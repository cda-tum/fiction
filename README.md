# Let there be a fiction

This code base provides a framework for **fi**eld-**c**oupled **t**echnology-**i**ndependent **o**pen **n**anocomputing
in C++14 using the [EPFL Logic Synthesis Libraries](https://github.com/lsils/lstools-showcase). *fiction* focuses on the
physical design of emerging nanotechnologies. As a promising class of post-CMOS technologies,
[Field-coupled Nanocomputing (FCN)](https://www.springer.com/de/book/9783662437216) devices like Quantum-dot Cellular
Automata (QCA) in manifold forms (e.g. atomic or molecular), Nanomagnet Logic (NML) devices, and many more, allow for high
computing performance with tremendously low power consumption without the flow of electric current.

With ongoing research in the field, it is unclear, which technology will eventually be competing with CMOS.
To be as generic as possible, *fiction* is able to perform physical design tasks for FCN circuit layouts on a data
structure that abstracts from a particular technology or cell design. Using an extensible set of gate libraries,
technologies, and cell types, these can be easily translated into whatever FCN technology is desired.

### Implemented physical design algorithms

Thus for, *fiction* provides two types of physical design approaches.

First, an [exact approach](https://ieeexplore.ieee.org/document/8342060)
([PDF](http://www.informatik.uni-bremen.de/agra/doc/konf/2018DATE_ExactMethodforDesignExplorationOfQCA.pdf)) determines
layouts which are optimal in terms of circuit area (by this, solving an [NP-hard problem](https://dl.acm.org/citation.cfm?id=3312661)
([PDF](http://iic.jku.at/files/eda/2019_jetc_placement_routing_field_coupled_nanocomputing_circuits_is_np_complete.pdf)) in
an exact fashion). The technique utilizes [Z3](https://github.com/Z3Prover/z3) by Microsoft Research, a solver for
Satisfiability Modulo Theories (SMT). While the approach is only feasible for small circuits, it generates the smallest layouts.
(See [SMT-based physical design](#smt-based-exact).)

Additionally, a [scalable method](https://dl.acm.org/citation.cfm?id=3287705)
([PDF](http://www.informatik.uni-bremen.de/agra/doc/konf/2019_ASP-DAC_Scalable_Design_for_Field-coupled_Nanocomputing_Circuits.pdf))
is implemented which is based on Orthogonal Graph Drawing (OGD). It has a huge runtime advantage compared to the exact approach.
Although the layouts generated by this approach are not optimal in terms of area, this technique is applicable even for larger
circuits and provides results in reasonable runtime. (See [OGD-based physical design](#ogd-based-ortho).)

This is ongoing research and more algorithms are to come!

### Supported technologies

So far, created layouts can be converted into QCA circuits using a custom version of the
[QCA-ONE](https://ieeexplore.ieee.org/document/7538997/) gate library. Those can be written as files for the
[QCADesigner](https://waluslab.ece.ubc.ca/qcadesigner/) to run physical simulations. Also, [SVG graphics](#svg-export) can be
generated to quickly visualize created circuits.

More technologies and libraries are to come!

## Design Features

To be as generic as possible regarding support for different technologies in its data types, *fiction* implements many design features
found in the literature. This section gives a quick overview.

### Tile-based vs. cell-based layouts

As [research suggests](https://www.mdpi.com/2079-9268/8/3/31), it might not be possible to apply external clocks to individual cells in
final (cell-based) layouts. Since clocking is crucial, that is why tile-based layouts are widely used where groups of cells forming logic
entities got the same clock assigned. Even though, tile-based layouts provide better abstraction from physics and more stable signals,
cell-based layouts are still used in many published papers right now. Hence, *fiction* uses tile-based layouts as its standard layout
datatype `fcn_gate_layout` but also supports cell-wise clocking in `fcn_cell_layout`. Furthermore, gate layouts can be compiled down
to cell based ones using an `fcn_gate_library` in a [physical synthesis](#physical-synthesis) step.

To support a new cell technology, a new refinement of `fcn_gate_library` must be implemented, and some adjustments to `port_router` need
to be done.

### Clocking schemes

There are highly regular clocking schemes proposed for FCN technologies which can be used as a floor plan for placement, routing, and
timing i.e. physical design. However, sometimes it can make sense to have more degree of freedom and assign clock numbers on the fly.
That is why *fiction* supports regular and irregular clocking schemes with variable amounts of clock numbers as QCA e.g. uses
four clock phases but NML needs only three.

Built-in schemes are


| [2DDWave](https://ieeexplore.ieee.org/document/1717097) (3 or 4 phases) | [USE](https://ieeexplore.ieee.org/document/7219390) (4 phases) | [RES](https://www.tandfonline.com/doi/abs/10.1080/21681724.2019.1570551) (4 phases) | [BANCS](https://ieeexplore.ieee.org/document/8533251) (3 phases) |
|:-----------------------------------------------------------------------:|:--------------------------------------------------------------:|:-----------------------------------------------------------------------------------:|:----------------------------------------------------------------:|
| <img src="img/2ddwave.png" alt="2DDWave" height="200"/>                 | <img src="img/use.png" alt="USE" height="200"/>                | <img src="img/res.png" alt="RES" height="200"/>                                     | <img src="img/bancs.png" alt="BANCS" height="200"/>              |

plus the mentioned irregular open clocking (3 or 4 phases) that works via a clock map instead of a regular extrapolated cutout.

More clocking schemes can be easily implemented by adjusting `fcn_clocking_scheme`.

### Wire crossings

<img src="img/cross.png" alt="Second layer crossing" align="left" width="200"/>

With many FCN technologies considered planar, wire crossings should be minimized if possible. However, there are some options in QCA where,
using a second layer, crossings over short distances and co-planar rotated cells become possible. As both are just technical implementations
of the same concept, *fiction* supports crossings as wires in a second grid layer in its data structures. They will also be represented as
such in corresponding SVG and QCADesigner output. However, not that it is to be interpreted as the concept of crossings and could also be
realized co-planar.

Wires are only allowed to cross other wires! Wires crossing gates is considered to lead to unstable signals.

### Gate pins vs. designated I/Os

<img src="img/io.png" alt="Input pin and cell output" align="right" width="200"/>

In the literature, both is seen: having input cells (pins) directly located in the gate structure or using designated I/O elements which are
located outside of gates. This distinction only makes sense on the gate-level and *fiction* supports both approaches and offers usage in
all implemented physical design algorithms.

### Multi wires

<img src="img/multi.png" alt="Multi wires" align="left" width="200"/>

Gate-level abstraction has its limits. Often, chip area is wasted when only using a single wire per tile. In *fiction*, data types support
the use of arbitrarily many wire elements per tile in theory. If the resulting circuit should be compiled down to cell-level, an
`fcn_gate_library` with respective tile dimensions which can handle that many wires is required. Discussion in literature is still
ongoing if multi wires can be supported by physics which is why making physical design algorithms incorporating them is not a top priority
right now. However, feel free to change that.

### Synchronization elements

<img src="img/se.png" alt="Synchronization element" align="right" width="150"/>

When using the external clocks in smart ways, artificial [synchronization elements](https://ieeexplore.ieee.org/document/8626294)
([PDF](http://www.informatik.uni-bremen.de/agra/doc/konf/2018NANO_SynchronizationOfClockedFieldCoupledCircuits.pdf)) can be created that
hold signals longer and therefore forming latches and even overcome local clock synchronization issues in final designs. By elongating the
the *Hold* phase of certain tiles, information is stalled in those tiles for some phases. This requires an additional external clock but
can gain several benefits. As mentioned, those tiles can form latches when holding signals by a multiple of *n* phases, where *n* is the
clock number in the design (e.g. 4 for QCA). When holding the signals for any *m* that is *not* a multiple *n*, the information flow
changes and therefore one can
[ignore local clock synchronization issues](http://www.informatik.uni-bremen.de/agra/doc/konf/2019_ISVLSI_Ignore_Clocking_Constraints_An_Alternative_Physical_Design_Methodology_for_Field-coupled_Nanotechnologies.pdf)
([PDF](http://www.informatik.uni-bremen.de/agra/doc/konf/2019_ISVLSI_Ignore_Clocking_Constraints_An_Alternative_Physical_Design_Methodology_for_Field-coupled_Nanotechnologies.pdf)).

These clock latches are ready for use in *fiction* and are supported by the [exact physical design approach](#smt-based-exact).

### Cost metrics

Designed layouts can be evaluated with regard to several cost functions. Some are substantial and can be printed directly, others will be
logged only if desired. The following metrics are currently implemented:

Gate-level layouts:

- Circuit dimension in tiles
- Number of gate tiles
- Number of wire tiles
- Number of wire crossings
- Number of clock latches ([synchronization elements](#synchronization-elements))
- Critical path
- Throughput
- Bounding box of non-free tiles
- Energy dissipation based on a [physical model](https://ieeexplore.ieee.org/document/8246526) (QCA only)

Cell-level layouts:

- Circuit dimension in cells
- Number of cells

Learn more about [benchmarking and scripting](#benchmarking-and-scripting).

## Building process

Git, g++, cmake and the Boost libraries are necessary in order to build *fiction*. Since a Python interpreter and
GNU readline are utilized by some dependencies, it is also recommended to set them up.
If on *Ubuntu*, one should be fine installing them with this command:

```sh
sudo apt-get install git g++ cmake libboost-all-dev python libreadline-dev
```

Note that there is no guarantee that a system does not lack some required packages which are not listed here!
CMake will print information about missing dependencies during the build process.

When checking out this repository, make sure to also clone all submodules by using

```sh
git clone --recursive
```

Several third-party libraries will be cloned within the `libs` folder. The `cmake` build process will take care of
them automatically. Should the repository have been cloned before,

```sh
git submodule update --init --recursive
```

will fetch the latest version of all external modules used.

Afterwards, *fiction* is ready to be built. Simply enter the following commands:

```sh
cd fiction
mkdir build
cd build
cmake ..
make
```

This process may take a while!

One have the choice to change the `cmake` call to `cmake -DCMAKE_BUILD_TYPE=Debug ..` if building with debug
information is preferred. The build mode can also be toggled via the `ccmake` CLI. Note that building with
debug information will have a significant negative impact on *fiction*'s runtime!

### Building on Windows Subsystem for Linux (WSL)

To build *fiction* on Windows, WSL has to be installed. Instructions can be found on
[the official Windows page](https://docs.microsoft.com/en-us/windows/wsl/install-win10). During installation, it is highly
recommended to pick *Ubuntu* as the Linux distribution. Then, simply follow the build steps listed above on the WSL.

If one wants to use [Visual Studio](https://visualstudio.microsoft.com/de/) (VS) to work with the source code, have a look at
how to [Target WSL from VS](https://devblogs.microsoft.com/cppblog/targeting-windows-subsystem-for-linux-from-visual-studio/),
[Cross Platform C++ with VS](https://devblogs.microsoft.com/cppblog/using-visual-studio-for-cross-platform-c-development-targeting-windows-and-linux/),
and [CMake with VS](https://docs.microsoft.com/en-us/cpp/linux/cmake-linux-project?view=vs-2017).

### Troubleshooting

On some CMake systems, it might be necessary to type

```sh
make z3
make fiction
```

after the `cmake` call instead of just `make` to guarantee the correct order of build steps. Try this if the initial
call leads to some kind of error messages revolving around Z3.

#### Troubleshooting while using the WSL

If one cannot install `libboost-all-dev` (the error might look like this: `Unable to locate package libboost-all-dev`) 
it should be fixed by adding `universe` to the repositories and trying again:

```sh
sudo add-apt-repository universe
sudo apt-get update
sudo apt-get install libboost-all-dev
```

Note that it is possible that *alice* does not find the readline-library even though it is 
installed. CMake will print information about this with a warning: 
```
CMake Warning at libs/alice/include/CMakeLists.txt:35 (message):
  Cannot find readline library, fall back to native interface.
```
There is no solution to this as of now and it may lead to missing tab-completion while interacting with *fiction*.

## Using the command line interface (CLI)

The [building process](#building-process) generates an executable called `fiction`. A simple non-exhaustive workflow
is described in the following. To get some information about the available commands, run `fiction` with a help flag:

```sh
./fiction --help
```

Starting the interactive mode by entering `fiction` greets the user with a prompt. Again, input of `help` produces a
list of available commands. One can generate a plain text full documentation by entering `help --docs <filename>`. 

### Preface

*fiction* utilizes the CLI [alice](https://github.com/msoeken/alice) by Mathias Soeken. It provides a flexible
store-based architecture. A store for logic networks holds specifications which then can be transformed into
FCN circuit layouts. Specifications can be provided in terms of synthesized structural Verilog netlist files using
`assign` statements and Boolean primitives. Using the tool [ABC](https://github.com/berkeley-abc/abc) for example,
such files can be generated by

```sh
read spec.bench
strash
write spec.v
```

ABC supports numerous file formats from which `.bench` is just an example one. *fiction* also comes with a lot of preset
netlists in the `benchmarks` folder.

### Stores

Stores hold data structures obtained by parsing, designing, or compiling. There are stores for

- `logic_network` (`-w`)
- `fcn_gate_layout` (`-g`)
- `fcn_cell_layout` (`-c`)

objects. Several generic commands typed in interactive mode work on all kinds of stores and therefore need to be
given a store flag as specified by the list above. Applicable commands are for instance

- `store`: shows a brief listing of the contained elements
- `current <n>`: changes the active store element to element number `<n>` (otherwise the newest entry is active)
- `ps`: prints statistical data and cost metrics of the active store element
- `print`: prints a textual representation of the store element to the standard output

For an exhaustive overview of available commands, see the full [alice documentation](https://libalice.readthedocs.io/en/latest/index.html).

### Circuit specifications in terms of logic networks

As mentioned before, `logic_network` objects parsed from Verilog files serve as specifications for FCN circuits to be
designed. In other words, `logic_network` objects are to be mapped onto grid-like structures under FCN constraints.

When in *fiction*'s interactive mode, one can enter `read <filename>` to read a logic network into a store or
`read <directory>` to parse all parsable files within that given directory powered by the
[lorina](https://github.com/hriener/lorina) parser by Heinz Riener respectively. The flag `-s` allows prior sorting.
The content of the logic network store can be briefly viewed by entering `store -w` whereas `print -w` writes a
[Graphviz](https://www.graphviz.org/) dot file of the current network to the standard output.

From here on, FCN circuits can be designed.

### Physical design

The above mentioned exact (SMT-based) and scalable (OGD-based)
[implemented physical design algorithms](#implemented-physical-design-algorithms) can be called on the currently active
`logic_network` in store by `exact` and `ortho` respectively. Find some information and parameters about them below.

Generated FCN gate layouts are also saved in stores. Entering `store -g` shows a list of all gate layouts available.
Statistical information about store elements can be printed using command `ps -g` and could produce the following output.

```
c17 - 5 × 7, #G: 18, #W: 18, #C: 3, #L: 0, CP: 11, TP: 1/1
```

This displays (from left to right) the name of the layout, the dimension in tiles, the number of gate tiles (including
designated I/O pins and fan-outs), wire elements, crossings, latches
([synchronization elements](https://ieeexplore.ieee.org/document/8626294),
[PDF](http://www.informatik.uni-bremen.de/agra/doc/konf/2018NANO_SynchronizationOfClockedFieldCoupledCircuits.pdf)),
the length of the critical path, and the throughput of the design (where 1/1 is maximum throughput).

#### SMT-based (`exact`)

Satisfiability Modulo Theories (SMT) is used to describe the physical design problem in first-order logic. The SMT solver
engine [Z3](https://github.com/Z3Prover/z3) is then used to extract a satisfiable model from the resulting formula
which is then translated back into a valid solution to the original physical design problem. For more information,
see [the paper](https://ieeexplore.ieee.org/document/8342060)
([PDF](http://www.informatik.uni-bremen.de/agra/doc/konf/2018DATE_ExactMethodforDesignExplorationOfQCA.pdf)).

This exact approach generates minimal layouts in terms of circuit area. Since determining minimal FCN circuits for given
specifications is an [NP-hard problem](https://dl.acm.org/citation.cfm?id=3312661)
([PDF](http://iic.jku.at/files/eda/2019_jetc_placement_routing_field_coupled_nanocomputing_circuits_is_np_complete.pdf)),
the process takes a while and is only suitable for rather small benchmarks with just a few gates.

On the other hand, this approach is highly parameterizable and can produce results for a variety of settings.
The most important ones are

- Define the used clocking scheme (`-s ...`)
- Enable wire crossings (`-x`)
- Enable designated I/O ports (`-i`)
- Route all I/Os to the layout's borders (`-b`)
- Allow artificial clock latches (`-a`)
- Allow for de-synchronized circuits (`-p`)

See `exact -h` for a full list.

#### OGD-based (`ortho`)

Orthogonal Graph Drawing (OGD) is a well known problem in graph theory that remarkably resembles the physical design
problem for tile-based FCN circuits. Even though the problem of determining minimal drawings is hard in general, there
exist linear time approximations for 3-graphs. Luckily, AOIGs can be substituted until they are 3-graphs. Using a
topological ordering and a certain direction assignment, even large circuits can be designed in reasonable runtime.
For more information, see [the paper](https://dl.acm.org/citation.cfm?id=3287705)
([PDF](http://www.informatik.uni-bremen.de/agra/doc/konf/2019_ASP-DAC_Scalable_Design_for_Field-coupled_Nanocomputing_Circuits.pdf)).

This scalable approach only works on logic networks which are AOIGs (MAJ gates do not work). The clocking scheme is fixed to
[2DDWave](https://ieeexplore.ieee.org/document/1717097) and the algorithm can only be slightly parameterized
(see `ortho -h`).

### Physical synthesis

As mentioned above, gate-level layouts can be compiled down to cell-level ones in a physical synthesis step. An
`fcn_gate_library` is required to do so. The command `cell` does exactly this, where the `-l` option indicates the gate
library to use. Currently, only [QCA-ONE](https://ieeexplore.ieee.org/document/7538997/) is available which is the default
setting. Cell-based layouts are also saved in stores which can be accessed by typing `store -c`. Due to significantly larger
size of cell layouts compared to gate layouts, the `print -c` command to write layouts to the terminal should be used carefully.
See [SVG export](#svg-export) instead.

Nevertheless, one can use `qca <filename>` to create a [QCADesigner](https://waluslab.ece.ubc.ca/qcadesigner/) file for
running physical simulations. If no filename is given, the stored layout name will be used and the file will be written
to the current folder.

### SVG export

Cell-level layouts can be exported as scalable vector graphics (`.svg` files) using the command `show -c`. This will
immediately open the standard SVG program immediately to give a more sophisticated visual representation of the
current cell layout in store. If one wants to just generate the SVG file without opening it in the standard viewer,
`show -c <filename>.svg --silent` can be used.

Alternatively, open the exported file with a different program by using `show -c --program "\"google-chrome\" {}"` for
instance to open it with the Chrome browser. Note that this behavior is platform-dependent and might not properly work
under every system. For more information see `show -h` or the full
[alice documentation](https://libalice.readthedocs.io/en/latest/index.html).

The used color scheme is based on the one known from [QCADesigner](https://waluslab.ece.ubc.ca/qcadesigner/).

There is also an option for showing a simple version of cells that leaves out the quantum dots and clock zone numbers.
This makes the exported files significantly smaller, especially for large layouts. The corresponding flag is `-s`.

### Benchmarking and scripting

All design steps explained in the previous sections can also be specified within a single *fiction script* file like
the following called `c17_synth.fs`

```sh
read ../benchmarks/ISCAS85/c17.v
exact -xibs 2ddwave4
ps -g
cell
show -c
exact -ps use
ps -g
cell
show -c
```

which can be executed by `./fiction -ef c17_synth.fs -l c17_log.json` where statistics are to be logged in a JSON file
called `c17_log.json`.  The following table presents the results.

| `exact -xibs 2ddwave4`                                               |  `exact -ps use`                                                |
|:--------------------------------------------------------------------:|:---------------------------------------------------------------:|
|<img src="img/compare1.png" alt="exact -xibs 2ddwave4" width="300"/>  | <img src="img/compare2.png" alt="exact -ps use" width="300"/>   |
| ```c17 - 5 × 7, #G: 18, #W: 18, #C: 3, #L: 0, CP: 11, TP: 1/1```     | ```c17 - 4 × 5, #G: 11, #W: 7, #C: 0, #L: 0, CP: 13, TP: 1/3``` |


These scripts can also be nested. One can use `< script.fs` within a *fiction script* to load `script.fs` in that very position.
A script called `shortcuts.fs` has been placed in the top level folder. It can be loaded on start-up by calling
`./fiction -if ../shortcuts.fs` in the build folder. This makes predefined commands and flows available as shortcuts.
Try `synth xibs use` for instance to perform the whole flow of design (utilizing `USE` clocking) and physical
synthesis down to cell-level including visual representation.

Additionally, *fiction* itself can be part of a bash script. Consider the following snippet

```sh
for filepath in ../benchmarks/TOY/*.v; do
    f="${filepath##*/}"
    ./fiction -c "read $filepath; ortho; cell; qca ${f%.*}.qca"
done
```

where the for-loop iterates over all Verilog files in the `../benchmarks/TOY/` folder. Using the flag `-c`, a
semicolon-separated list of commands can be entered in *fiction*. In this case, the files are to be read in a store,
designed using the `ortho` algorithm, synthesized to cell-level, and written as QCA using their original file
name.

## Uninstall

Since all tools were built locally, simply delete the git folder cloned initially to uninstall this project.

## References

A brief technical report summarizing the features of *fiction* is available at [arXiv](https://arxiv.org/abs/1905.02477).

If you use *fiction* in your work, I would appreciate if you cited

> Marcel Walter, Robert Wille, Frank Sill Torres, Daniel Große and Rolf Drechsler: "fiction: An Open Source Framework
> for the Design of Field-coupled Nanocomputing Circuits", 2019, **arXiv:1905.02477**.

```tex
@misc{fiction,
  author = {Marcel Walter and Robert Wille and Frank Sill Torres and Daniel Gro{\ss}e and Rolf Drechsler},
  title = {{fiction: An Open Source Framework for the Design of Field-coupled Nanocomputing Circuits}},
  archivePrefix = {arXiv}, 
  eprint = {1905.02477},
  year = {2019},
  month = {May}
}
```

Furthermore, if the aforementioned physical design techniques are helpful for you, please find corresponding
citations for the [exact approach](https://ieeexplore.ieee.org/document/8342060)
([BibTeX](https://scholar.googleusercontent.com/scholar.bib?q=info:4sV4HLtAl5MJ:scholar.google.com/&output=citation&scisig=AAGBfm0AAAAAXNVeLMDWESEscPWEEn-IZ3Cg_8q9ph6i&scisf=4&ct=citation&cd=-1))
and the [scalable method](https://dl.acm.org/citation.cfm?id=3287705)
([BibTeX](https://scholar.googleusercontent.com/scholar.bib?q=info:q_5SZf8jCP0J:scholar.google.com/&output=citation&scisig=AAGBfm0AAAAAXNVeTetPuxrHHCntTQFhw0TaYhjIIIYP&scisf=4&ct=citation&cd=-1))
online.

The *fiction* framework is part of my PhD Thesis entitled "Layout of Large Scale Field-coupled Nanocomputing Circuits"
(working title). Please find my publication list [here](http://www.informatik.uni-bremen.de/agra/eng/pub.php?search=Marcel%20Walter).

## Acknowledgments

I would like to thank my co-authors for countless helpful discussions and support with this framework. Also, I thank
Gregor Kuhn for implementing the SVG export and for reporting troublesome bugs; and Mario Kneidinger for code
contributions, pointing out the Visual Studio resources and documentation inconsistencies on my side.

## Disclaimer

This is academic software made available under the CRAPL license. For more information see the LICENSE file.
