# Let there be a *fiction*

[![Ubuntu CI](https://github.com/marcelwa/fiction/actions/workflows/ubuntu.yml/badge.svg)](https://github.com/marcelwa/fiction/actions/workflows/ubuntu.yml)
[![macOS CI](https://github.com/marcelwa/fiction/actions/workflows/macos.yml/badge.svg)](https://github.com/marcelwa/fiction/actions/workflows/macos.yml)
[![Windows CI](https://github.com/marcelwa/fiction/actions/workflows/windows.yml/badge.svg)](https://github.com/marcelwa/fiction/actions/workflows/windows.yml)
[![codecov](https://codecov.io/gh/marcelwa/fiction/branch/v0.4.0/graph/badge.svg?token=SUPC5N6KFU)](https://codecov.io/gh/marcelwa/fiction)
[![Documentation Status](https://readthedocs.org/projects/fiction/badge/?version=rtfd)](https://fiction.readthedocs.io/en/rtfd/?badge=rtfd)

This code base provides a framework for **fi**eld-**c**oupled **t**echnology-**i**ndependent **o**pen **n**anocomputing
in C++17 using the [EPFL Logic Synthesis Libraries](https://github.com/lsils/lstools-showcase). *fiction* focuses on the
physical design of emerging nanotechnologies. As a promising class of post-CMOS technologies,
[Field-coupled Nanocomputing (FCN)](https://www.springer.com/de/book/9783662437216) devices like Quantum-dot Cellular
Automata (QCA) in manifold forms (e.g. atomic or molecular), Nanomagnet Logic (NML) devices, and many more, allow for high
computing performance with tremendously low power consumption without the flow of electric current.

With ongoing research in the field, it is unclear, which technology will eventually be competing with CMOS. To be as
generic as possible, *fiction* is able to perform physical design tasks for FCN circuit layouts on data structures that
abstract from particular technology or cell design. Using an extensible set of gate libraries, technologies, and cell
types, these can easily be compiled down to any desired FCN technology for physical simulation.

The *fiction* framework is academic software and aims at researchers and developers in the FCN domain who want to obtain
cell-accurate circuit layouts from logical specifications or who want to implement their own physical design algorithms.

For these use cases, *fiction* provides a [header-only library](https://fiction.readthedocs.io/en/latest/getting_started.html#using-fiction-as-a-header-only-library)
that provides data types and algorithms for recurring tasks, e.g., logic network and layout types on different abstraction
levels, clocking schemes, gate libraries, placement, routing, clocking, and verification algorithms, etc. Additionally,
*fiction* comes with an ABC-like [CLI tool](https://fiction.readthedocs.io/en/latest/getting_started.html#using-fiction-as-a-stand-alone-cli-tool)
that allows quick access to its core functionality.

Learn more by referring to the [full documentation](https://fiction.readthedocs.io/).

If you have any questions, comments, or suggestions, please do not hesitate to get in touch.


### Implemented physical design algorithms

Thus for, *fiction* provides three physical design approaches.

First, an [exact approach](https://ieeexplore.ieee.org/document/8342060)
([PDF](http://www.informatik.uni-bremen.de/agra/doc/konf/2018DATE_ExactMethodforDesignExplorationOfQCA.pdf)) determines
layouts which are optimal in terms of circuit area (by this, solving an [NP-hard problem](https://dl.acm.org/citation.cfm?id=3312661)
([PDF](http://iic.jku.at/files/eda/2019_jetc_placement_routing_field_coupled_nanocomputing_circuits_is_np_complete.pdf)) in
an exact fashion). The technique utilizes [Z3](https://github.com/Z3Prover/z3) by Microsoft Research, a solver for
Satisfiability Modulo Theories (SMT). While the approach is only feasible for small circuits, it generates the most compact layouts.
(See [SMT-based physical design](#smt-based-exact).)

Additionally, a [scalable method](https://dl.acm.org/citation.cfm?id=3287705)
([PDF](http://www.informatik.uni-bremen.de/agra/doc/konf/2019_ASP-DAC_Scalable_Design_for_Field-coupled_Nanocomputing_Circuits.pdf))
is implemented which is based on Orthogonal Graph Drawing (OGD). It has a huge runtime advantage compared to the exact approach.
Although the layouts generated by this approach are not optimal in terms of area, this technique is applicable even for larger
circuits and provides results in reasonable runtime. (See [OGD-based physical design](#ogd-based-ortho).)

Finally, an experimental [one-pass algorithm](http://www.informatik.uni-bremen.de/agra/doc/konf/ASP-DAC2021_One-pass_Synthesis_for_Field-coupled_Nanocomputing_Technologies.pdf)
([PDF](http://www.informatik.uni-bremen.de/agra/doc/konf/ASP-DAC2021_One-pass_Synthesis_for_Field-coupled_Nanocomputing_Technologies.pdf))
is provided that uses SAT solver calls to perform logic synthesis and physical design combined in a single run. This
enables absolute minimality, but has the largest runtime overhead. Thereby, it is not suited for large-scale circuits.
(See [SAT-based one-pass synthesis](#sat-based-one-pass-synthesis-onepass).)

Furthermore, *fiction* provides [formal verification](http://www.informatik.uni-bremen.de/agra/doc/konf/2020_DAC_Verification_for_Field-coupled_Nanocomputing_Circuits.pdf)
([PDF](http://www.informatik.uni-bremen.de/agra/doc/konf/2020_DAC_Verification_for_Field-coupled_Nanocomputing_Circuits.pdf))
and utility functions. See the [CLI functionality](#Using-the-command-line-interface-(CLI)) for more details.

### Supported technologies

Created layouts can be converted into QCA circuits using a slightly adjusted version of the
[QCA-ONE](https://ieeexplore.ieee.org/document/7538997/) gate library. Those can be written as files for the
[QCADesigner](https://waluslab.ece.ubc.ca/qcadesigner/) to run physical simulations. Also, [SVG graphics](#svg-export) can be
generated to quickly visualize created circuits.

Additionally, thanks to a cooperation with the Department of Electronics and Telecommunications at Politecnico di Torino,
first support for iNML circuits has been achieved. To enable integration with [ToPoliNano and MagCAD](https://topolinano.polito.it/),
the column-based clocking scheme and the custom gate library used in ToPoliNano are implemented alongside. Generated
iNML circuits can be written as QCC files for ToPoliNano and MagCAD to perform physical simulations. SVG visualization will
follow in a future update. 

## Design Features

To be as generic as possible regarding support for different technologies in its data types, *fiction* implements many design features
found in the literature. This section gives a quick overview.

### Tile-based vs. cell-based layouts

As [research suggests](https://www.mdpi.com/2079-9268/8/3/31), it might not be possible to apply external clocks to individual cells in
final (cell-based) layouts. Since clocking is crucial, that is why tile-based layouts are widely used where groups of cells forming logic
entities got the same clock assigned. Even though, tile-based layouts provide better abstraction from physics and more stable signals,
cell-based layouts are still used in many published papers right now. Hence, *fiction* uses tile-based layouts as its standard layout
datatype `fcn_gate_layout` but also supports cell-wise clocking in `fcn_cell_layout`. Furthermore, gate layouts can be compiled down
to cell based ones using an `fcn_gate_library` in a [physical synthesis](#physical-synthesis) step.

To support a new cell technology, a new refinement of `fcn_gate_library` must be implemented, and some adjustments to `port_router` need
to be done.

### Clocking schemes

There are highly regular clocking schemes proposed for FCN technologies which can be used as a floor plan for placement, routing, and
timing i.e. physical design. However, sometimes it can make sense to have more degree of freedom and assign clock numbers on the fly.
That is why *fiction* supports regular and irregular clocking schemes with variable amounts of clock numbers as QCA e.g. uses
four clock phases but iNML needs only three.

Built-in schemes are


| [2DDWave](https://ieeexplore.ieee.org/document/1717097) (3 or 4 phases) | [USE](https://ieeexplore.ieee.org/document/7219390) (4 phases) | [RES](https://www.tandfonline.com/doi/abs/10.1080/21681724.2019.1570551) (4 phases) | [BANCS](https://ieeexplore.ieee.org/document/8533251) (3 phases) |  [ToPoliNano](https://topolinano.polito.it/) (3 or 4 phases)  |
|:-----------------------------------------------------------------------:|:--------------------------------------------------------------:|:-----------------------------------------------------------------------------------:|:----------------------------------------------------------------:|:-------------------------------------------------------------:|
| <img src="img/2ddwave.png" alt="2DDWave" height="200"/>                 | <img src="img/use.png" alt="USE" height="200"/>                | <img src="img/res.png" alt="RES" height="200"/>                                     | <img src="img/bancs.png" alt="BANCS" height="200"/>              | <img src="img/topolinano.png" alt="ToPoliNano" height="200"/> |

plus the mentioned irregular open clocking (3 or 4 phases) that works via a clock map instead of a regular extrapolated cutout.

More clocking schemes can be easily implemented by adjusting `fcn_clocking_scheme`.

### Wire crossings

<img src="img/cross.png" alt="Second layer crossing" align="left" width="200"/>

With many FCN technologies considered planar, wire crossings should be minimized if possible. However, there are some options in QCA where,
using a second layer, crossings over short distances and co-planar rotated cells become possible. As both are just technical implementations
of the same concept, *fiction* supports crossings as wires in a second grid layer in its data structures. They will also be represented as
such in corresponding SVG and QCADesigner output. However, note that it is to be interpreted as the concept of crossings and could also be
realized co-planar.

Wires are only allowed to cross other wires! Wires crossing gates is considered to lead to unstable signals.

### Gate pins vs. designated I/Os

<img src="img/io.png" alt="Input pin and cell output" align="right" width="200"/>

In the literature, both is seen: having input cells (pins) directly located in the gate structure or using designated I/O elements which are
located outside of gates. This distinction only makes sense on the gate-level and *fiction* supports both approaches and offers usage in
all implemented physical design algorithms.

### Multi wires

<img src="img/multi.png" alt="Multi wires" align="left" width="200"/>

Gate-level abstraction has its limits. Often, chip area is wasted when only using a single wire per tile. In *fiction*, data types support
the use of arbitrarily many wire elements per tile in theory. If the resulting circuit should be compiled down to cell-level, an
`fcn_gate_library` with respective tile dimensions which can handle that many wires is required. Discussion in literature is still
ongoing if multi wires can be supported by physics which is why making physical design algorithms incorporating them is not a top priority
right now. However, feel free to change that.

### Synchronization elements

<img src="img/se.png" alt="Synchronization element" align="right" width="150"/>

When using the external clocks in smart ways, artificial [synchronization elements](https://ieeexplore.ieee.org/document/8626294)
([PDF](http://www.informatik.uni-bremen.de/agra/doc/konf/2018NANO_SynchronizationOfClockedFieldCoupledCircuits.pdf)) can be created that
hold signals longer and therefore forming latches and even overcome local clock synchronization issues in final designs. By elongating the
the *Hold* phase of certain tiles, information is stalled in those tiles for some phases. This requires an additional external clock but
can gain several benefits. As mentioned, those tiles can form latches when holding signals by a multiple of *n* phases, where *n* is the
clock number in the design (e.g. 4 for QCA). When holding the signals for any *m* that is *not* a multiple *n*, the information flow
changes and therefore one can
[ignore local clock synchronization issues](https://ieeexplore.ieee.org/document/8839546)
([PDF](http://www.informatik.uni-bremen.de/agra/doc/konf/2019_ISVLSI_Ignore_Clocking_Constraints_An_Alternative_Physical_Design_Methodology_for_Field-coupled_Nanotechnologies.pdf)).

These clock latches are ready for use in *fiction* and are supported by the [exact physical design approach](#smt-based-exact).

### Cost metrics

Designed layouts can be evaluated with regard to several cost functions. Some are substantial and can be printed directly, others will be
logged only if desired. The following metrics are currently implemented:

Gate-level layouts:

- Circuit dimension in tiles
- Number of gate tiles
- Number of wire tiles
- Number of wire crossings
- Number of clock latches ([synchronization elements](#synchronization-elements))
- Critical path
- Throughput
- Bounding box of non-free tiles
- Energy dissipation based on a [physical model](https://ieeexplore.ieee.org/document/8246526) (QCA only)

Cell-level layouts:

- Circuit dimension in cells
- Number of cells
- Area usage in nmÂ²

Learn more about [benchmarking and scripting](#benchmarking-and-scripting).

### Logic synthesis

*fiction* focuses on physical design, i.e., placement, routing, and timing, of circuits and takes logic synthesis for granted. As
described [later](#preface), the tool [ABC](https://github.com/berkeley-abc/abc) for example could be used to generate synthesized
logic networks which can be passed to *fiction* as circuit specifications.

However, *fiction* makes use of the logic network library [mockturtle](https://github.com/lsils/mockturtle) by Mathias Soeken, which
comes with various logic synthesis and optimization algorithms. The reader may feel free to make use of them prior to physical
design in order to obtain optimized layouts.

The `mockturtle` library is also used to provide functionality for generating networks from truth tables as well as random networks. 
See the section about [logic networks](#circuit-specifications-in-terms-of-logic-networks) for more information about network
generation and manipulation.

The [one-pass synthesis algorithm](#sat-based-one-pass-synthesis) can be utilized for combined logic synthesis and
physical design from truth table or logic network specifications.

## Building process

*For building within a Docker container, see the [Docker directions](#docker).*

Git, g++, cmake and the Boost libraries are necessary in order to build *fiction*. Since a Python interpreter and
GNU readline are utilized by some dependencies, it is also recommended to set them up.

When checking out this repository, make sure to also clone all submodules by using

```sh
git clone --recursive
```

Several third-party libraries will be cloned within the `libs` folder. The `cmake` build process will take care of
them automatically. Should the repository have been cloned before,

```sh
git submodule update --init --recursive
```

will fetch the latest version of all external modules used.

Afterwards, *fiction* is ready to be built.

### Linux (Ubuntu)

Use this command to install all necessary libraries.

```sh
sudo apt-get install git g++ cmake libboost-all-dev graphviz python3 python3-dev libreadline-dev
```

Note that there is no guarantee that a system does not lack some required packages which are not listed here!
CMake will print information about missing dependencies during the build process. Simply enter the following commands:

```sh
cd fiction
mkdir build
cd build
cmake ..
make
```

This process may take a while!

One have the choice to change the `cmake` call to `cmake -DCMAKE_BUILD_TYPE=Debug ..` if building with debug
information is preferred. The build mode can also be toggled via the `ccmake` CLI. Note that building with
debug information will have a significant negative impact on *fiction*'s runtime!


The [one-pass synthesis algorithm](#sat-based-one-pass-synthesis) is embedded via the Python3 script
[Mugen](https://github.com/whaaswijk/mugen) by Winston Haaswijk using [pybind11](https://github.com/pybind/pybind11).
It has some further Python dependencies that can be installed via `pip`:

```sh
pip3 install python-sat wrapt_timeout_decorator graphviz
```

The Python3 integration may cause issues on some systems. In case, you want to utilize Mugen, make sure to follow the
setup thoroughly. Note that Mugen requires at least Python 3.7! Mugen can be disabled via toggling the `ENABLE_MUGEN`
flag, e.g., calling

```sh
cmake -DENABLE_MUGEN=OFF ..
```

### Docker

[Docker](https://www.docker.com/) can be used to build an image to run *fiction* or to use it for development
purposes on all operating systems supported by Docker. Make sure you have Docker installed and if you are on
Windows, that you switched to Linux containers.

If Docker is set up correctly, you can download the [Dockerfile](https://github.com/marcelwa/fiction/blob/master/Dockerfile)
and build the image, which automatically clones the repository and builds fiction. To do so, execute

```sh
docker build .
```

in the directory that contains the Dockerfile.

This can take a while, as it downloads the necessary alpine image file, build tools, clones the repository, and
builds fiction. Especially building the Z3 solver takes a while. There is an optional build argument to run the
make command in parallel with 

```sh
docker build --build-arg NUMBER_OF_JOBS=<#> .
```
where `<#>` is the desired maximum number of jobs. Which value is prudent to use depends on your system and the
resources allocated by Docker. Reasonable values that should run on most systems without problems are values
between `2` and `8`.  If your build fails, try using a lower value or the default setting.

If everything finishes successfully, you can fetch the ID of your newly created image via the command

```sh
docker images
```

Run your image using

```sh
docker run -it <Image-ID>
```
where `<Image-ID>` has to be replaced with the respective ID.

This starts the image in a new container and automatically launches *fiction* in interactive mode.
You can quit with the command `quit`. If you don't want to automatically start *fiction* and instead
connect via shell, use command

```sh
docker run -it <Image-ID> /bin/sh
```

instead.

You will start in the directory `/fiction/` which contains the cloned git repository. All build files and the
*fiction* executable can be found in `/fiction/build/`.

Once the container is created, you should not use the `run` command to start the image every time, because
this always creates a new container. Instead, just reuse the already created container. You can see your docker
containers using command

```sh
docker ps -a
```

To start an existing container and attach to it, use

```sh
docker start -ai <Container-ID>
```

Depending on which `run` command you used, this may or may not automatically start *fiction*. You can use the
same parameter for `docker start` and `docker run` to switch between shell and *fiction*'s interactive mode.

You can also use the container for development purposes; depending on if you are used to develop with containers.
One way would be to use [Visual Studio Code](https://code.visualstudio.com/) (VSC) with the *Remote-Containers*
extension. You can either attach VSC to an already running container or you can let Visual Studio Code build its
own container. If you followed the previous steps, make sure the container is running. To do so, check if the
container is listed when you enter `docker ps`. If not, start it via `docker start <Container-ID>`. For further
information, see [Developing inside a Container](https://code.visualstudio.com/docs/remote/containers).

### Windows Subsystem for Linux (WSL)

To build *fiction* on Windows, WSL has to be installed. Instructions can be found on
[the official Windows page](https://docs.microsoft.com/en-us/windows/wsl/install-win10). During installation, it is highly
recommended to pick *Ubuntu* as the Linux distribution. Then, simply follow the build steps listed above on the WSL.

If one wants to use [Visual Studio](https://visualstudio.microsoft.com/de/) (VS) to work with the source code, have a look at
how to [Target WSL from VS](https://devblogs.microsoft.com/cppblog/targeting-windows-subsystem-for-linux-from-visual-studio/),
[Cross Platform C++ with VS](https://devblogs.microsoft.com/cppblog/using-visual-studio-for-cross-platform-c-development-targeting-windows-and-linux/),
and [CMake with VS](https://docs.microsoft.com/en-us/cpp/linux/cmake-linux-project?view=vs-2017).

#### Troubleshooting while using the WSL

If one cannot install `libboost-all-dev` (the error might look like this: `Unable to locate package libboost-all-dev`) 
it should be fixed by adding `universe` to the repositories and trying again:

```sh
sudo add-apt-repository universe
sudo apt-get update
sudo apt-get install libboost-all-dev
```

Note that it is possible that *alice* does not find the readline-library even though it is 
installed. CMake will print information about this with a warning: 
```
CMake Warning at libs/alice/include/CMakeLists.txt:35 (message):
  Cannot find readline library, fall back to native interface.
```
There is no solution to this as of now and it may lead to missing tab-completion while interacting with *fiction*.

### Visual Studio (MSVC)

***Disclaimer**: fiction was developed for Linux. Unexpected behavior might occur during an MSVC build or execution
of the resulting binary as this mode is not fully tested (but it could be made working with MSVC 14.16).
Apologies for any inconveniences you might face.*

Make sure you have CMake set up in Visual Studio and Boost and Python installed on your system.

Open a Visual Studio Command Prompt and navigate to `fiction\libs\z3`. Type

```batch
python scripts\mk_make.py
```

Add `-x` for 64-bit builds. Then enter

```batch
cd build
nmake
```

This process builds Z3 and might take a while. Afterwards, the CMake process can be triggered in Visual Studio.
Note that it can happen that the Boost Libraries are not detected correctly. In this case, two new CMake variables
can be defined to point CMake towards the installation directory. Simply add

```
-DBoost_CUSTOM_INCLUDE_DIRS=<include_path>
-DBoost_CUSTOM_LIBRARY_DIRS=<library_path>
```

as arguments to the CMake call.

Set `fiction.exe` as build target and run the build process. Note that it might be necessary to copy Boost DLLs into
your build folder. Windows will inform you about missing DLLs when executing *fiction*.

## Disclaimer

This is academic software made available under the CRAPL license. For more information see the LICENSE file.
