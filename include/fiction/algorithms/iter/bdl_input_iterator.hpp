//
// Created by marcel on 24.07.23.
//

#ifndef FICTION_BDL_INPUT_ITERATOR_HPP
#define FICTION_BDL_INPUT_ITERATOR_HPP

#include "fiction/algorithms/simulation/sidb/detect_bdl_pairs.hpp"
#include "fiction/algorithms/simulation/sidb/detect_bdl_wires.hpp"
#include "fiction/technology/cell_technologies.hpp"
#include "fiction/traits.hpp"

#include <cstdint>
#include <iterator>
#include <vector>

namespace fiction
{

/**
 * Parameters for the BDL input iterator.
 */
struct bdl_input_iterator_params
{
    /**
     * This enum defines how BDL inputs are manipulated within the algorithm.
     * According to existing literature, there are two main approaches for handling BDL inputs:
     *
     * 1. A perturber is used to set the input to `1`, while the absence of a perturber represents a `0`
     *    (as described in https://ieeexplore.ieee.org/abstract/document/8963859).
     * 2. An input of `1` is generated by placing a perturber closer to the target, whereas a `0` is produced
     *    by positioning the perturber farther away (as described in https://dl.acm.org/doi/10.1145/3489517.3530525).
     */
    enum class input_bdl_configuration : uint8_t
    {
        /**
         * An input of `1` is generated by placing a perturber closer to the BDL wire, whereas a `0` is produced
         * by positioning the perturber farther away (as described in https://dl.acm.org/doi/10.1145/3489517.3530525).
         */
        PERTURBER_DISTANCE_ENCODED,
        /**
         * A perturber is used to set the input to `1`, while the absence of a perturber represents a `0`
         * (as described in https://ieeexplore.ieee.org/abstract/document/8963859).
         */
        PERTURBER_ABSENCE_ENCODED
    };
    /**
     * Parameters to detect BDL wires.
     */
    detect_bdl_wires_params bdl_wire_params{};
    /**
     * The `input_bdl_config` member allows selection between different modes for handling input BDLs.
     */
    input_bdl_configuration input_bdl_config{input_bdl_configuration::PERTURBER_DISTANCE_ENCODED};
};

/**
 * Iterator that iterates over all possible input states of a BDL layout. There are \f$2^n\f$ possible input states
 * for an \f$n\f$-input BDL layout, each with a unique input index. The input index is interpreted as a binary number,
 * where the \f$i\f$-th bit represents the input state of the \f$i\f$-th input BDL pair. If the bit is `1`, the lower
 * BDL dot is set and the upper BDL dot removed. If the bit is `0`, the upper BDL dot is removed and the lower BDL dot
 * set. The iterator creates and stores a deep-copy of the given layout. The state enumeration wraps around, i.e., after
 * the last possible input state, the first input state is set again.
 *
 * The iterator satisfies the requirements of `LegacyRandomAccessIterator` and can be used in iterator-based `for`
 * loops.
 *
 * @tparam Lyt SiDB cell-level layout type.
 */
template <typename Lyt>
class bdl_input_iterator
{
  public:
    /**
     * Standard constructor. It alters the layout to set the first input state, which assigns binary `0` to all input
     * BDL pairs.
     *
     * @param lyt The SiDB BDL layout to iterate over.
     * @param ps Parameters for the BDL input iterator.
     */
    explicit bdl_input_iterator(const Lyt&                       lyt,
                                const bdl_input_iterator_params& ps = bdl_input_iterator_params{}) noexcept :
            layout{lyt.clone()},
            input_pairs{
                detect_bdl_pairs<Lyt>(lyt, sidb_technology::cell_type::INPUT, ps.bdl_wire_params.bdl_pairs_params)},
            num_inputs{static_cast<uint8_t>(input_pairs.size())},
            input_bdl_wires{detect_bdl_wires<Lyt>(lyt, ps.bdl_wire_params, bdl_wire_selection::INPUT)},
            last_bdl_for_each_wire{determine_last_bdl_for_each_wire()},
            params{ps}
    {
        static_assert(is_cell_level_layout_v<Lyt>, "Lyt is not a cell-level layout");
        static_assert(has_sidb_technology_v<Lyt>, "Lyt is not an SiDB layout");
        set_all_inputs();
    }

    /**
     * Constructor with pre-detected input wires and directions. It alters the layout to set the first input state,
     * which assigns binary `0` to all input BDL pairs.
     *
     * @param lyt The SiDB BDL layout to iterate over.
     * @param ps Parameters for the BDL input iterator.
     * @param input_wires Pre-detected input BDL wires.
     */
    explicit bdl_input_iterator(const Lyt& lyt, const bdl_input_iterator_params& ps,
                                const std::vector<bdl_wire<Lyt>>& input_wires) noexcept :
            layout{lyt.clone()},
            input_pairs{
                detect_bdl_pairs<Lyt>(lyt, sidb_technology::cell_type::INPUT, ps.bdl_wire_params.bdl_pairs_params)},
            num_inputs{static_cast<uint8_t>(input_pairs.size())},
            input_bdl_wires{input_wires},
            last_bdl_for_each_wire{determine_last_bdl_for_each_wire()},
            params{ps}
    {
        static_assert(is_cell_level_layout_v<Lyt>, "Lyt is not a cell-level layout");
        static_assert(has_sidb_technology_v<Lyt>, "Lyt is not an SiDB layout");
        set_all_inputs();
    }
    /**
     * Dereference operator. Returns a reference to the layout with the current input state.
     *
     * @return Reference to the current layout.
     */
    [[nodiscard]] const Lyt& operator*() const noexcept
    {
        return layout;
    }
    /**
     * Prefix increment operator. Sets the next input state.
     *
     * @return Reference to `this`.
     */
    bdl_input_iterator& operator++() noexcept
    {
        ++current_input_index;

        set_all_inputs();

        return *this;
    }
    /**
     * Postfix increment operator. Sets the next input state.
     *
     * @return Copy of `this` before incrementing.
     */
    bdl_input_iterator operator++(int) noexcept
    {
        auto result{*this};

        ++(*this);

        return result;
    }
    /**
     * Addition operator. Computes the input state of the current iterator plus the given integer.
     *
     * @param m The amount of input states to skip.
     * @return The input state of the current iterator plus the given integer.
     */
    [[nodiscard]] bdl_input_iterator operator+(const int m) const noexcept
    {
        auto result{*this};

        result += m;

        return result;
    }
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wsign-conversion"
    /**
     * Addition assignment operator. Sets a next input state.
     *
     * @param m The amount of input states to skip.
     * @return Reference to `this`.
     */
    bdl_input_iterator& operator+=(const int m) noexcept
    {
        current_input_index += m;

        set_all_inputs();

        return *this;
    }
#pragma GCC diagnostic pop
    /**
     * Subtraction operator. Computes the input state of the current iterator minus the given integer.
     *
     * @param m The amount of input states to skip.
     * @return The input state of the current iterator minus the given integer.
     */
    [[nodiscard]] bdl_input_iterator operator-(const int m) const noexcept
    {
        auto result{*this};

        result -= m;

        return result;
    }
    /**
     * Prefix decrement operator. Sets the previous input state.
     *
     * @return Reference to `this`.
     */
    bdl_input_iterator& operator--() noexcept
    {
        --current_input_index;

        set_all_inputs();

        return *this;
    }
    /**
     * Postfix decrement operator. Sets the previous input state.
     *
     * @return Copy of `this` before decrementing.
     */
    bdl_input_iterator operator--(int) noexcept
    {
        auto result{*this};

        --(*this);

        return result;
    }
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wsign-conversion"
    /**
     * Subtraction assignment operator. Sets a previous input state.
     *
     * @param m The amount of input states to skip.
     * @return Reference to `this`.
     */
    bdl_input_iterator& operator-=(const int m) noexcept
    {
        current_input_index -= m;

        set_all_inputs();

        return *this;
    }
#pragma GCC diagnostic pop
    /**
     * Assignment operator. Sets the input state to the given integer.
     *
     * @param m The input state to set.
     */
    bdl_input_iterator& operator=(const uint64_t m) noexcept
    {
        current_input_index = m;

        set_all_inputs();

        return *this;
    }
    /**
     * Subscript operator. Computes the input state of the current iterator plus the given integer.
     *
     * @param m The amount of input states to skip.
     * @return The input state of the current iterator plus the given integer.
     */
    [[nodiscard]] bdl_input_iterator operator[](const int m) const noexcept
    {
        return (*this + m);
    }
    /**
     * Subtraction operator. Computes the difference between the current input index and the given iterator ones.
     *
     * @param other Iterator to compute the difference with.
     * @return The difference between the current input index and the given iterator ones.
     */
    [[nodiscard]] int64_t operator-(const bdl_input_iterator& other) const noexcept
    {
        return static_cast<int64_t>(current_input_index) - static_cast<int64_t>(other.current_input_index);
    }
    /**
     * Equality operator. Compares the current input index with the given integer.
     *
     * @param m Integer to compare with.
     * @return `true` if the current input index is equal to `m`, `false` otherwise.
     */
    [[nodiscard]] bool operator==(const uint64_t m) const noexcept
    {
        return current_input_index == m;
    }
    /**
     * Inequality operator. Compares the current input index with the given integer.
     *
     * @param m Integer to compare with.
     * @return `true` if the current input index is not equal to `m`, `false` otherwise.
     */
    [[nodiscard]] bool operator!=(const uint64_t m) const noexcept
    {
        return current_input_index != m;
    }
    /**
     * Less-than operator. Compares the current input index with the given integer.
     *
     * @param m Integer to compare with.
     * @return `true` if the current input index is less than `m`, `false` otherwise.
     */
    [[nodiscard]] bool operator<(const uint64_t m) const noexcept
    {
        return current_input_index < m;
    }
    /**
     * Less-or-equal-than operator. Compares the current input index with the given integer.
     *
     * @param m Integer to compare with.
     * @return `true` if the current input index is less than or equal to `m`, `false` otherwise.
     */
    [[nodiscard]] bool operator<=(const uint64_t m) const noexcept
    {
        return current_input_index <= m;
    }
    /**
     * Greater-than operator. Compares the current input index with the given integer.
     *
     * @param m Integer to compare with.
     * @return `true` if the current input index is greater than `m`, `false` otherwise.
     */
    [[nodiscard]] bool operator>(const uint64_t m) const noexcept
    {
        return current_input_index > m;
    }
    /**
     * Greater-or-equal-than operator. Compares the current input index with the given integer.
     *
     * @param m Integer to compare with.
     * @return `true` if the current input index is greater than or equal to `m`, `false` otherwise.
     */
    [[nodiscard]] bool operator>=(const uint64_t m) const noexcept
    {
        return current_input_index >= m;
    }
    /**
     * Returns the total number of input BDL pairs of the given SiDB gate layout.
     *
     * @return The number of input BDL pairs.
     */
    [[nodiscard]] uint64_t num_input_pairs() const noexcept
    {
        return input_pairs.size();
    }

  private:
    /**
     * The layout to iterate over.
     */
    Lyt layout;
    /**
     * The detected input BDL pairs.
     */
    const std::vector<bdl_pair<cell<Lyt>>> input_pairs;
    /**
     * The amount of input BDL pairs.
     */
    const uint8_t num_inputs;
    /**
     * The detected input BDL wires.
     */
    const std::vector<bdl_wire<Lyt>> input_bdl_wires;
    /**
     * Last BDL pairs for each BDL wire.
     */
    const std::vector<bdl_pair<cell<Lyt>>> last_bdl_for_each_wire;
    /**
     * The current input index. There are \f$2^n\f$ possible input states for an \f$n\f$-input BDL layout.
     */
    uint64_t current_input_index{0ull};
    /**
     * Parameters for the BDL input iterator.
     */
    const bdl_input_iterator_params params;

    /**
     * This function iterates through each wire in `input_bdl_wires`, identifies the first BDL pair
     * of type `INPUT`, and then finds the BDL pair within the same wire that has the maximum distance
     * from the starting pair. The resulting last BDL pairs are stored in `last_bdl_for_each_wire`.
     *
     * @note Assumes that `input_bdl_wires` and `last_bdl_for_each_wire` are accessible within the scope.
     */
    [[nodiscard]] std::vector<bdl_pair<cell<Lyt>>> determine_last_bdl_for_each_wire() noexcept
    {
        std::vector<bdl_pair<cell<Lyt>>> end_bdls{};
        end_bdls.reserve(input_bdl_wires.size());

        // Iterate through each wire in the input collection
        for (const auto& wire : input_bdl_wires)
        {
            // Find the first BDL pair in the wire with type INPUT
            auto start_bdl_it = std::find_if(wire.pairs.cbegin(), wire.pairs.cend(), [](const bdl_pair<cell<Lyt>>& bdl)
                                             { return bdl.type == sidb_technology::cell_type::INPUT; });

            // If no INPUT type BDL pair is found, skip this wire
            if (start_bdl_it == wire.pairs.cend())
            {
                continue;
            }

            const auto& start_bdl_pair = *start_bdl_it;

            // Find the BDL pair with the maximum distance from the start BDL pair
            const auto max_bdl_it =
                std::max_element(wire.pairs.cbegin(), wire.pairs.cend(),
                                 [&](const bdl_pair<cell<Lyt>>& a, const bdl_pair<cell<Lyt>>& b) -> bool
                                 {
                                     double distance_a = sidb_nm_distance(Lyt{}, start_bdl_pair.upper, a.upper);
                                     double distance_b = sidb_nm_distance(Lyt{}, start_bdl_pair.upper, b.upper);
                                     return distance_a < distance_b;
                                 });

            // If a valid BDL pair is found, add it to the end BDLs collection
            if (max_bdl_it != wire.pairs.cend())
            {
                end_bdls.emplace_back(*max_bdl_it);
            }
        }

        return end_bdls;
    }
    /**
     * Sets all input cells of the layout according to the current input index. The input index is interpreted as a
     * binary number, where the \f$i\f$-th bit represents the input state of the \f$i\f$-th input BDL pair. If the bit
     * is `1`, the lower BDL dot is set and the upper BDL dot removed. If the bit is `0`, the upper BDL dot is removed
     * and the lower BDL dot set.
     */
    void set_all_inputs() noexcept
    {
        for (uint64_t i = num_inputs - 1; i < num_inputs; --i)
        {
            const auto& input_i = input_pairs[i];

            if ((current_input_index & (uint64_t{1ull} << (num_inputs - 1 - i))) != 0ull)
            {
                const auto distance_between_end_bdl_and_upper_input =
                    sidb_nm_distance(Lyt{}, input_i.upper, last_bdl_for_each_wire[i].upper);
                const auto distance_between_end_bdl_and_lower_input =
                    sidb_nm_distance(Lyt{}, input_i.lower, last_bdl_for_each_wire[i].upper);

                if (distance_between_end_bdl_and_upper_input < distance_between_end_bdl_and_lower_input)
                {
                    layout.assign_cell_type(input_i.lower, technology<Lyt>::cell_type::EMPTY);
                    layout.assign_cell_type(input_i.upper, technology<Lyt>::cell_type::INPUT);
                }

                else
                {
                    layout.assign_cell_type(input_i.lower, technology<Lyt>::cell_type::INPUT);
                    layout.assign_cell_type(input_i.upper, technology<Lyt>::cell_type::EMPTY);
                }
            }
            else
            {
                if (params.input_bdl_config ==
                    bdl_input_iterator_params::input_bdl_configuration::PERTURBER_DISTANCE_ENCODED)
                {
                    const auto distance_between_end_bdl_and_upper_input =
                        sidb_nm_distance(Lyt{}, input_i.upper, last_bdl_for_each_wire[i].upper);
                    const auto distance_between_end_bdl_and_lower_input =
                        sidb_nm_distance(Lyt{}, input_i.lower, last_bdl_for_each_wire[i].upper);

                    if (distance_between_end_bdl_and_upper_input < distance_between_end_bdl_and_lower_input)
                    {
                        layout.assign_cell_type(input_i.lower, technology<Lyt>::cell_type::INPUT);
                        layout.assign_cell_type(input_i.upper, technology<Lyt>::cell_type::EMPTY);
                    }

                    else
                    {
                        layout.assign_cell_type(input_i.lower, technology<Lyt>::cell_type::EMPTY);
                        layout.assign_cell_type(input_i.upper, technology<Lyt>::cell_type::INPUT);
                    }
                }
                else
                {
                    // set input i to 0
                    layout.assign_cell_type(input_i.upper, technology<Lyt>::cell_type::EMPTY);
                    layout.assign_cell_type(input_i.lower, technology<Lyt>::cell_type::EMPTY);
                }
            }
        }
    }
};

}  // namespace fiction

// make `bdl_input_iterator` compatible with STL iterator categories
namespace std
{
template <typename Lyt>
struct iterator_traits<fiction::bdl_input_iterator<Lyt>>
{
    using iterator_category = std::random_access_iterator_tag;
    using difference_type   = int64_t;
    using value_type        = Lyt;
};
}  // namespace std

#endif  // FICTION_BDL_INPUT_ITERATOR_HPP
