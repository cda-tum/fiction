//
// Created by marcel on 16.07.18.
//

#ifndef FICTION_COMMANDS_H
#define FICTION_COMMANDS_H

#include "version.h"
#include "verilog_parser.h"
#include "exact_pr.h"
#include "orthogonal_pr.h"
#include "fcn_gate_layout.h"
#include "fcn_cell_layout.h"
#include "qca_one_library.h"
#include "qca_writer.h"
#include <boost/filesystem.hpp>
#include <boost/range/iterator_range.hpp>
#include <alice/alice.hpp>

namespace alice
{
    /**
     * Outputs version and build information.
     */
    class version_command : public command
    {
    public:
        /**
         * Standard constructor. Adds descriptive information, options, and flags.
         *
         * @param env alice::environment that specifies stores etc.
         */
        explicit version_command(const environment::ptr& env)
                :
                command(env, "Outputs the version string as well as build time and date.")
        {}

    protected:
        /**
         * Function to perform the version print call.
         */
        void execute() override
        {
            env->out() << VERSION << " - compiled on " << COMPILED_DATE << " at " << COMPILED_TIME << std::endl;
        }
    };

    ALICE_ADD_COMMAND(version, "General")


    /**
     * Shorthand for all read commands. Chooses the proper function by the file ending.
     *
     * Parses verilog files currently. Gate level netlists are supported. The lorina verilog parser is used. At the
     * moment, only 2-input gates + 3-input MAJ in assign notation are supported. Using ABC, those can be generated by
     * the commands
     *
     * read <file>
     * strash
     * write <file>.v
     *
     * For more information see: https://github.com/marcelwa/lorina
     */
    class read_command : public command
    {
    public:
        /**
         * Standard constructor. Adds descriptive information, options, and flags.
         *
         * @param env alice::environment that specifies stores etc.
         */
        explicit read_command(const environment::ptr& env)
                :
                command(env, "Reads one Verilog file or a directory of those and creates logic network objects which will be put "
                             "into the respective store. In a directory, only files with extension '.v' are considered.")
        {
            add_option("filename", filename,
                       "Verilog filename or directory of Verilog files")->required();
            add_flag("--sort,-s", sort,
                       "Sort files in given directory by file size prior to parsing");
        }

    protected:
        /**
         * Function to perform the read call. Reads Verilog and creates a logic_network.
         */
        void execute() override
        {
            // checks for extension validity
            auto is_valid_extension = [](const auto& _f) -> bool
            {
                const std::vector<std::string> extensions{{".v"}};
                return std::any_of(extensions.cbegin(), extensions.cend(),
                                   [&_f](const auto& _e) { return boost::filesystem::extension(_f) == _e; });
            };

            // check for for given file's properties
            if (boost::filesystem::exists(filename))
            {
                if (boost::filesystem::is_regular_file(filename))
                {
                    // collect valid files only
                    if (is_valid_extension(filename))
                        paths.push_back(filename);
                }

                else if (boost::filesystem::is_directory(filename))
                {
                    // iterate over each file in the directory
                    for (auto& file : boost::make_iterator_range(boost::filesystem::directory_iterator(filename), {}))
                    {
                        if (boost::filesystem::is_regular_file(file))
                        {
                            // collect valid files only
                            if (is_valid_extension(file))
                                paths.push_back(file.path().string());
                        }
                    }
                }
                else // existing file but a weird one
                    env->out() << "[e] given file name does not point to a regular file" << std::endl;
            }
            else // path leads nowhere
                env->out() << "[e] given file name does not exist" << std::endl;

            // sort by file size to make the small ones go first
            if (sort)
            {
                std::sort(paths.begin(), paths.end(), [](std::string& f1, std::string& f2)
                { return boost::filesystem::file_size(f1) >= boost::filesystem::file_size(f2); });
            }

            // handle collected files
            for (const auto& f : paths)
            {
                // parse Verilog
                if (boost::filesystem::extension(f) == ".v")
                {
                    auto name = boost::filesystem::path{f}.stem().string();
                    auto ln = std::make_shared<logic_network>(std::move(name));

                    lorina::diagnostic_engine diag{};
                    if (lorina::read_verilog(f, verilog_parser{ln}, &diag) == lorina::return_code::success)
                    {
                        store<logic_network_ptr>().extend() = std::move(ln);
                    }
                    else
                    {
                        env->out() << "[e] parsing error in " << f << std::endl;
                    }
                }
                // parse ...
                // else if (boost::filesystem::extension(f) == ...)
            }

            // reset flags, necessary for some reason... alice bug?
            paths = {};
            sort = false;
        }

    private:
        /**
         * Verilog filename.
         */
        std::string filename;
        /**
         * All paths found under filename.
         */
        std::vector<std::string> paths{};
        /**
         * Flag to indicate that files should be sorted by file size.
         */
         bool sort = false;
    };

    ALICE_ADD_COMMAND(read, "I/O")

   /**
    * Clears all stores by removing all their entries.
    */
    class clear_command : public command
    {
    public:
        /**
         * Standard constructor. Adds descriptive information, options, and flags.
         *
         * @param env alice::environment that specifies stores etc.
         */
        explicit clear_command(const environment::ptr& env)
                :
                command(env,
                        "Removes all elements from the respectively flagged stores. If no store is specified, all "
                        "stores will be cleared.")
        {
            add_flag("--logic_network,-w", network,
                     "Clear logic network store");
            add_flag("--gate_layout,-g", gate,
                     "Clear gate layout store");
            add_flag("--cell_layout,-c", cell,
                     "Clear cell layout store");
        }

    protected:
        /**
         * Function to perform the clear call. Calls alice's clear function for all stores.
         */
        void execute() override
        {
            // if no store was specified, clear all.
            if (!cell && !gate && !network)
            {
                cell = true; gate = true; network = true;
            }

            if (cell)
                store<fcn_cell_layout_ptr>().clear();
            if (gate)
                store<fcn_gate_layout_ptr>().clear();
            if (network)
                store<logic_network_ptr>().clear();

            // reset flags, necessary for some reason... alice bug?
            cell = false; gate = false; network = false;
        }

    private:
        /**
         * Stores to clear.
         */
        bool cell = false, gate = false, network = false;
    };

    ALICE_ADD_COMMAND(clear, "General")


    /**
     * Executes an exact placement and routing approach utilizing the SMT solver Z3.
     * See exact_pr.h for more details.
     */
    class exact_command : public command
    {
    public:
        /**
         * Standard constructor. Adds descriptive information, options, and flags.
         *
         * @param env alice::environment that specifies stores etc.
         */
        explicit exact_command(const environment::ptr& env)
                :
                command(env, "Performs exact placement and routing of the current logic network in store. "
                             "A minimum FCN layout will be found that meets all given constraints.")
        {
            add_option("--clocking_scheme,-s", clocking,
                       "Clocking scheme to be used {OPEN3, OPEN4, 2DDWAVE3, 2DDWAVE4, USE, RES, BANCS}", true);
            add_option("--upper_bound,-u", config.upper_bound,
                       "Number of FCN gate tiles to use at maximum");
            add_option("--limit_crossings,-c", config.crossings_limit,
                       "Maximum number of tiles to use for crossings");
            add_option("--limit_wires,-w", config.wire_limit,
                       "Maximum number of wire elements per connection");
            add_option("--timeout,-t", config.timeout,
                       "Timeout in milliseconds");

            add_flag("--crossings,-x", config.crossings,
                     "Enable second layer for wire crossings");
            add_flag("--io_ports,-i", config.io_ports,
                     "Route extra wires to balance I/O port paths");
            add_flag("--border_io,-b", config.border_io,
                     "Enforce primary I/O to be placed at the layout's borders");
            add_flag("--path_discrepancy,-p", config.path_discrepancy,
                     "Allow a discrepancy in fan-in paths (area vs. throughput)");
            add_flag("--artificial_latch,-a", config.artificial_latch,
                     "Allow clocked latch delays to balance fan-in paths");
            add_flag("--fixed_size,-f", config.fixed_size,
                     "Execute only one run with upper_bound given as a fixed size");
        }

    protected:
        /**
         * Function to perform the P&R call. Given arguments are parsed and a FCN gate layout is generated if possible.
         */
        void execute() override
        {
            auto& s = store<logic_network_ptr>();

            // error case: empty logic network store
            if (s.empty())
            {
                env->out() << "[w] no logic network in store" << std::endl;
                reset_flags();
                return;
            }

            // error case: -f is set but -u is not
            if (this->is_set("fixed_size") && !this->is_set("upper_bound"))
            {
                env->out() << "[e] -u must be defined as well when -f is used" << std::endl;
                reset_flags();
                return;
            }

            // choose clocking
            if (auto clk = get_clocking_scheme(clocking))
            {
                config.scheme = std::make_shared<fcn_clocking_scheme>(*clk);
            }
            else
            {
                env->out() << "[e] \"" << clocking << "\" does not refer to a supported clocking scheme" << std::endl;
                reset_flags();
                return;
            }

            // perform exact P&R
            exact_pr pr{s.current(), std::move(config)};
            auto result = pr.perform_place_and_route();

            if (result.success)
            {
                store<fcn_gate_layout_ptr>().extend() = pr.get_layout();
                pr_result = result.json;
            }
            else
                env->out() << "[e] impossible to place and route " << s.current()->get_name() << " within the given "
                              "parameters" << std::endl;


            reset_flags();
        }
        /**
         * Logs the resulting information in a log file.
         *
         * @return JSON object containing information about the solving process.
         */
        nlohmann::json log() const override
        {
            return pr_result;
        }
        /**
         * Reset all flags. Necessary for some reason... alice bug?
         */
        void reset_flags()
        {
            config = exact_pr_config{};
            clocking = "OPEN4";
        }

    private:
        /**
         * Configuration object extracted from arguments and flags.
         */
        exact_pr_config config{};
        /**
         * Identifier of clocking scheme to use.
         */
        std::string clocking = "OPEN4";
        /**
         * Resulting logging information.
         */
        nlohmann::json pr_result;
    };

    ALICE_ADD_COMMAND(exact, "Placement & Routing")


    /**
     * Executes a heuristic placement and routing approach based on "Improved Orthogonal Drawing of 3-graphs" by
     * Therese Biedl, 1996.
     * See orthogonal_pr.h for more details.
     */
    class ortho_command : public command
    {
    public:
        /**
         * Standard constructor. Adds descriptive information, options, and flags.
         *
         * @param env alice::environment that specifies stores etc.
         */
        explicit ortho_command(const environment::ptr& env)
                :
                command(env, "Performs heuristic placement and routing of the current logic network in store. "
                             "An FCN layout that is not minimal will be found in reasonable runtime.")
        {
            add_option("--clock_numbers,-n", phases,
                       "Number of clock phases to be used {3 or 4}", true);
            add_flag("--io_ports,-i", io_ports,
                     "Place designated I/O ports too");
        }

    protected:
        /**
         * Function to perform the P&R call. Generates an FCN gate layout.
         */
        void execute() override
        {
            auto& s = store<logic_network_ptr>();

            // error case: empty logic network store
            if (s.empty())
            {
                env->out() << "[w] no logic network in store" << std::endl;
                reset_flags();
                return;
            }
            // error case: phases out of range
            if (phases != 3u && phases != 4u)
            {
                env->out() << "[e] only 3- and 4-phase clocking schemes are supported" << std::endl;
                reset_flags();
                return;
            }

            // perform heuristic P&R
            orthogonal_pr pr{s.current(), phases, io_ports};
            auto result = pr.perform_place_and_route();

            if (result.success)
            {
                store<fcn_gate_layout_ptr>().extend() = pr.get_layout();
                pr_result = result.json;
            }
            else
                env->out() << "[e] impossible to place and route " << s.current()->get_name() << std::endl;

            reset_flags();
        }
        /**
         * Logs the resulting information in a log file.
         *
         * @return JSON object containing information about the P&R process.
         */
        nlohmann::json log() const override
        {
            return pr_result;
        }
        /**
         * Reset all flags. Necessary for some reason... alice bug?
         */
        void reset_flags()
        {
            phases = 4u;
            io_ports = false;
        }

    private:
        /**
         * Number of clock phases to use. 3 and 4 are supported.
         */
        unsigned phases = 4u;
        /**
         * Flag to indicate that designated I/O ports should be placed.
         */
        bool io_ports = false;
        /**
         * Resulting logging information.
         */
        nlohmann::json pr_result;
    };

    ALICE_ADD_COMMAND(ortho, "Placement & Routing")


    /**
     * Converts an fcn_gate_layout to an fcn_cell_layout. Conversion process allows to choose from supported FCN gate
     * libraries.
     */
    class cell_command : public command
    {
    public:
        /**
         * Standard constructor. Adds descriptive information, options, and flags.
         *
         * @param env alice::environment that specifies stores etc.
         */
        explicit cell_command(const environment::ptr& env)
                :
                command(env, "Converts the current gate layout in store to a cell layout. A gate library must be "
                             "specified in order to instruct the algorithm how to map gate tiles to cell tiles.")
        {
            add_option("--library,-l", library,
                       "Gate library to use {QCA-ONE=0}", true);
        }

    protected:
        /**
         * Function to perform the conversion call. Generates an fcn_cell_layout.
         */
        void execute() override
        {
            auto& s = store<fcn_gate_layout_ptr>();

            // error case: empty gate layout store
            if (s.empty())
            {
                env->out() << "[w] no gate layout in store" << std::endl;
                return;
            }

            fcn_gate_library_ptr lib = nullptr;
            std::string lib_name{};
            try
            {
                if (library == 0u)
                    lib = std::make_shared<qca_one_library>(s.current());
                // else if (library == 1u)
                    // more libraries go here
                else
                {
                    env->out() << "[e] identifier " << library << " does not refer to a supported gate library" << std::endl;
                    return;
                }

                lib_name = lib->get_name();
            }
            catch (...)
            {
                env->out() << "[e] could not assign directions in " << s.current()->get_name() << " to cell ports" << std::endl;
                return;
            }

            fcn_cell_layout_ptr fcl = nullptr;
            try
            {
                fcl = std::make_shared<fcn_cell_layout>(std::move(lib));
            }
            catch (...)
            {
                env->out() << "[e] mapping " << s.current()->get_name() << " to a cell layout using the "
                    << lib_name << " library was not successful" << std::endl;
                return;
            }

            // store new layout
            store<fcn_cell_layout_ptr>().extend() = std::move(fcl);
        }

    private:
        /**
         * Identifier of gate library to use.
         */
        unsigned library = 0u;
    };

    ALICE_ADD_COMMAND(cell, "Conversion")

    /**
     * Generates a QCADesigner file for the current cell layout in store and writes it to the given path.
     *
     * QCADesigner is available at: https://waluslab.ece.ubc.ca/qcadesigner/
     */
    class qca_command : public command
    {
    public:
        /**
         * Standard constructor. Adds descriptive information, options, and flags.
         *
         * @param env alice::environment that specifies stores etc.
         */
        explicit qca_command(const environment::ptr& env)
                :
                command(env, "Generates a QCADesigner file for the current cell layout in store to perform "
                             "physical simulations.")
        {
            add_option("filename", filename,
                       "QCA file name");
        }

    protected:
        /**
         * Function to perform the output print call. Generates a QCADesigner file.
         */
        void execute() override
        {
            auto s = store<fcn_cell_layout_ptr>();

            // error case: empty cell layout store
            if (s.empty())
            {
                env->out() << "[w] no cell layout in store" << std::endl;
                return;
            }
            // error case: do not override directories
            if (boost::filesystem::is_directory(filename))
            {
                env->out() << "[e] cannot override a directory" << std::endl;
                return;
            }
            // if filename was empty or not given, use stored layout name
            if (filename.empty())
                filename = s.current()->get_name();
            // add .qca file extension if necessary
            if (boost::filesystem::extension(filename) != ".qca")
                filename += ".qca";

            qca::write(std::move(s.current()), filename);
        }

    private:
        /**
         * File name to write the QCA file into.
         */
        std::string filename;
    };

    ALICE_ADD_COMMAND(qca, "I/O")
}


#endif //FICTION_COMMANDS_H
