from typing import overload, Union, List, Optional, Tuple
from enum import Enum


# Layouts

class offset_coordinate:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, int_repr: int) -> None: ...

    @overload
    def __init__(self, x: int, y: int, z: int) -> None: ...

    @overload
    def __init__(self, c: offset_coordinate) -> None: ...

    @overload
    def __init__(self, c: tuple[int, int, int]) -> None: ...

    x: int
    y: int
    z: int

    def __eq__(self, other: object) -> bool: ...

    def __ne__(self, other: object) -> bool: ...

    def __lt__(self, other: offset_coordinate) -> bool: ...

    def __gt__(self, other: offset_coordinate) -> bool: ...

    def __le__(self, other: offset_coordinate) -> bool: ...

    def __ge__(self, other: offset_coordinate) -> bool: ...

    def __repr__(self) -> str: ...

    def __hash__(self) -> int: ...


class cube_coordinate:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, x: int, y: int, z: int = 0) -> None: ...

    @overload
    def __init__(self, c: cube_coordinate) -> None: ...

    @overload
    def __init__(self, c: tuple[int, int, int]) -> None: ...

    x: int
    y: int
    z: int

    def __eq__(self, other: object) -> bool: ...

    def __ne__(self, other: object) -> bool: ...

    def __lt__(self, other: cube_coordinate) -> bool: ...

    def __gt__(self, other: cube_coordinate) -> bool: ...

    def __le__(self, other: cube_coordinate) -> bool: ...

    def __ge__(self, other: cube_coordinate) -> bool: ...

    def __repr__(self) -> str: ...

    def __hash__(self) -> int: ...


class siqad_coordinate:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, x: int, y: int, z: int = 0) -> None: ...

    @overload
    def __init__(self, c: siqad_coordinate) -> None: ...

    @overload
    def __init__(self, c: tuple[int, int, int]) -> None: ...

    x: int
    y: int
    z: int

    def __eq__(self, other: object) -> bool: ...

    def __ne__(self, other: object) -> bool: ...

    def __lt__(self, other: siqad_coordinate) -> bool: ...

    def __gt__(self, other: siqad_coordinate) -> bool: ...

    def __le__(self, other: siqad_coordinate) -> bool: ...

    def __ge__(self, other: siqad_coordinate) -> bool: ...

    def __repr__(self) -> str: ...

    def __hash__(self) -> int: ...


# For consistent behavior:
def area(coord: Union[offset_coordinate, cube_coordinate, siqad_coordinate]) -> float: ...


def volume(coord: Union[offset_coordinate, cube_coordinate, siqad_coordinate]) -> float: ...


# For conversions with potentially nuanced behavior:
@overload
def to_offset_coord(coord: siqad_coordinate) -> offset_coordinate: ...


@overload
def to_cube_coord(coord: siqad_coordinate) -> cube_coordinate: ...


@overload
def to_siqad_coord(coord: offset_coordinate) -> siqad_coordinate: ...


@overload
def to_siqad_coord(coord: cube_coordinate) -> siqad_coordinate: ...


class cartesian_layout:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, dimension: offset_coordinate) -> None: ...

    def coord(self, x: int, y: int, z: int = 0) -> offset_coordinate: ...

    def x(self) -> int: ...

    def y(self) -> int: ...

    def z(self) -> int: ...

    def area(self) -> int: ...

    def resize(self, dimension: offset_coordinate) -> None: ...

    def north(self, c: offset_coordinate) -> Optional[offset_coordinate]: ...

    def north_east(self, c: offset_coordinate) -> Optional[offset_coordinate]: ...

    def east(self, c: offset_coordinate) -> Optional[offset_coordinate]: ...

    def south_east(self, c: offset_coordinate) -> Optional[offset_coordinate]: ...

    def south(self, c: offset_coordinate) -> Optional[offset_coordinate]: ...

    def south_west(self, c: offset_coordinate) -> Optional[offset_coordinate]: ...

    def west(self, c: offset_coordinate) -> Optional[offset_coordinate]: ...

    def north_west(self, c: offset_coordinate) -> Optional[offset_coordinate]: ...

    def above(self, c: offset_coordinate) -> Optional[offset_coordinate]: ...

    def below(self, c: offset_coordinate) -> Optional[offset_coordinate]: ...

    def is_north_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...

    def is_east_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...

    def is_south_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...

    def is_west_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...

    def is_adjacent_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...

    def is_adjacent_elevation_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...

    def is_above(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...

    def is_below(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...

    def is_northwards_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...

    def is_eastwards_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...

    def is_southwards_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...

    def is_westwards_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...

    def is_at_northern_border(self, c: offset_coordinate) -> bool: ...

    def is_at_eastern_border(self, c: offset_coordinate) -> bool: ...

    def is_at_southern_border(self, c: offset_coordinate) -> bool: ...

    def is_at_western_border(self, c: offset_coordinate) -> bool: ...

    def is_at_any_border(self, c: offset_coordinate) -> bool: ...

    def northern_border_of(self, c: offset_coordinate) -> Optional[offset_coordinate]: ...

    def eastern_border_of(self, c: offset_coordinate) -> Optional[offset_coordinate]: ...

    def southern_border_of(self, c: offset_coordinate) -> Optional[offset_coordinate]: ...

    def western_border_of(self, c: offset_coordinate) -> Optional[offset_coordinate]: ...

    def is_ground_layer(self, c: offset_coordinate) -> bool: ...

    def is_crossing_layer(self, c: offset_coordinate) -> bool: ...

    def is_within_bounds(self, c: offset_coordinate) -> bool: ...

    def offset_coordinates(self) -> List[offset_coordinate]: ...

    def ground_coordinates(self) -> List[offset_coordinate]: ...

    def adjacent_coordinates(self, c: offset_coordinate) -> List[offset_coordinate]: ...

    def adjacent_opposite_coordinates(self, c: offset_coordinate) -> List[offset_coordinate]: ...

    def __repr__(self) -> str: ...


class shifted_cartesian_layout:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, dimension: offset_coordinate) -> None: ...

    def coord(self, x: int, y: int, z: int = 0) -> offset_coordinate: ...

    def x(self) -> int: ...

    def y(self) -> int: ...

    def z(self) -> int: ...

    def area(self) -> int: ...

    def resize(self, dimension: offset_coordinate) -> None: ...

    def north(self, c: offset_coordinate) -> Optional[offset_coordinate]: ...

    def north_east(self, c: offset_coordinate) -> Optional[offset_coordinate]: ...

    def east(self, c: offset_coordinate) -> Optional[offset_coordinate]: ...

    def south_east(self, c: offset_coordinate) -> Optional[offset_coordinate]: ...

    def south(self, c: offset_coordinate) -> Optional[offset_coordinate]: ...

    def south_west(self, c: offset_coordinate) -> Optional[offset_coordinate]: ...

    def west(self, c: offset_coordinate) -> Optional[offset_coordinate]: ...

    def north_west(self, c: offset_coordinate) -> Optional[offset_coordinate]: ...

    def above(self, c: offset_coordinate) -> Optional[offset_coordinate]: ...

    def below(self, c: offset_coordinate) -> Optional[offset_coordinate]: ...

    def is_north_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...

    def is_east_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...

    def is_south_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...

    def is_west_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...

    def is_adjacent_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...

    def is_adjacent_elevation_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...

    def is_above(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...

    def is_below(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...

    def is_northwards_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...

    def is_eastwards_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...

    def is_southwards_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...

    def is_westwards_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...

    def is_at_northern_border(self, c: offset_coordinate) -> bool: ...

    def is_at_eastern_border(self, c: offset_coordinate) -> bool: ...

    def is_at_southern_border(self, c: offset_coordinate) -> bool: ...

    def is_at_western_border(self, c: offset_coordinate) -> bool: ...

    def is_at_any_border(self, c: offset_coordinate) -> bool: ...

    def northern_border_of(self, c: offset_coordinate) -> Optional[offset_coordinate]: ...

    def eastern_border_of(self, c: offset_coordinate) -> Optional[offset_coordinate]: ...

    def southern_border_of(self, c: offset_coordinate) -> Optional[offset_coordinate]: ...

    def western_border_of(self, c: offset_coordinate) -> Optional[offset_coordinate]: ...

    def is_ground_layer(self, c: offset_coordinate) -> bool: ...

    def is_crossing_layer(self, c: offset_coordinate) -> bool: ...

    def is_within_bounds(self, c: offset_coordinate) -> bool: ...

    def offset_coordinates(self) -> List[offset_coordinate]: ...

    def ground_coordinates(self) -> List[offset_coordinate]: ...

    def adjacent_coordinates(self, c: offset_coordinate) -> List[offset_coordinate]: ...

    def adjacent_opposite_coordinates(self, c: offset_coordinate) -> List[offset_coordinate]: ...

    def __repr__(self) -> str: ...


class hexagonal_layout:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, dimension: cube_coordinate) -> None: ...

    def coord(self, x: int, y: int, z: int = 0) -> cube_coordinate: ...

    def x(self) -> int: ...

    def y(self) -> int: ...

    def z(self) -> int: ...

    def area(self) -> int: ...

    def resize(self, dimension: cube_coordinate) -> None: ...

    def north(self, c: cube_coordinate) -> Optional[cube_coordinate]: ...

    def north_east(self, c: cube_coordinate) -> Optional[cube_coordinate]: ...

    def east(self, c: cube_coordinate) -> Optional[cube_coordinate]: ...

    def south_east(self, c: cube_coordinate) -> Optional[cube_coordinate]: ...

    def south(self, c: cube_coordinate) -> Optional[cube_coordinate]: ...

    def south_west(self, c: cube_coordinate) -> Optional[cube_coordinate]: ...

    def west(self, c: cube_coordinate) -> Optional[cube_coordinate]: ...

    def north_west(self, c: cube_coordinate) -> Optional[cube_coordinate]: ...

    def above(self, c: cube_coordinate) -> Optional[cube_coordinate]: ...

    def below(self, c: cube_coordinate) -> Optional[cube_coordinate]: ...

    def is_north_of(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...

    def is_east_of(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...

    def is_south_of(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...

    def is_west_of(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...

    def is_adjacent_of(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...

    def is_adjacent_elevation_of(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...

    def is_above(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...

    def is_below(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...

    def is_northwards_of(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...

    def is_eastwards_of(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...

    def is_southwards_of(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...

    def is_westwards_of(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...

    def is_at_northern_border(self, c: cube_coordinate) -> bool: ...

    def is_at_eastern_border(self, c: cube_coordinate) -> bool: ...

    def is_at_southern_border(self, c: cube_coordinate) -> bool: ...

    def is_at_western_border(self, c: cube_coordinate) -> bool: ...

    def is_at_any_border(self, c: cube_coordinate) -> bool: ...

    def northern_border_of(self, c: cube_coordinate) -> Optional[cube_coordinate]: ...

    def eastern_border_of(self, c: cube_coordinate) -> Optional[cube_coordinate]: ...

    def southern_border_of(self, c: cube_coordinate) -> Optional[cube_coordinate]: ...

    def western_border_of(self, c: cube_coordinate) -> Optional[cube_coordinate]: ...

    def is_ground_layer(self, c: cube_coordinate) -> bool: ...

    def is_crossing_layer(self, c: cube_coordinate) -> bool: ...

    def is_within_bounds(self, c: cube_coordinate) -> bool: ...

    def coordinates(self) -> List[cube_coordinate]: ...

    def ground_coordinates(self) -> List[cube_coordinate]: ...

    def adjacent_coordinates(self, c: cube_coordinate) -> List[cube_coordinate]: ...

    def adjacent_opposite_coordinates(self, c: cube_coordinate) -> List[cube_coordinate]: ...

    def __repr__(self) -> str: ...


class clocked_cartesian_layout(cartesian_layout):
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, dimension: offset_coordinate) -> None: ...

    @overload
    def __init__(self, dimension: offset_coordinate, clocking_scheme: str = "2DDWave") -> None: ...

    def assign_clock_number(self, cz: offset_coordinate, cn: int) -> None: ...

    def get_clock_number(self, cz: offset_coordinate) -> int: ...

    def num_clocks(self) -> int: ...

    def is_regularly_clocked(self) -> bool: ...

    def is_clocking_scheme(self, name: str) -> bool: ...

    def is_incoming_clocked(self, cz1: offset_coordinate, cz2: offset_coordinate) -> bool: ...

    def is_outgoing_clocked(self, cz1: offset_coordinate, cz2: offset_coordinate) -> bool: ...

    def incoming_clocked_zones(self, cz: offset_coordinate) -> List[offset_coordinate]: ...

    def outgoing_clocked_zones(self, cz: offset_coordinate) -> List[offset_coordinate]: ...

    def in_degree(self, cz: offset_coordinate) -> int: ...

    def out_degree(self, cz: offset_coordinate) -> int: ...

    def degree(self, cz: offset_coordinate) -> int: ...

    def __repr__(self) -> str: ...


class clocked_shifted_cartesian_layout(shifted_cartesian_layout):
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, dimension: offset_coordinate) -> None: ...

    @overload
    def __init__(self, dimension: offset_coordinate, clocking_scheme: str = "2DDWave") -> None: ...

    def assign_clock_number(self, cz: offset_coordinate, cn: int) -> None: ...

    def get_clock_number(self, cz: offset_coordinate) -> int: ...

    def num_clocks(self) -> int: ...

    def is_regularly_clocked(self) -> bool: ...

    def is_clocking_scheme(self, name: str) -> bool: ...

    def is_incoming_clocked(self, cz1: offset_coordinate, cz2: offset_coordinate) -> bool: ...

    def is_outgoing_clocked(self, cz1: offset_coordinate, cz2: offset_coordinate) -> bool: ...

    def incoming_clocked_zones(self, cz: offset_coordinate) -> List[offset_coordinate]: ...

    def outgoing_clocked_zones(self, cz: offset_coordinate) -> List[offset_coordinate]: ...

    def in_degree(self, cz: offset_coordinate) -> int: ...

    def out_degree(self, cz: offset_coordinate) -> int: ...

    def degree(self, cz: offset_coordinate) -> int: ...

    def __repr__(self) -> str: ...


class clocked_hexagonal_layout(hexagonal_layout):
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, dimension: cube_coordinate) -> None: ...

    @overload
    def __init__(self, dimension: cube_coordinate, clocking_scheme: str = "2DDWave") -> None: ...

    def assign_clock_number(self, cz: cube_coordinate, cn: int) -> None: ...

    def get_clock_number(self, cz: cube_coordinate) -> int: ...

    def num_clocks(self) -> int: ...

    def is_regularly_clocked(self) -> bool: ...

    def is_clocking_scheme(self, name: str) -> bool: ...

    def is_incoming_clocked(self, cz1: cube_coordinate, cz2: cube_coordinate) -> bool: ...

    def is_outgoing_clocked(self, cz1: cube_coordinate, cz2: cube_coordinate) -> bool: ...

    def incoming_clocked_zones(self, cz: cube_coordinate) -> List[cube_coordinate]: ...

    def outgoing_clocked_zones(self, cz: cube_coordinate) -> List[cube_coordinate]: ...

    def in_degree(self, cz: cube_coordinate) -> int: ...

    def out_degree(self, cz: cube_coordinate) -> int: ...

    def degree(self, cz: cube_coordinate) -> int: ...

    def __repr__(self) -> str: ...


class cartesian_gate_layout(clocked_cartesian_layout):
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, dimension: offset_coordinate) -> None: ...

    @overload
    def __init__(self, dimension: offset_coordinate, clocking_scheme: str = "2DDWave",
                 layout_name: str = "") -> None: ...

    def create_pi(self, name: str = "", t: Optional[offset_coordinate] = None) -> None: ...

    def create_po(self, s: int, name: str = "", t: Optional[offset_coordinate] = None) -> None: ...

    def is_pi(self, n: int) -> bool: ...

    def is_po(self, n: int) -> bool: ...

    def is_pi_coordinate(self, t: offset_coordinate) -> bool: ...

    def is_po_coordinate(self, t: offset_coordinate) -> bool: ...

    def is_inv(self) -> bool: ...

    def is_and(self) -> bool: ...

    def is_nand(self) -> bool: ...

    def is_or(self) -> bool: ...

    def is_nor(self) -> bool: ...

    def is_xor(self) -> bool: ...

    def is_xnor(self) -> bool: ...

    def is_maj(self) -> bool: ...

    def is_fanout(self) -> bool: ...

    def is_wire(self) -> bool: ...

    def set_layout_name(self, name: str) -> None: ...

    def get_layout_name(self) -> str: ...

    def set_input_name(self, index: int, name: str) -> None: ...

    def get_input_name(self, index: int) -> str: ...

    def set_output_name(self, index: int, name: str) -> None: ...

    def get_output_name(self, index: int) -> str: ...

    def get_name(self, s: int) -> str: ...

    def create_buf(self, a: int, t: Optional[offset_coordinate] = None) -> None: ...

    def create_not(self, a: int, t: Optional[offset_coordinate] = None) -> None: ...

    def create_and(self, a: int, b: int, t: Optional[offset_coordinate] = None) -> None: ...

    def create_nand(self, a: int, b: int, t: Optional[offset_coordinate] = None) -> None: ...

    def create_or(self, a: int, b: int, t: Optional[offset_coordinate] = None) -> None: ...

    def create_nor(self, a: int, b: int, t: Optional[offset_coordinate] = None) -> None: ...

    def create_xor(self, a: int, b: int, t: Optional[offset_coordinate] = None) -> None: ...

    def create_xnor(self, a: int, b: int, t: Optional[offset_coordinate] = None) -> None: ...

    def create_maj(self, a: int, b: int, c: int, t: Optional[offset_coordinate] = None) -> None: ...

    def num_pis(self) -> int: ...

    def num_pos(self) -> int: ...

    def num_gates(self) -> int: ...

    def num_wires(self) -> int: ...

    def num_crossings(self) -> int: ...

    def is_empty(self) -> bool: ...

    def fanin_size(self, n: int) -> int: ...

    def fanout_size(self, n: int) -> int: ...

    def get_int(self, t: offset_coordinate) -> int: ...

    def get_coordinate(self, n: int) -> offset_coordinate: ...

    def make_int(self, n: int) -> int: ...

    def move_int(self, n: int, t: offset_coordinate, new_children: List[offset_coordinate] = []) -> None: ...

    def clear_coordinate(self, t: offset_coordinate) -> None: ...

    def is_gate_coordinate(self, t: offset_coordinate) -> bool: ...

    def is_wire_coordinate(self, t: offset_coordinate) -> bool: ...

    def is_empty_coordinate(self, t: offset_coordinate) -> bool: ...

    def pis(self) -> List[offset_coordinate]: ...

    def pos(self) -> List[offset_coordinate]: ...

    def gates(self) -> List[offset_coordinate]: ...

    def wires(self) -> List[offset_coordinate]: ...

    def fanins(self, t: offset_coordinate) -> List[int]: ...

    def fanouts(self, t: offset_coordinate) -> List[int]: ...

    def is_incoming_int(self, t: offset_coordinate, s: int) -> bool: ...

    def has_no_incoming_int(self, t: offset_coordinate) -> bool: ...

    def has_northern_incoming_int(self, t: offset_coordinate) -> bool: ...

    def has_north_eastern_incoming_int(self, t: offset_coordinate) -> bool: ...

    def has_eastern_incoming_int(self, t: offset_coordinate) -> bool: ...

    def has_south_eastern_incoming_int(self, t: offset_coordinate) -> bool: ...

    def has_southern_incoming_int(self, t: offset_coordinate) -> bool: ...

    def has_south_western_incoming_int(self, t: offset_coordinate) -> bool: ...

    def has_western_incoming_int(self, t: offset_coordinate) -> bool: ...

    def has_north_western_incoming_int(self, t: offset_coordinate) -> bool: ...

    def is_outgoing_int(self, t: offset_coordinate, s: int) -> bool: ...

    def has_no_outgoing_int(self, t: offset_coordinate) -> bool: ...

    def has_northern_outgoing_int(self, t: offset_coordinate) -> bool: ...

    def has_north_eastern_outgoing_int(self, t: offset_coordinate) -> bool: ...

    def has_eastern_outgoing_int(self, t: offset_coordinate) -> bool: ...

    def has_south_eastern_outgoing_int(self, t: offset_coordinate) -> bool: ...

    def has_southern_outgoing_int(self, t: offset_coordinate) -> bool: ...

    def has_south_western_outgoing_int(self, t: offset_coordinate) -> bool: ...

    def has_western_outgoing_int(self, t: offset_coordinate) -> bool: ...

    def has_north_western_outgoing_int(self, t: offset_coordinate) -> bool: ...

    def bounding_box_2d(self) -> Tuple[offset_coordinate, offset_coordinate]: ...

    def is_dead(self, n: int) -> bool: ...

    def __repr__(self) -> str: ...


class shifted_cartesian_gate_layout(clocked_shifted_cartesian_layout):
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, dimension: offset_coordinate) -> None: ...

    @overload
    def __init__(self, dimension: offset_coordinate, clocking_scheme: str = "2DDWave",
                 layout_name: str = "") -> None: ...

    def create_pi(self, name: str = "", t: Optional[offset_coordinate] = None) -> None: ...

    def create_po(self, s: int, name: str = "", t: Optional[offset_coordinate] = None) -> None: ...

    def is_pi(self, n: int) -> bool: ...

    def is_po(self, n: int) -> bool: ...

    def is_pi_coordinate(self, t: offset_coordinate) -> bool: ...

    def is_po_coordinate(self, t: offset_coordinate) -> bool: ...

    def is_inv(self) -> bool: ...

    def is_and(self) -> bool: ...

    def is_nand(self) -> bool: ...

    def is_or(self) -> bool: ...

    def is_nor(self) -> bool: ...

    def is_xor(self) -> bool: ...

    def is_xnor(self) -> bool: ...

    def is_maj(self) -> bool: ...

    def is_fanout(self) -> bool: ...

    def is_wire(self) -> bool: ...

    def set_layout_name(self, name: str) -> None: ...

    def get_layout_name(self) -> str: ...

    def set_input_name(self, index: int, name: str) -> None: ...

    def get_input_name(self, index: int) -> str: ...

    def set_output_name(self, index: int, name: str) -> None: ...

    def get_output_name(self, index: int) -> str: ...

    def get_name(self, s: int) -> str: ...

    def create_buf(self, a: int, t: Optional[offset_coordinate] = None) -> None: ...

    def create_not(self, a: int, t: Optional[offset_coordinate] = None) -> None: ...

    def create_and(self, a: int, b: int, t: Optional[offset_coordinate] = None) -> None: ...

    def create_nand(self, a: int, b: int, t: Optional[offset_coordinate] = None) -> None: ...

    def create_or(self, a: int, b: int, t: Optional[offset_coordinate] = None) -> None: ...

    def create_nor(self, a: int, b: int, t: Optional[offset_coordinate] = None) -> None: ...

    def create_xor(self, a: int, b: int, t: Optional[offset_coordinate] = None) -> None: ...

    def create_xnor(self, a: int, b: int, t: Optional[offset_coordinate] = None) -> None: ...

    def create_maj(self, a: int, b: int, c: int, t: Optional[offset_coordinate] = None) -> None: ...

    def num_pis(self) -> int: ...

    def num_pos(self) -> int: ...

    def num_gates(self) -> int: ...

    def num_wires(self) -> int: ...

    def num_crossings(self) -> int: ...

    def is_empty(self) -> bool: ...

    def fanin_size(self, n: int) -> int: ...

    def fanout_size(self, n: int) -> int: ...

    def get_int(self, t: offset_coordinate) -> int: ...

    def get_coordinate(self, n: int) -> offset_coordinate: ...

    def make_int(self, n: int) -> int: ...

    def move_int(self, n: int, t: offset_coordinate, new_children: List[offset_coordinate] = []) -> None: ...

    def clear_coordinate(self, t: offset_coordinate) -> None: ...

    def is_gate_coordinate(self, t: offset_coordinate) -> bool: ...

    def is_wire_coordinate(self, t: offset_coordinate) -> bool: ...

    def is_empty_coordinate(self, t: offset_coordinate) -> bool: ...

    def pis(self) -> List[offset_coordinate]: ...

    def pos(self) -> List[offset_coordinate]: ...

    def gates(self) -> List[offset_coordinate]: ...

    def wires(self) -> List[offset_coordinate]: ...

    def fanins(self, t: offset_coordinate) -> List[int]: ...

    def fanouts(self, t: offset_coordinate) -> List[int]: ...

    def is_incoming_int(self, t: offset_coordinate, s: int) -> bool: ...

    def has_no_incoming_int(self, t: offset_coordinate) -> bool: ...

    def has_northern_incoming_int(self, t: offset_coordinate) -> bool: ...

    def has_north_eastern_incoming_int(self, t: offset_coordinate) -> bool: ...

    def has_eastern_incoming_int(self, t: offset_coordinate) -> bool: ...

    def has_south_eastern_incoming_int(self, t: offset_coordinate) -> bool: ...

    def has_southern_incoming_int(self, t: offset_coordinate) -> bool: ...

    def has_south_western_incoming_int(self, t: offset_coordinate) -> bool: ...

    def has_western_incoming_int(self, t: offset_coordinate) -> bool: ...

    def has_north_western_incoming_int(self, t: offset_coordinate) -> bool: ...

    def is_outgoing_int(self, t: offset_coordinate, s: int) -> bool: ...

    def has_no_outgoing_int(self, t: offset_coordinate) -> bool: ...

    def has_northern_outgoing_int(self, t: offset_coordinate) -> bool: ...

    def has_north_eastern_outgoing_int(self, t: offset_coordinate) -> bool: ...

    def has_eastern_outgoing_int(self, t: offset_coordinate) -> bool: ...

    def has_south_eastern_outgoing_int(self, t: offset_coordinate) -> bool: ...

    def has_southern_outgoing_int(self, t: offset_coordinate) -> bool: ...

    def has_south_western_outgoing_int(self, t: offset_coordinate) -> bool: ...

    def has_western_outgoing_int(self, t: offset_coordinate) -> bool: ...

    def has_north_western_outgoing_int(self, t: offset_coordinate) -> bool: ...

    def bounding_box_2d(self) -> Tuple[offset_coordinate, offset_coordinate]: ...

    def is_dead(self, n: int) -> bool: ...

    def __repr__(self) -> str: ...


class hexagonal_gate_layout(clocked_hexagonal_layout):
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, dimension: cube_coordinate) -> None: ...

    @overload
    def __init__(self, dimension: cube_coordinate, clocking_scheme: str = "2DDWave",
                 layout_name: str = "") -> None: ...

    def create_pi(self, name: str = "", t: Optional[cube_coordinate] = None) -> None: ...

    def create_po(self, s: int, name: str = "", t: Optional[cube_coordinate] = None) -> None: ...

    def is_pi(self, n: int) -> bool: ...

    def is_po(self, n: int) -> bool: ...

    def is_pi_coordinate(self, t: cube_coordinate) -> bool: ...

    def is_po_coordinate(self, t: cube_coordinate) -> bool: ...

    def is_inv(self) -> bool: ...

    def is_and(self) -> bool: ...

    def is_nand(self) -> bool: ...

    def is_or(self) -> bool: ...

    def is_nor(self) -> bool: ...

    def is_xor(self) -> bool: ...

    def is_xnor(self) -> bool: ...

    def is_maj(self) -> bool: ...

    def is_fanout(self) -> bool: ...

    def is_wire(self) -> bool: ...

    def set_layout_name(self, name: str) -> None: ...

    def get_layout_name(self) -> str: ...

    def set_input_name(self, index: int, name: str) -> None: ...

    def get_input_name(self, index: int) -> str: ...

    def set_output_name(self, index: int, name: str) -> None: ...

    def get_output_name(self, index: int) -> str: ...

    def get_name(self, s: int) -> str: ...

    def create_buf(self, a: int, t: Optional[cube_coordinate] = None) -> None: ...

    def create_not(self, a: int, t: Optional[cube_coordinate] = None) -> None: ...

    def create_and(self, a: int, b: int, t: Optional[cube_coordinate] = None) -> None: ...

    def create_nand(self, a: int, b: int, t: Optional[cube_coordinate] = None) -> None: ...

    def create_or(self, a: int, b: int, t: Optional[cube_coordinate] = None) -> None: ...

    def create_nor(self, a: int, b: int, t: Optional[cube_coordinate] = None) -> None: ...

    def create_xor(self, a: int, b: int, t: Optional[cube_coordinate] = None) -> None: ...

    def create_xnor(self, a: int, b: int, t: Optional[cube_coordinate] = None) -> None: ...

    def create_maj(self, a: int, b: int, c: int, t: Optional[cube_coordinate] = None) -> None: ...

    def num_pis(self) -> int: ...

    def num_pos(self) -> int: ...

    def num_gates(self) -> int: ...

    def num_wires(self) -> int: ...

    def num_crossings(self) -> int: ...

    def is_empty(self) -> bool: ...

    def fanin_size(self, n: int) -> int: ...

    def fanout_size(self, n: int) -> int: ...

    def get_int(self, t: cube_coordinate) -> int: ...

    def get_coordinate(self, n: int) -> cube_coordinate: ...

    def make_int(self, n: int) -> int: ...

    def move_int(self, n: int, t: cube_coordinate, new_children: List[cube_coordinate] = []) -> None: ...

    def clear_coordinate(self, t: cube_coordinate) -> None: ...

    def is_gate_coordinate(self, t: cube_coordinate) -> bool: ...

    def is_wire_coordinate(self, t: cube_coordinate) -> bool: ...

    def is_empty_coordinate(self, t: cube_coordinate) -> bool: ...

    def pis(self) -> List[cube_coordinate]: ...

    def pos(self) -> List[cube_coordinate]: ...

    def gates(self) -> List[cube_coordinate]: ...

    def wires(self) -> List[cube_coordinate]: ...

    def fanins(self, t: cube_coordinate) -> List[int]: ...

    def fanouts(self, t: cube_coordinate) -> List[int]: ...

    def is_incoming_int(self, t: cube_coordinate, s: int) -> bool: ...

    def has_no_incoming_int(self, t: cube_coordinate) -> bool: ...

    def has_northern_incoming_int(self, t: cube_coordinate) -> bool: ...

    def has_north_eastern_incoming_int(self, t: cube_coordinate) -> bool: ...

    def has_eastern_incoming_int(self, t: cube_coordinate) -> bool: ...

    def has_south_eastern_incoming_int(self, t: cube_coordinate) -> bool: ...

    def has_southern_incoming_int(self, t: cube_coordinate) -> bool: ...

    def has_south_western_incoming_int(self, t: cube_coordinate) -> bool: ...

    def has_western_incoming_int(self, t: cube_coordinate) -> bool: ...

    def has_north_western_incoming_int(self, t: cube_coordinate) -> bool: ...

    def is_outgoing_int(self, t: cube_coordinate, s: int) -> bool: ...

    def has_no_outgoing_int(self, t: cube_coordinate) -> bool: ...

    def has_northern_outgoing_int(self, t: cube_coordinate) -> bool: ...

    def has_north_eastern_outgoing_int(self, t: cube_coordinate) -> bool: ...

    def has_eastern_outgoing_int(self, t: cube_coordinate) -> bool: ...

    def has_south_eastern_outgoing_int(self, t: cube_coordinate) -> bool: ...

    def has_southern_outgoing_int(self, t: cube_coordinate) -> bool: ...

    def has_south_western_outgoing_int(self, t: cube_coordinate) -> bool: ...

    def has_western_outgoing_int(self, t: cube_coordinate) -> bool: ...

    def has_north_western_outgoing_int(self, t: cube_coordinate) -> bool: ...

    def bounding_box_2d(self) -> Tuple[cube_coordinate, cube_coordinate]: ...

    def is_dead(self, n: int) -> bool: ...

    def __repr__(self) -> str: ...


class cartesian_obstruction_layout(cartesian_gate_layout):
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, layout: cartesian_gate_layout) -> None: ...

    def obstruct_coordinate(self, c: offset_coordinate) -> None: ...

    def obstruct_connection(self, src: offset_coordinate, tgt: offset_coordinate) -> None: ...

    def is_obstructed_coordinate(self, c: offset_coordinate) -> bool: ...

    def is_obstructed_connection(self, src: offset_coordinate, tgt: offset_coordinate) -> bool: ...

    def clear_obstructed_coordinate(self, c: offset_coordinate) -> None: ...

    def clear_obstructed_connection(self, src: offset_coordinate, tgt: offset_coordinate) -> None: ...

    def clear_obstructed_coordinates(self) -> None: ...

    def clear_obstructed_connections(self) -> None: ...


class shifted_cartesian_obstruction_layout(shifted_cartesian_gate_layout):
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, layout: shifted_cartesian_gate_layout) -> None: ...

    def obstruct_coordinate(self, c: offset_coordinate) -> None: ...

    def obstruct_connection(self, src: offset_coordinate, tgt: offset_coordinate) -> None: ...

    def is_obstructed_coordinate(self, c: offset_coordinate) -> bool: ...

    def is_obstructed_connection(self, src: offset_coordinate, tgt: offset_coordinate) -> bool: ...

    def clear_obstructed_coordinate(self, c: offset_coordinate) -> None: ...

    def clear_obstructed_connection(self, src: offset_coordinate, tgt: offset_coordinate) -> None: ...

    def clear_obstructed_coordinates(self) -> None: ...

    def clear_obstructed_connections(self) -> None: ...


class hexagonal_obstruction_layout(hexagonal_gate_layout):
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, layout: hexagonal_gate_layout) -> None: ...

    def obstruct_coordinate(self, c: cube_coordinate) -> None: ...

    def obstruct_connection(self, src: cube_coordinate, tgt: cube_coordinate) -> None: ...

    def is_obstructed_coordinate(self, c: cube_coordinate) -> bool: ...

    def is_obstructed_connection(self, src: cube_coordinate, tgt: cube_coordinate) -> bool: ...

    def clear_obstructed_coordinate(self, c: cube_coordinate) -> None: ...

    def clear_obstructed_connection(self, src: cube_coordinate, tgt: cube_coordinate) -> None: ...

    def clear_obstructed_coordinates(self) -> None: ...

    def clear_obstructed_connections(self) -> None: ...


class qca_technology:
    class cell_type(Enum):
        EMPTY = ...
        NORMAL = ...
        INPUT = ...
        OUTPUT = ...
        CONST_0 = ...
        CONST_1 = ...


class inml_technology:
    class cell_type(Enum):
        EMPTY = ...
        NORMAL = ...
        INPUT = ...
        OUTPUT = ...
        SLANTED_EDGE_UP_MAGNET = ...
        SLANTED_EDGE_DOWN_MAGNET = ...
        INVERTER_MAGNET = ...
        CROSSWIRE_MAGNET = ...
        FANOUT_COUPLER_MAGNET = ...


class sidb_technology:
    class cell_type(Enum):
        EMPTY = ...
        NORMAL = ...
        INPUT = ...
        OUTPUT = ...
        LOGIC = ...


class qca_layout(clocked_cartesian_layout):
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, dimension: offset_coordinate) -> None: ...

    @overload
    def __init__(self, dimension: offset_coordinate, clocking_scheme: str = "2DDWave",
                 layout_name: str = "") -> None: ...

    def assign_cell_type(self, c: offset_coordinate, ct: qca_technology.cell_type) -> None: ...

    def get_cell_type(self, c: offset_coordinate) -> qca_technology.cell_type: ...

    def is_empty_cell(self, c: offset_coordinate) -> bool: ...

    def assign_cell_name(self, c: offset_coordinate, n: str) -> None: ...

    def get_cell_name(self, c: offset_coordinate) -> Optional[str]: ...

    def set_layout_name(self, name: str) -> None: ...

    def get_layout_name(self) -> str: ...

    def num_cells(self) -> int: ...

    def is_empty(self) -> bool: ...

    def num_pis(self) -> int: ...

    def num_pos(self) -> int: ...

    def is_pi(self, c: offset_coordinate) -> bool: ...

    def is_po(self, c: offset_coordinate) -> bool: ...

    def cells(self) -> List[offset_coordinate]: ...

    def pis(self) -> List[offset_coordinate]: ...

    def pos(self) -> List[offset_coordinate]: ...

    def bounding_box_2d(self) -> Tuple[offset_coordinate, offset_coordinate]: ...

    def __repr__(self) -> str: ...


class inml_layout(clocked_cartesian_layout):
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, dimension: offset_coordinate) -> None: ...

    @overload
    def __init__(self, dimension: offset_coordinate, clocking_scheme: str = "2DDWave",
                 layout_name: str = "") -> None: ...

    def assign_cell_type(self, c: offset_coordinate, ct: inml_technology.cell_type) -> None: ...

    def get_cell_type(self, c: offset_coordinate) -> inml_technology.cell_type: ...

    def is_empty_cell(self, c: offset_coordinate) -> bool: ...

    def assign_cell_name(self, c: offset_coordinate, n: str) -> None: ...

    def get_cell_name(self, c: offset_coordinate) -> Optional[str]: ...

    def set_layout_name(self, name: str) -> None: ...

    def get_layout_name(self) -> str: ...

    def num_cells(self) -> int: ...

    def is_empty(self) -> bool: ...

    def num_pis(self) -> int: ...

    def num_pos(self) -> int: ...

    def is_pi(self, c: offset_coordinate) -> bool: ...

    def is_po(self, c: offset_coordinate) -> bool: ...

    def cells(self) -> List[offset_coordinate]: ...

    def pis(self) -> List[offset_coordinate]: ...

    def pos(self) -> List[offset_coordinate]: ...

    def bounding_box_2d(self) -> Tuple[offset_coordinate, offset_coordinate]: ...

    def __repr__(self) -> str: ...


class sidb_layout(clocked_cartesian_layout):
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, dimension: offset_coordinate) -> None: ...

    @overload
    def __init__(self, dimension: offset_coordinate, clocking_scheme: str = "2DDWave",
                 layout_name: str = "") -> None: ...

    def assign_cell_type(self, c: offset_coordinate, ct: sidb_technology.cell_type) -> None: ...

    def get_cell_type(self, c: offset_coordinate) -> sidb_technology.cell_type: ...

    def is_empty_cell(self, c: offset_coordinate) -> bool: ...

    def assign_cell_name(self, c: offset_coordinate, n: str) -> None: ...

    def get_cell_name(self, c: offset_coordinate) -> Optional[str]: ...

    def set_layout_name(self, name: str) -> None: ...

    def get_layout_name(self) -> str: ...

    def num_cells(self) -> int: ...

    def is_empty(self) -> bool: ...

    def num_pis(self) -> int: ...

    def num_pos(self) -> int: ...

    def is_pi(self, c: offset_coordinate) -> bool: ...

    def is_po(self, c: offset_coordinate) -> bool: ...

    def cells(self) -> List[offset_coordinate]: ...

    def pis(self) -> List[offset_coordinate]: ...

    def pos(self) -> List[offset_coordinate]: ...

    def bounding_box_2d(self) -> Tuple[offset_coordinate, offset_coordinate]: ...

    def __repr__(self) -> str: ...


# Networks

class technology_network_node:
    def __hash__(self) -> int: ...


class technology_network:
    def __init__(self) -> None: ...

    def size(self) -> int: ...

    def num_gates(self) -> int: ...

    def num_pis(self) -> int: ...

    def num_pos(self) -> int: ...

    def nodes(self) -> List[technology_network_node]: ...

    def gates(self) -> List[technology_network_node]: ...

    def pis(self) -> List[technology_network_node]: ...

    def pos(self) -> List[technology_network_node]: ...

    def fanins(self, n: technology_network_node) -> List[technology_network_node]: ...

    def is_constant(self, n: technology_network_node) -> bool: ...

    def is_pi(self, n: technology_network_node) -> bool: ...

    def is_po(self, n: technology_network_node) -> bool: ...

    def is_buf(self, n: technology_network_node) -> bool: ...

    def is_fanout(self, n: technology_network_node) -> bool: ...

    def is_inv(self, n: technology_network_node) -> bool: ...

    def is_and(self, n: technology_network_node) -> bool: ...

    def is_or(self, n: technology_network_node) -> bool: ...

    def is_xor(self, n: technology_network_node) -> bool: ...

    def is_maj(self, n: technology_network_node) -> bool: ...

    def is_nand(self, n: technology_network_node) -> bool: ...

    def is_nor(self, n: technology_network_node) -> bool: ...

    def is_xnor(self, n: technology_network_node) -> bool: ...

    def has_name(self, n: technology_network_node) -> bool: ...

    def get_name(self, n: technology_network_node) -> Optional[str]: ...

    def has_output_name(self, index: int) -> bool: ...

    def get_output_name(self, index: int) -> Optional[str]: ...

    def po_index(self, n: technology_network_node) -> int: ...

    def po_at(self, index: int) -> technology_network_node: ...


def read_technology_network(filename: str) -> technology_network: ...


class dynamic_truth_table:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, num_vars: int) -> None: ...

    def num_vars(self) -> int: ...

    def num_blocks(self) -> int: ...

    def num_bits(self) -> int: ...


# Algorithms

## path finding

from typing import overload, Union


@overload
def manhattan_distance(layout: Union[cartesian_layout, shifted_cartesian_layout], source: offset_coordinate,
                       target: offset_coordinate) -> int: ...


@overload
def manhattan_distance(layout: hexagonal_layout, source: cube_coordinate, target: cube_coordinate) -> int: ...


@overload
def euclidean_distance(layout: Union[cartesian_layout, shifted_cartesian_layout], source: offset_coordinate,
                       target: offset_coordinate) -> float: ...


@overload
def euclidean_distance(layout: hexagonal_layout, source: cube_coordinate, target: cube_coordinate) -> float: ...


@overload
def squared_euclidean_distance(layout: Union[cartesian_layout, shifted_cartesian_layout], source: offset_coordinate,
                               target: offset_coordinate) -> float: ...


@overload
def squared_euclidean_distance(layout: hexagonal_layout, source: cube_coordinate, target: cube_coordinate) -> float: ...


@overload
def twoddwave_distance(layout: Union[cartesian_layout, shifted_cartesian_layout], source: offset_coordinate,
                       target: offset_coordinate) -> int: ...


@overload
def twoddwave_distance(layout: hexagonal_layout, source: cube_coordinate, target: cube_coordinate) -> int: ...


@overload
def chebyshev_distance(layout: Union[cartesian_layout, shifted_cartesian_layout], source: offset_coordinate,
                       target: offset_coordinate) -> int: ...


@overload
def chebyshev_distance(layout: hexagonal_layout, source: cube_coordinate, target: cube_coordinate) -> int: ...


class a_star_params:
    def __init__(self): ...

    crossings: bool


@overload
def a_star(
        layout: Union[
            cartesian_obstruction_layout,
            cartesian_gate_layout,
            cartesian_layout,
            shifted_cartesian_obstruction_layout,
            shifted_cartesian_gate_layout,
            shifted_cartesian_layout
        ],
        source: offset_coordinate,
        target: offset_coordinate,
        params: a_star_params
) -> List[offset_coordinate]: ...


@overload
def a_star(
        layout: Union[
            hexagonal_obstruction_layout,
            hexagonal_gate_layout,
            hexagonal_layout
        ],
        source: cube_coordinate,
        target: cube_coordinate,
        params: a_star_params
) -> List[cube_coordinate]: ...


class enumerate_all_paths_params:
    def __init__(self): ...

    crossings: bool


@overload
def enumerate_all_paths(
        layout: Union[
            cartesian_obstruction_layout,
            cartesian_gate_layout,
            cartesian_layout,
            shifted_cartesian_obstruction_layout,
            shifted_cartesian_gate_layout,
            shifted_cartesian_layout
        ],
        source: offset_coordinate,
        target: offset_coordinate,
        params: a_star_params
) -> List[List[offset_coordinate]]: ...


@overload
def enumerate_all_paths(
        layout: Union[
            hexagonal_obstruction_layout,
            hexagonal_gate_layout,
            hexagonal_layout
        ],
        source: cube_coordinate,
        target: cube_coordinate,
        params: a_star_params
) -> List[List[cube_coordinate]]: ...
