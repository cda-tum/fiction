from collections.abc import Iterable
from enum import Enum
from typing import Any, Callable, ClassVar, overload

from typing_extensions import Self

# Layouts

class offset_coordinate:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, int_repr: int) -> None: ...
    @overload
    def __init__(self, x: int, y: int, z: int = 0) -> None: ...
    @overload
    def __init__(self, c: offset_coordinate) -> None: ...
    @overload
    def __init__(self, c: tuple[int, int, int]) -> None: ...

    x: int
    y: int
    z: int

    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: offset_coordinate) -> bool: ...
    def __gt__(self, other: offset_coordinate) -> bool: ...
    def __le__(self, other: offset_coordinate) -> bool: ...
    def __ge__(self, other: offset_coordinate) -> bool: ...
    def __hash__(self) -> int: ...

class cube_coordinate:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: int, y: int, z: int = 0) -> None: ...
    @overload
    def __init__(self, c: cube_coordinate) -> None: ...
    @overload
    def __init__(self, c: tuple[int, int, int]) -> None: ...

    x: int
    y: int
    z: int

    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: cube_coordinate) -> bool: ...
    def __gt__(self, other: cube_coordinate) -> bool: ...
    def __le__(self, other: cube_coordinate) -> bool: ...
    def __ge__(self, other: cube_coordinate) -> bool: ...
    def __hash__(self) -> int: ...

class siqad_coordinate:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: int, y: int, z: int = 0) -> None: ...
    @overload
    def __init__(self, c: siqad_coordinate) -> None: ...
    @overload
    def __init__(self, c: tuple[int, int, int]) -> None: ...

    x: int
    y: int
    z: int

    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: siqad_coordinate) -> bool: ...
    def __gt__(self, other: siqad_coordinate) -> bool: ...
    def __le__(self, other: siqad_coordinate) -> bool: ...
    def __ge__(self, other: siqad_coordinate) -> bool: ...
    def __hash__(self) -> int: ...

# For consistent behavior:
@overload
def area(coord: offset_coordinate | cube_coordinate | siqad_coordinate) -> float: ...
def volume(coord: offset_coordinate | cube_coordinate | siqad_coordinate) -> float: ...

# For conversions with potentially nuanced behavior:
def to_offset_coord(coord: siqad_coordinate) -> offset_coordinate: ...
def to_cube_coord(coord: siqad_coordinate) -> cube_coordinate: ...
@overload
def to_siqad_coord(coord: offset_coordinate) -> siqad_coordinate: ...
@overload
def to_siqad_coord(coord: cube_coordinate) -> siqad_coordinate: ...

class cartesian_layout:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> None: ...
    def coord(self, x: int, y: int, z: int = 0) -> offset_coordinate: ...
    def x(self) -> int: ...
    def y(self) -> int: ...
    def z(self) -> int: ...
    def area(self) -> int: ...
    def resize(self, dimension: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> None: ...
    def north(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> offset_coordinate | None: ...
    def north_east(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> offset_coordinate | None: ...
    def east(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> offset_coordinate | None: ...
    def south_east(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> offset_coordinate | None: ...
    def south(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> offset_coordinate | None: ...
    def south_west(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> offset_coordinate | None: ...
    def west(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> offset_coordinate | None: ...
    def north_west(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> offset_coordinate | None: ...
    def above(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> offset_coordinate | None: ...
    def below(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> offset_coordinate | None: ...
    def is_north_of(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_east_of(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_south_of(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_west_of(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_adjacent_of(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_adjacent_elevation_of(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_above(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_below(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_northwards_of(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_eastwards_of(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_southwards_of(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_westwards_of(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_at_northern_border(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_at_eastern_border(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_at_southern_border(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_at_western_border(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_at_any_border(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def northern_border_of(
        self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> offset_coordinate | None: ...
    def eastern_border_of(
        self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> offset_coordinate | None: ...
    def southern_border_of(
        self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> offset_coordinate | None: ...
    def western_border_of(
        self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> offset_coordinate | None: ...
    def is_ground_layer(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_crossing_layer(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_within_bounds(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def offset_coordinates(self) -> list[offset_coordinate]: ...
    def ground_coordinates(self) -> list[offset_coordinate]: ...
    def adjacent_coordinates(
        self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> list[offset_coordinate]: ...
    def adjacent_opposite_coordinates(
        self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> list[offset_coordinate]: ...

class shifted_cartesian_layout:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> None: ...
    def coord(self, x: int, y: int, z: int = 0) -> offset_coordinate: ...
    def x(self) -> int: ...
    def y(self) -> int: ...
    def z(self) -> int: ...
    def area(self) -> int: ...
    def resize(self, dimension: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> None: ...
    def north(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> offset_coordinate | None: ...
    def north_east(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> offset_coordinate | None: ...
    def east(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> offset_coordinate | None: ...
    def south_east(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> offset_coordinate | None: ...
    def south(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> offset_coordinate | None: ...
    def south_west(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> offset_coordinate | None: ...
    def west(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> offset_coordinate | None: ...
    def north_west(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> offset_coordinate | None: ...
    def above(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> offset_coordinate | None: ...
    def below(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> offset_coordinate | None: ...
    def is_north_of(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_east_of(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_south_of(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_west_of(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_adjacent_of(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_adjacent_elevation_of(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_above(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_below(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_northwards_of(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_eastwards_of(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_southwards_of(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_westwards_of(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_at_northern_border(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_at_eastern_border(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_at_southern_border(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_at_western_border(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_at_any_border(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def northern_border_of(
        self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> offset_coordinate | None: ...
    def eastern_border_of(
        self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> offset_coordinate | None: ...
    def southern_border_of(
        self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> offset_coordinate | None: ...
    def western_border_of(
        self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> offset_coordinate | None: ...
    def is_ground_layer(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_crossing_layer(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_within_bounds(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def coordinates(self) -> list[offset_coordinate]: ...
    def ground_coordinates(self) -> list[offset_coordinate]: ...
    def adjacent_coordinates(
        self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> list[offset_coordinate]: ...
    def adjacent_opposite_coordinates(
        self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> list[offset_coordinate]: ...

class hexagonal_layout:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> None: ...
    def coord(self, x: int, y: int, z: int = 0) -> cube_coordinate: ...
    def x(self) -> int: ...
    def y(self) -> int: ...
    def z(self) -> int: ...
    def area(self) -> int: ...
    def resize(self, dimension: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> None: ...
    def north(self, c: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> cube_coordinate | None: ...
    def north_east(self, c: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> cube_coordinate | None: ...
    def east(self, c: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> cube_coordinate | None: ...
    def south_east(self, c: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> cube_coordinate | None: ...
    def south(self, c: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> cube_coordinate | None: ...
    def south_west(self, c: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> cube_coordinate | None: ...
    def west(self, c: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> cube_coordinate | None: ...
    def north_west(self, c: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> cube_coordinate | None: ...
    def above(self, c: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> cube_coordinate | None: ...
    def below(self, c: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> cube_coordinate | None: ...
    def is_north_of(
        self,
        c1: cube_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: cube_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_east_of(
        self,
        c1: cube_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: cube_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_south_of(
        self,
        c1: cube_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: cube_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_west_of(
        self,
        c1: cube_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: cube_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_adjacent_of(
        self,
        c1: cube_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: cube_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_adjacent_elevation_of(
        self,
        c1: cube_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: cube_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_above(
        self,
        c1: cube_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: cube_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_below(
        self,
        c1: cube_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: cube_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_northwards_of(
        self,
        c1: cube_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: cube_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_eastwards_of(
        self,
        c1: cube_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: cube_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_southwards_of(
        self,
        c1: cube_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: cube_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_westwards_of(
        self,
        c1: cube_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: cube_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_at_northern_border(self, c: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_at_eastern_border(self, c: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_at_southern_border(self, c: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_at_western_border(self, c: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_at_any_border(self, c: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def northern_border_of(
        self, c: cube_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> cube_coordinate | None: ...
    def eastern_border_of(
        self, c: cube_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> cube_coordinate | None: ...
    def southern_border_of(
        self, c: cube_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> cube_coordinate | None: ...
    def western_border_of(
        self, c: cube_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> cube_coordinate | None: ...
    def is_ground_layer(self, c: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_crossing_layer(self, c: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_within_bounds(self, c: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def coordinates(self) -> list[cube_coordinate]: ...
    def ground_coordinates(self) -> list[cube_coordinate]: ...
    def adjacent_coordinates(
        self, c: cube_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> list[cube_coordinate]: ...
    def adjacent_opposite_coordinates(
        self, c: cube_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> list[cube_coordinate]: ...

class clocked_cartesian_layout(cartesian_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> None: ...
    @overload
    def __init__(
        self, dimension: offset_coordinate | tuple[int, int] | tuple[int, int, int], clocking_scheme: str = "2DDWave"
    ) -> None: ...
    def assign_clock_number(self, cz: offset_coordinate | tuple[int, int] | tuple[int, int, int], cn: int) -> None: ...
    def get_clock_number(self, cz: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> int: ...
    def num_clocks(self) -> int: ...
    def is_regularly_clocked(self) -> bool: ...
    def is_clocking_scheme(self, name: str) -> bool: ...
    def is_incoming_clocked(
        self,
        cz1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        cz2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_outgoing_clocked(
        self,
        cz1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        cz2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def incoming_clocked_zones(
        self, cz: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> list[offset_coordinate]: ...
    def outgoing_clocked_zones(
        self, cz: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> list[offset_coordinate]: ...
    def in_degree(self, cz: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> int: ...
    def out_degree(self, cz: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> int: ...
    def degree(self, cz: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> int: ...

class clocked_shifted_cartesian_layout(shifted_cartesian_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> None: ...
    @overload
    def __init__(
        self, dimension: offset_coordinate | tuple[int, int] | tuple[int, int, int], clocking_scheme: str = "2DDWave"
    ) -> None: ...
    def assign_clock_number(self, cz: offset_coordinate | tuple[int, int] | tuple[int, int, int], cn: int) -> None: ...
    def get_clock_number(self, cz: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> int: ...
    def num_clocks(self) -> int: ...
    def is_regularly_clocked(self) -> bool: ...
    def is_clocking_scheme(self, name: str) -> bool: ...
    def is_incoming_clocked(
        self,
        cz1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        cz2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_outgoing_clocked(
        self,
        cz1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        cz2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def incoming_clocked_zones(
        self, cz: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> list[offset_coordinate]: ...
    def outgoing_clocked_zones(
        self, cz: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> list[offset_coordinate]: ...
    def in_degree(self, cz: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> int: ...
    def out_degree(self, cz: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> int: ...
    def degree(self, cz: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> int: ...

class clocked_hexagonal_layout(hexagonal_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> None: ...
    @overload
    def __init__(
        self, dimension: cube_coordinate | tuple[int, int] | tuple[int, int, int], clocking_scheme: str = "2DDWave"
    ) -> None: ...
    def assign_clock_number(self, cz: cube_coordinate | tuple[int, int] | tuple[int, int, int], cn: int) -> None: ...
    def get_clock_number(self, cz: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> int: ...
    def num_clocks(self) -> int: ...
    def is_regularly_clocked(self) -> bool: ...
    def is_clocking_scheme(self, name: str) -> bool: ...
    def is_incoming_clocked(
        self,
        cz1: cube_coordinate | tuple[int, int] | tuple[int, int, int],
        cz2: cube_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def is_outgoing_clocked(
        self,
        cz1: cube_coordinate | tuple[int, int] | tuple[int, int, int],
        cz2: cube_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def incoming_clocked_zones(
        self, cz: cube_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> list[cube_coordinate]: ...
    def outgoing_clocked_zones(
        self, cz: cube_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> list[cube_coordinate]: ...
    def in_degree(self, cz: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> int: ...
    def out_degree(self, cz: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> int: ...
    def degree(self, cz: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> int: ...

class cartesian_gate_layout(clocked_cartesian_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> None: ...
    @overload
    def __init__(
        self,
        dimension: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        clocking_scheme: str = "2DDWave",
        layout_name: str = "",
    ) -> None: ...
    def create_pi(
        self, name: str = "", t: offset_coordinate | tuple[int, int] | tuple[int, int, int] | None = ...
    ) -> int: ...
    def create_po(
        self, s: int, name: str = "", t: offset_coordinate | tuple[int, int] | tuple[int, int, int] | None = ...
    ) -> int: ...
    def is_pi(self, n: int) -> bool: ...
    def is_po(self, n: int) -> bool: ...
    def is_pi_coordinate(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_po_coordinate(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_inv(self) -> bool: ...
    def is_and(self) -> bool: ...
    def is_nand(self) -> bool: ...
    def is_or(self) -> bool: ...
    def is_nor(self) -> bool: ...
    def is_xor(self) -> bool: ...
    def is_xnor(self) -> bool: ...
    def is_maj(self) -> bool: ...
    def is_fanout(self) -> bool: ...
    def is_wire(self) -> bool: ...
    def set_layout_name(self, name: str) -> None: ...
    def set_name(self, name: str) -> None: ...
    def get_layout_name(self) -> str: ...
    def set_input_name(self, index: int, name: str) -> None: ...
    def get_input_name(self, index: int) -> str: ...
    def set_output_name(self, index: int, name: str) -> None: ...
    def get_output_name(self, index: int) -> str: ...
    def get_name(self, s: int) -> str: ...
    def create_buf(
        self, a: int, t: offset_coordinate | tuple[int, int] | tuple[int, int, int] | None = None
    ) -> int: ...
    def create_not(
        self, a: int, t: offset_coordinate | tuple[int, int] | tuple[int, int, int] | None = None
    ) -> int: ...
    def create_and(
        self, a: int, b: int, t: offset_coordinate | tuple[int, int] | tuple[int, int, int] | None = None
    ) -> int: ...
    def create_nand(
        self, a: int, b: int, t: offset_coordinate | tuple[int, int] | tuple[int, int, int] | None = None
    ) -> int: ...
    def create_or(
        self, a: int, b: int, t: offset_coordinate | tuple[int, int] | tuple[int, int, int] | None = None
    ) -> int: ...
    def create_nor(
        self, a: int, b: int, t: offset_coordinate | tuple[int, int] | tuple[int, int, int] | None = None
    ) -> int: ...
    def create_xor(
        self, a: int, b: int, t: offset_coordinate | tuple[int, int] | tuple[int, int, int] | None = None
    ) -> int: ...
    def create_xnor(
        self, a: int, b: int, t: offset_coordinate | tuple[int, int] | tuple[int, int, int] | None = None
    ) -> int: ...
    def create_maj(
        self, a: int, b: int, c: int, t: offset_coordinate | tuple[int, int] | tuple[int, int, int] | None = None
    ) -> int: ...
    def num_pis(self) -> int: ...
    def num_pos(self) -> int: ...
    def num_gates(self) -> int: ...
    def num_wires(self) -> int: ...
    def num_crossings(self) -> int: ...
    def is_empty(self) -> bool: ...
    def fanin_size(self, n: int) -> int: ...
    def fanout_size(self, n: int) -> int: ...
    def get_node(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> int: ...
    def get_tile(self, n: int) -> int: ...
    def make_signal(self, n: int) -> int: ...
    def move_node(
        self,
        n: int,
        t: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        new_children: list[offset_coordinate] = [],
    ) -> None: ...
    def clear_tile(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> None: ...
    def is_gate_tile(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_wire_tile(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_empty_tile(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def pis(self) -> list[offset_coordinate]: ...
    def pos(self) -> list[offset_coordinate]: ...
    def gates(self) -> list[offset_coordinate]: ...
    def wires(self) -> list[offset_coordinate]: ...
    def fanins(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> list[int]: ...
    def fanouts(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> list[int]: ...
    def is_incoming_signal(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int], s: int) -> bool: ...
    def has_no_incoming_signal(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def has_northern_incoming_signal(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def has_north_eastern_incoming_signal(
        self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> bool: ...
    def has_eastern_incoming_signal(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def has_south_eastern_incoming_signal(
        self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> bool: ...
    def has_southern_incoming_signal(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def has_south_western_incoming_signal(
        self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> bool: ...
    def has_western_incoming_signal(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def has_north_western_incoming_signal(
        self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> bool: ...
    def is_outgoing_signal(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int], s: int) -> bool: ...
    def has_no_outgoing_signal(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def has_northern_outgoing_signal(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def has_north_eastern_outgoing_signal(
        self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> bool: ...
    def has_eastern_outgoing_signal(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def has_south_eastern_outgoing_signal(
        self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> bool: ...
    def has_southern_outgoing_signal(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def has_south_western_outgoing_signal(
        self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> bool: ...
    def has_western_outgoing_signal(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def has_north_western_outgoing_signal(
        self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> bool: ...
    def bounding_box_2d(self) -> tuple[offset_coordinate, offset_coordinate]: ...
    def is_dead(self, n: int) -> bool: ...

class shifted_cartesian_gate_layout(clocked_shifted_cartesian_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> None: ...
    @overload
    def __init__(
        self,
        dimension: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        clocking_scheme: str = "2DDWave",
        layout_name: str = "",
    ) -> None: ...
    def create_pi(
        self, name: str = "", t: offset_coordinate | tuple[int, int] | tuple[int, int, int] | None = ...
    ) -> int: ...
    def create_po(
        self, s: int, name: str = "", t: offset_coordinate | tuple[int, int] | tuple[int, int, int] | None = ...
    ) -> int: ...
    def is_pi(self, n: int) -> bool: ...
    def is_po(self, n: int) -> bool: ...
    def is_pi_coordinate(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_po_coordinate(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_inv(self) -> bool: ...
    def is_and(self) -> bool: ...
    def is_nand(self) -> bool: ...
    def is_or(self) -> bool: ...
    def is_nor(self) -> bool: ...
    def is_xor(self) -> bool: ...
    def is_xnor(self) -> bool: ...
    def is_maj(self) -> bool: ...
    def is_fanout(self) -> bool: ...
    def is_wire(self) -> bool: ...
    def set_layout_name(self, name: str) -> None: ...
    def get_layout_name(self) -> str: ...
    def set_input_name(self, index: int, name: str) -> None: ...
    def get_input_name(self, index: int) -> str: ...
    def set_output_name(self, index: int, name: str) -> None: ...
    def get_output_name(self, index: int) -> str: ...
    def get_name(self, s: int) -> str: ...
    def create_buf(
        self, a: int, t: offset_coordinate | tuple[int, int] | tuple[int, int, int] | None = None
    ) -> int: ...
    def create_not(
        self, a: int, t: offset_coordinate | tuple[int, int] | tuple[int, int, int] | None = None
    ) -> int: ...
    def create_and(
        self, a: int, b: int, t: offset_coordinate | tuple[int, int] | tuple[int, int, int] | None = None
    ) -> int: ...
    def create_nand(
        self, a: int, b: int, t: offset_coordinate | tuple[int, int] | tuple[int, int, int] | None = None
    ) -> int: ...
    def create_or(
        self, a: int, b: int, t: offset_coordinate | tuple[int, int] | tuple[int, int, int] | None = None
    ) -> int: ...
    def create_nor(
        self, a: int, b: int, t: offset_coordinate | tuple[int, int] | tuple[int, int, int] | None = None
    ) -> int: ...
    def create_xor(
        self, a: int, b: int, t: offset_coordinate | tuple[int, int] | tuple[int, int, int] | None = None
    ) -> int: ...
    def create_xnor(
        self, a: int, b: int, t: offset_coordinate | tuple[int, int] | tuple[int, int, int] | None = None
    ) -> int: ...
    def create_maj(
        self, a: int, b: int, c: int, t: offset_coordinate | tuple[int, int] | tuple[int, int, int] | None = None
    ) -> int: ...
    def num_pis(self) -> int: ...
    def num_pos(self) -> int: ...
    def num_gates(self) -> int: ...
    def num_wires(self) -> int: ...
    def num_crossings(self) -> int: ...
    def is_empty(self) -> bool: ...
    def fanin_size(self, n: int) -> int: ...
    def fanout_size(self, n: int) -> int: ...
    def get_tile(self, n: int) -> int: ...
    def get_coordinate(self, n: int) -> offset_coordinate: ...
    def make_signal(self, n: int) -> int: ...
    def move_node(
        self,
        n: int,
        t: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        new_children: list[offset_coordinate] = [],
    ) -> None: ...
    def clear_tile(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> None: ...
    def is_gate_tile(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_wire_tile(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_empty_tile(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def pis(self) -> list[offset_coordinate]: ...
    def pos(self) -> list[offset_coordinate]: ...
    def gates(self) -> list[offset_coordinate]: ...
    def wires(self) -> list[offset_coordinate]: ...
    def fanins(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> list[int]: ...
    def fanouts(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> list[int]: ...
    def is_incoming_signal(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int], s: int) -> bool: ...
    def has_no_incoming_signal(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def has_northern_incoming_signal(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def has_north_eastern_incoming_signal(
        self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> bool: ...
    def has_eastern_incoming_signal(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def has_south_eastern_incoming_signal(
        self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> bool: ...
    def has_southern_incoming_signal(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def has_south_western_incoming_signal(
        self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> bool: ...
    def has_western_incoming_signal(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def has_north_western_incoming_signal(
        self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> bool: ...
    def is_outgoing_signal(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int], s: int) -> bool: ...
    def has_no_outgoing_signal(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def has_northern_outgoing_signal(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def has_north_eastern_outgoing_signal(
        self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> bool: ...
    def has_eastern_outgoing_signal(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def has_south_eastern_outgoing_signal(
        self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> bool: ...
    def has_southern_outgoing_signal(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def has_south_western_outgoing_signal(
        self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> bool: ...
    def has_western_outgoing_signal(self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def has_north_western_outgoing_signal(
        self, t: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> bool: ...
    def bounding_box_2d(self) -> tuple[offset_coordinate, offset_coordinate]: ...
    def is_dead(self, n: int) -> bool: ...

class hexagonal_gate_layout(clocked_hexagonal_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> None: ...
    @overload
    def __init__(
        self,
        dimension: cube_coordinate | tuple[int, int] | tuple[int, int, int],
        clocking_scheme: str = "2DDWave",
        layout_name: str = "",
    ) -> None: ...
    def create_pi(
        self, name: str = "", t: cube_coordinate | tuple[int, int] | tuple[int, int, int] | None = ...
    ) -> int: ...
    def create_po(
        self, s: int, name: str = "", t: cube_coordinate | tuple[int, int] | tuple[int, int, int] | None = ...
    ) -> int: ...
    def is_pi(self, n: int) -> bool: ...
    def is_po(self, n: int) -> bool: ...
    def is_pi_coordinate(self, t: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_po_coordinate(self, t: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_inv(self) -> bool: ...
    def is_and(self) -> bool: ...
    def is_nand(self) -> bool: ...
    def is_or(self) -> bool: ...
    def is_nor(self) -> bool: ...
    def is_xor(self) -> bool: ...
    def is_xnor(self) -> bool: ...
    def is_maj(self) -> bool: ...
    def is_fanout(self) -> bool: ...
    def is_wire(self) -> bool: ...
    def set_layout_name(self, name: str) -> None: ...
    def get_layout_name(self) -> str: ...
    def set_input_name(self, index: int, name: str) -> None: ...
    def get_input_name(self, index: int) -> str: ...
    def set_output_name(self, index: int, name: str) -> None: ...
    def get_output_name(self, index: int) -> str: ...
    def get_name(self, s: int) -> str: ...
    def create_buf(self, a: int, t: cube_coordinate | tuple[int, int] | tuple[int, int, int] | None = None) -> int: ...
    def create_not(self, a: int, t: cube_coordinate | tuple[int, int] | tuple[int, int, int] | None = None) -> int: ...
    def create_and(
        self, a: int, b: int, t: cube_coordinate | tuple[int, int] | tuple[int, int, int] | None = None
    ) -> int: ...
    def create_nand(
        self, a: int, b: int, t: cube_coordinate | tuple[int, int] | tuple[int, int, int] | None = None
    ) -> int: ...
    def create_or(
        self, a: int, b: int, t: cube_coordinate | tuple[int, int] | tuple[int, int, int] | None = None
    ) -> int: ...
    def create_nor(
        self, a: int, b: int, t: cube_coordinate | tuple[int, int] | tuple[int, int, int] | None = None
    ) -> int: ...
    def create_xor(
        self, a: int, b: int, t: cube_coordinate | tuple[int, int] | tuple[int, int, int] | None = None
    ) -> int: ...
    def create_xnor(
        self, a: int, b: int, t: cube_coordinate | tuple[int, int] | tuple[int, int, int] | None = None
    ) -> int: ...
    def create_maj(
        self, a: int, b: int, c: int, t: cube_coordinate | tuple[int, int] | tuple[int, int, int] | None = None
    ) -> int: ...
    def num_pis(self) -> int: ...
    def num_pos(self) -> int: ...
    def num_gates(self) -> int: ...
    def num_wires(self) -> int: ...
    def num_crossings(self) -> int: ...
    def is_empty(self) -> bool: ...
    def fanin_size(self, n: int) -> int: ...
    def fanout_size(self, n: int) -> int: ...
    def get_tile(self, n: int) -> int: ...
    def get_coordinate(self, n: int) -> cube_coordinate: ...
    def make_signal(self, n: int) -> int: ...
    def move_node(
        self,
        n: int,
        t: cube_coordinate | tuple[int, int] | tuple[int, int, int],
        new_children: list[cube_coordinate] = [],
    ) -> None: ...
    def clear_tile(self, t: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> None: ...
    def is_gate_tile(self, t: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_wire_tile(self, t: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_empty_tile(self, t: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def pis(self) -> list[cube_coordinate]: ...
    def pos(self) -> list[cube_coordinate]: ...
    def gates(self) -> list[cube_coordinate]: ...
    def wires(self) -> list[cube_coordinate]: ...
    def fanins(self, t: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> list[int]: ...
    def fanouts(self, t: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> list[int]: ...
    def is_incoming_signal(self, t: cube_coordinate | tuple[int, int] | tuple[int, int, int], s: int) -> bool: ...
    def has_no_incoming_signal(self, t: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def has_northern_incoming_signal(self, t: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def has_north_eastern_incoming_signal(
        self, t: cube_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> bool: ...
    def has_eastern_incoming_signal(self, t: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def has_south_eastern_incoming_signal(
        self, t: cube_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> bool: ...
    def has_southern_incoming_signal(self, t: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def has_south_western_incoming_signal(
        self, t: cube_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> bool: ...
    def has_western_incoming_signal(self, t: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def has_north_western_incoming_signal(
        self, t: cube_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> bool: ...
    def is_outgoing_signal(self, t: cube_coordinate | tuple[int, int] | tuple[int, int, int], s: int) -> bool: ...
    def has_no_outgoing_signal(self, t: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def has_northern_outgoing_signal(self, t: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def has_north_eastern_outgoing_signal(
        self, t: cube_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> bool: ...
    def has_eastern_outgoing_signal(self, t: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def has_south_eastern_outgoing_signal(
        self, t: cube_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> bool: ...
    def has_southern_outgoing_signal(self, t: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def has_south_western_outgoing_signal(
        self, t: cube_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> bool: ...
    def has_western_outgoing_signal(self, t: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def has_north_western_outgoing_signal(
        self, t: cube_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> bool: ...
    def bounding_box_2d(self) -> tuple[cube_coordinate, cube_coordinate]: ...
    def is_dead(self, n: int) -> bool: ...

class cartesian_obstruction_layout(cartesian_gate_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, layout: cartesian_gate_layout) -> None: ...
    def obstruct_coordinate(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> None: ...
    def obstruct_connection(
        self,
        src: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        tgt: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> None: ...
    def is_obstructed_coordinate(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_obstructed_connection(
        self,
        src: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        tgt: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def clear_obstructed_coordinate(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> None: ...
    def clear_obstructed_connection(
        self,
        src: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        tgt: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> None: ...
    def clear_obstructed_coordinates(self) -> None: ...
    def clear_obstructed_connections(self) -> None: ...

class shifted_cartesian_obstruction_layout(shifted_cartesian_gate_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, layout: shifted_cartesian_gate_layout) -> None: ...
    def obstruct_coordinate(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> None: ...
    def obstruct_connection(
        self,
        src: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        tgt: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> None: ...
    def is_obstructed_coordinate(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_obstructed_connection(
        self,
        src: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        tgt: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def clear_obstructed_coordinate(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> None: ...
    def clear_obstructed_connection(
        self,
        src: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        tgt: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> None: ...
    def clear_obstructed_coordinates(self) -> None: ...
    def clear_obstructed_connections(self) -> None: ...

class hexagonal_obstruction_layout(hexagonal_gate_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, layout: hexagonal_gate_layout) -> None: ...
    def obstruct_coordinate(self, c: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> None: ...
    def obstruct_connection(
        self,
        src: cube_coordinate | tuple[int, int] | tuple[int, int, int],
        tgt: cube_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> None: ...
    def is_obstructed_coordinate(self, c: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_obstructed_connection(
        self,
        src: cube_coordinate | tuple[int, int] | tuple[int, int, int],
        tgt: cube_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> bool: ...
    def clear_obstructed_coordinate(self, c: cube_coordinate | tuple[int, int] | tuple[int, int, int]) -> None: ...
    def clear_obstructed_connection(
        self,
        src: cube_coordinate | tuple[int, int] | tuple[int, int, int],
        tgt: cube_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> None: ...
    def clear_obstructed_coordinates(self) -> None: ...
    def clear_obstructed_connections(self) -> None: ...

class qca_technology:
    class cell_type:
        __members__: ClassVar[dict[qca_technology.cell_type, str]]  # readonly

        EMPTY: ClassVar[qca_technology.cell_type]
        NORMAL: ClassVar[qca_technology.cell_type]
        INPUT: ClassVar[qca_technology.cell_type]
        OUTPUT: ClassVar[qca_technology.cell_type]
        CONST_0: ClassVar[qca_technology.cell_type]
        CONST_1: ClassVar[qca_technology.cell_type]

        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        @overload
        def __init__(self, value: int) -> None: ...
        @overload
        def __init__(self, arg0: str) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...

class inml_technology:
    class cell_type:
        __members__: ClassVar[dict[inml_technology.cell_type, str]]  # readonly
        EMPTY: ClassVar[inml_technology.cell_type]
        NORMAL: ClassVar[inml_technology.cell_type]
        INPUT: ClassVar[inml_technology.cell_type]
        OUTPUT: ClassVar[inml_technology.cell_type]
        SLANTED_EDGE_UP_MAGNET: ClassVar[inml_technology.cell_type]
        SLANTED_EDGE_DOWN_MAGNET: ClassVar[inml_technology.cell_type]
        INVERTER_MAGNET: ClassVar[inml_technology.cell_type]
        CROSSWIRE_MAGNET: ClassVar[inml_technology.cell_type]
        FANOUT_COUPLER_MAGNET: ClassVar[inml_technology.cell_type]

        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        @overload
        def __init__(self, value: int) -> None: ...
        @overload
        def __init__(self, arg0: str) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...

class sidb_technology:
    class cell_type:
        __members__: ClassVar[dict[sidb_technology.cell_type, str]]  # readonly

        EMPTY: ClassVar[sidb_technology.cell_type]
        NORMAL: ClassVar[sidb_technology.cell_type]
        INPUT: ClassVar[sidb_technology.cell_type]
        OUTPUT: ClassVar[sidb_technology.cell_type]
        SLANTED_EDGE_UP_MAGNET: ClassVar[sidb_technology.cell_type]
        SLANTED_EDGE_DOWN_MAGNET: ClassVar[sidb_technology.cell_type]
        INVERTER_MAGNET: ClassVar[sidb_technology.cell_type]
        CROSSWIRE_MAGNET: ClassVar[sidb_technology.cell_type]
        FANOUT_COUPLER_MAGNET: ClassVar[sidb_technology.cell_type]

        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        @overload
        def __init__(self, value: int) -> None: ...
        @overload
        def __init__(self, arg0: str) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...

class qca_layout(clocked_cartesian_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> None: ...
    @overload
    def __init__(
        self,
        dimension: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        clocking_scheme: str = "2DDWave",
        layout_name: str = "",
    ) -> None: ...
    def assign_cell_type(
        self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int], ct: qca_technology.cell_type
    ) -> None: ...
    def get_cell_type(
        self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> qca_technology.cell_type: ...
    def is_empty_cell(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def assign_cell_name(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int], n: str) -> None: ...
    def get_cell_name(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> str | None: ...
    def set_layout_name(self, name: str) -> None: ...
    def get_layout_name(self) -> str: ...
    def num_cells(self) -> int: ...
    def is_empty(self) -> bool: ...
    def num_pis(self) -> int: ...
    def num_pos(self) -> int: ...
    def is_pi(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_po(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def cells(self) -> list[offset_coordinate]: ...
    def pis(self) -> list[offset_coordinate]: ...
    def pos(self) -> list[offset_coordinate]: ...
    def bounding_box_2d(self) -> tuple[offset_coordinate, offset_coordinate]: ...

class inml_layout(clocked_cartesian_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> None: ...
    @overload
    def __init__(
        self,
        dimension: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        clocking_scheme: str = "2DDWave",
        layout_name: str = "",
    ) -> None: ...
    def assign_cell_type(
        self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int], ct: inml_technology.cell_type
    ) -> None: ...
    def get_cell_type(
        self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> inml_technology.cell_type: ...
    def is_empty_cell(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def assign_cell_name(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int], n: str) -> None: ...
    def get_cell_name(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> str | None: ...
    def set_layout_name(self, name: str) -> None: ...
    def get_layout_name(self) -> str: ...
    def num_cells(self) -> int: ...
    def is_empty(self) -> bool: ...
    def num_pis(self) -> int: ...
    def num_pos(self) -> int: ...
    def is_pi(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_po(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def cells(self) -> list[offset_coordinate]: ...
    def pis(self) -> list[offset_coordinate]: ...
    def pos(self) -> list[offset_coordinate]: ...
    def bounding_box_2d(self) -> tuple[offset_coordinate, offset_coordinate]: ...

class sidb_layout(clocked_cartesian_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> None: ...
    @overload
    def __init__(
        self,
        dimension: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        clocking_scheme: str = "2DDWave",
        layout_name: str = "",
    ) -> None: ...
    def assign_cell_type(
        self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int], ct: sidb_technology.cell_type
    ) -> None: ...
    def get_cell_type(
        self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> sidb_technology.cell_type: ...
    def is_empty_cell(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def assign_cell_name(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int], n: str) -> None: ...
    def get_cell_name(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> str | None: ...
    def set_layout_name(self, name: str) -> None: ...
    def get_layout_name(self) -> str: ...
    def num_cells(self) -> int: ...
    def is_empty(self) -> bool: ...
    def num_pis(self) -> int: ...
    def num_pos(self) -> int: ...
    def is_pi(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def is_po(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> bool: ...
    def cells(self) -> list[offset_coordinate]: ...
    def pis(self) -> list[offset_coordinate]: ...
    def pos(self) -> list[offset_coordinate]: ...
    def bounding_box_2d(self) -> tuple[offset_coordinate, offset_coordinate]: ...

class sidb_100_lattice(sidb_layout):
    def __init__(
        self, dimension: offset_coordinate | tuple[int, int] | tuple[int, int, int] = ..., name: str = ""
    ) -> None: ...

class sidb_111_lattice(sidb_layout):
    def __init__(
        self, dimension: offset_coordinate | tuple[int, int] | tuple[int, int, int] = ..., name: str = ""
    ) -> None: ...

# Networks

class technology_network_node:
    def __hash__(self) -> int: ...

class technology_network:
    def __init__(self) -> None: ...
    def size(self) -> int: ...
    def num_gates(self) -> int: ...
    def num_pis(self) -> int: ...
    def num_pos(self) -> int: ...
    def nodes(self) -> list[technology_network_node]: ...
    def gates(self) -> list[technology_network_node]: ...
    def pis(self) -> list[technology_network_node]: ...
    def pos(self) -> list[technology_network_node]: ...
    def fanins(self, n: technology_network_node | int) -> list[technology_network_node]: ...
    def is_constant(self, n: technology_network_node | int) -> bool: ...
    def is_pi(self, n: technology_network_node | int) -> bool: ...
    def is_po(self, n: technology_network_node | int) -> bool: ...
    def is_buf(self, n: technology_network_node | int) -> bool: ...
    def is_fanout(self, n: technology_network_node | int) -> bool: ...
    def is_inv(self, n: technology_network_node | int) -> bool: ...
    def is_and(self, n: technology_network_node | int) -> bool: ...
    def is_or(self, n: technology_network_node | int) -> bool: ...
    def is_xor(self, n: technology_network_node | int) -> bool: ...
    def is_maj(self, n: technology_network_node | int) -> bool: ...
    def is_nand(self, n: technology_network_node | int) -> bool: ...
    def is_nor(self, n: technology_network_node | int) -> bool: ...
    def is_xnor(self, n: technology_network_node | int) -> bool: ...
    def has_name(self, n: technology_network_node | int) -> bool: ...
    def get_name(self, n: technology_network_node | int) -> str | None: ...
    def has_output_name(self, index: int) -> bool: ...
    def get_output_name(self, index: int) -> str | None: ...
    def po_index(self, n: technology_network_node | int) -> int: ...
    def po_at(self, index: int) -> technology_network_node: ...

def read_technology_network(filename: str) -> technology_network: ...

class dynamic_truth_table:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, num_vars: int) -> None: ...
    def num_vars(self) -> int: ...
    def num_blocks(self) -> int: ...
    def num_bits(self) -> int: ...

# Algorithms

## network transformation
class substitution_strategy:
    __members__: ClassVar[dict[substitution_strategy, str]]  # readonly
    BREADTH: ClassVar[substitution_strategy]
    DEPTH: ClassVar[substitution_strategy]

    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...

class fanout_substitution_params:
    def __init__(self) -> None: ...

    strategy: substitution_strategy
    degree: int | None
    threshold: int | None

def fanout_substitution(
    network: technology_network, params: fanout_substitution_params | None = ...
) -> technology_network: ...
def is_fanout_substituted(network: technology_network, params: fanout_substitution_params | None = ...) -> bool: ...

class network_balancing_params:
    def __init__(self) -> None: ...

    unify_outputs: bool

def network_balancing(
    network: technology_network, params: network_balancing_params | None = ...
) -> technology_network: ...
def is_balanced(network: technology_network, params: network_balancing_params | None = ...) -> bool: ...

class technology_mapping_params:
    def __init__(self) -> None: ...

    decay: float | None
    inv: bool | None
    and2: bool | None
    nand2: bool | None
    or2: bool | None
    nor2: bool | None
    xor2: bool | None
    xnor2: bool | None
    and3: bool | None
    xor_and: bool | None
    or_and: bool | None
    onehot: bool | None
    maj3: bool | None
    gamble: bool | None
    dot: bool | None
    mux: bool | None
    and_xor: bool | None

class technology_mapping_stats:
    def __init__(self) -> None: ...
    def report(self) -> None: ...

def and_or_not() -> technology_mapping_params: ...
def and_or_not_maj() -> technology_mapping_params: ...
def all_standard_2_input_functions() -> technology_mapping_params: ...
def all_standard_3_input_functions() -> technology_mapping_params: ...
def all_supported_standard_functions() -> technology_mapping_params: ...
def technology_mapping(
    network: technology_network,
    params: technology_mapping_params | None = ...,
    stats: technology_mapping_stats | None = None,
) -> technology_network: ...

## path finding

@overload
def manhattan_distance(
    layout: cartesian_layout | shifted_cartesian_layout,
    source: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    target: offset_coordinate | tuple[int, int] | tuple[int, int, int],
) -> int: ...
@overload
def manhattan_distance(
    layout: hexagonal_layout,
    source: cube_coordinate | tuple[int, int] | tuple[int, int, int],
    target: cube_coordinate | tuple[int, int] | tuple[int, int, int],
) -> int: ...
@overload
def euclidean_distance(
    layout: cartesian_layout | shifted_cartesian_layout,
    source: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    target: offset_coordinate | tuple[int, int] | tuple[int, int, int],
) -> float: ...
@overload
def euclidean_distance(
    layout: hexagonal_layout,
    source: cube_coordinate | tuple[int, int] | tuple[int, int, int],
    target: cube_coordinate | tuple[int, int] | tuple[int, int, int],
) -> float: ...
@overload
def squared_euclidean_distance(
    layout: cartesian_layout | shifted_cartesian_layout,
    source: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    target: offset_coordinate | tuple[int, int] | tuple[int, int, int],
) -> float: ...
@overload
def squared_euclidean_distance(
    layout: hexagonal_layout,
    source: cube_coordinate | tuple[int, int] | tuple[int, int, int],
    target: cube_coordinate | tuple[int, int] | tuple[int, int, int],
) -> float: ...
@overload
def twoddwave_distance(
    layout: cartesian_layout | shifted_cartesian_layout,
    source: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    target: offset_coordinate | tuple[int, int] | tuple[int, int, int],
) -> int: ...
@overload
def twoddwave_distance(
    layout: hexagonal_layout,
    source: cube_coordinate | tuple[int, int] | tuple[int, int, int],
    target: cube_coordinate | tuple[int, int] | tuple[int, int, int],
) -> int: ...
@overload
def chebyshev_distance(
    layout: cartesian_layout | shifted_cartesian_layout,
    source: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    target: offset_coordinate | tuple[int, int] | tuple[int, int, int],
) -> int: ...
@overload
def chebyshev_distance(
    layout: hexagonal_layout,
    source: cube_coordinate | tuple[int, int] | tuple[int, int, int],
    target: cube_coordinate | tuple[int, int] | tuple[int, int, int],
) -> int: ...

class a_star_params:
    def __init__(self) -> None: ...

    crossings: bool

@overload
def a_star(
    layout: cartesian_obstruction_layout
    | cartesian_gate_layout
    | cartesian_layout
    | shifted_cartesian_obstruction_layout
    | shifted_cartesian_gate_layout
    | shifted_cartesian_layout,
    source: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    target: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    params: a_star_params | None = ...,
) -> list[offset_coordinate]: ...
@overload
def a_star(
    layout: hexagonal_obstruction_layout | hexagonal_gate_layout | hexagonal_layout,
    source: cube_coordinate | tuple[int, int] | tuple[int, int, int],
    target: cube_coordinate | tuple[int, int] | tuple[int, int, int],
    params: a_star_params | None = ...,
) -> list[cube_coordinate]: ...
@overload
def a_star_distance(
    layout: cartesian_layout | shifted_cartesian_layout,
    source: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    target: offset_coordinate | tuple[int, int] | tuple[int, int, int],
) -> int: ...
@overload
def a_star_distance(
    layout: hexagonal_layout,
    source: cube_coordinate | tuple[int, int] | tuple[int, int, int],
    target: cube_coordinate | tuple[int, int] | tuple[int, int, int],
) -> int: ...

class enumerate_all_paths_params:
    def __init__(self) -> None: ...

    crossings: bool

@overload
def enumerate_all_paths(
    layout: cartesian_obstruction_layout
    | cartesian_gate_layout
    | cartesian_layout
    | shifted_cartesian_obstruction_layout
    | shifted_cartesian_gate_layout
    | shifted_cartesian_layout,
    source: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    target: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    params: enumerate_all_paths_params | None = ...,
) -> list[list[offset_coordinate]]: ...
@overload
def enumerate_all_paths(
    layout: hexagonal_obstruction_layout | hexagonal_gate_layout | hexagonal_layout,
    source: cube_coordinate | tuple[int, int] | tuple[int, int, int],
    target: cube_coordinate | tuple[int, int] | tuple[int, int, int],
    params: enumerate_all_paths_params | None = ...,
) -> list[list[cube_coordinate]]: ...

class yen_k_shortest_paths_params:
    def __init__(self) -> None: ...

    astar_params: a_star_params

@overload
def yen_k_shortest_paths(
    layout: cartesian_obstruction_layout
    | cartesian_gate_layout
    | cartesian_layout
    | shifted_cartesian_obstruction_layout
    | shifted_cartesian_gate_layout
    | shifted_cartesian_layout,
    source: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    target: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    k: int,
    params: yen_k_shortest_paths_params | None = ...,
) -> list[list[offset_coordinate]]: ...
@overload
def yen_k_shortest_paths(
    layout: hexagonal_obstruction_layout | hexagonal_gate_layout | hexagonal_layout,
    source: cube_coordinate | tuple[int, int] | tuple[int, int, int],
    target: cube_coordinate | tuple[int, int] | tuple[int, int, int],
    k: int,
    params: yen_k_shortest_paths_params | None = ...,
) -> list[list[cube_coordinate]]: ...

# physical design

def apply_qca_one_library(layout: cartesian_gate_layout) -> qca_layout: ...
def apply_topolinano_library(layout: shifted_cartesian_gate_layout) -> inml_layout: ...
def apply_bestagon_library(layout: hexagonal_gate_layout) -> sidb_layout: ...

class graph_coloring_engine:
    __members__: ClassVar[dict[graph_coloring_engine, str]]  # readonly
    MCS: ClassVar[graph_coloring_engine]
    DSATUR: ClassVar[graph_coloring_engine]
    LMXRLF: ClassVar[graph_coloring_engine]
    TABUCOL: ClassVar[graph_coloring_engine]
    SAT: ClassVar[graph_coloring_engine]

    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...

class color_routing_params:
    def __init__(self) -> None: ...

    conduct_partial_routing: bool
    crossings: bool
    path_limit: int | None
    engine: graph_coloring_engine
    partial_sat: bool

@overload
def color_routing(
    layout: cartesian_obstruction_layout
    | cartesian_gate_layout
    | shifted_cartesian_obstruction_layout
    | shifted_cartesian_gate_layout,
    objectives: list[tuple[offset_coordinate, offset_coordinate]],
    params: color_routing_params | None = ...,
) -> bool: ...
@overload
def color_routing(
    layout: hexagonal_obstruction_layout | hexagonal_gate_layout,
    objectives: list[tuple[cube_coordinate, cube_coordinate]],
    params: color_routing_params | None = ...,
) -> bool: ...

class technology_constraints:
    __members__: ClassVar[dict[technology_constraints, str]]  # readonly
    NONE: ClassVar[technology_constraints]
    TOPOLINANO: ClassVar[technology_constraints]
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...

class exact_params:
    def __init__(self) -> None: ...

    scheme: str
    upper_bound_area: int
    upper_bound_x: int
    upper_bound_y: int
    fixed_size: bool
    num_threads: int
    crossings: bool
    border_io: bool
    straight_inverters: bool
    desynchronize: bool
    minimize_wires: bool
    minimize_crossings: bool
    timeout: int
    technology_specifics: technology_constraints

class exact_stats:
    time_total: float
    x_size: int
    y_size: int
    num_gates: int
    num_wires: int
    num_crossings: int
    num_aspect_ratios: int

    def __init__(self) -> None: ...
    def report(self) -> str: ...

def exact_cartesian(
    network: technology_network, parameters: exact_params | None = None, statistics: exact_stats | None = None
) -> cartesian_gate_layout: ...
def exact_shifted_cartesian(
    network: technology_network, parameters: exact_params | None = None, statistics: exact_stats | None = None
) -> shifted_cartesian_gate_layout: ...
def exact_hexagonal(
    network: technology_network, parameters: exact_params | None = None, statistics: exact_stats | None = None
) -> hexagonal_gate_layout: ...

class gold_effort_mode:
    __members__: ClassVar[dict[gold_effort_mode, str]]  # readonly
    HIGH_EFFICIENCY: ClassVar[gold_effort_mode]
    HIGH_EFFORT: ClassVar[gold_effort_mode]
    HIGHEST_EFFORT: ClassVar[gold_effort_mode]

    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...

class gold_cost_objective:
    __members__: ClassVar[dict[gold_cost_objective, str]]  # readonly
    AREA: ClassVar[gold_cost_objective]
    WIRES: ClassVar[gold_cost_objective]
    CROSSINGS: ClassVar[gold_cost_objective]
    ACP: ClassVar[gold_cost_objective]
    CUSTOM: ClassVar[gold_cost_objective]

    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...

class graph_oriented_layout_design_params:
    def __init__(self) -> None: ...

    timeout: int
    num_vertex_expansions: int
    verbose: bool
    mode: gold_effort_mode
    cost: gold_cost_objective
    return_first: bool
    planar: bool
    enable_multithreading: bool

class graph_oriented_layout_design_stats:
    time_total: float
    x_size: int
    y_size: int
    num_gates: int
    num_wires: int
    num_crossings: int

    def __init__(self) -> None: ...
    def report(self) -> str: ...

def graph_oriented_layout_design(
    network: technology_network,
    parameters: graph_oriented_layout_design_params | None = ...,
    statistics: graph_oriented_layout_design_stats | None = None,
) -> cartesian_gate_layout: ...

class hexagonalization_stats:
    time_total: float

    def __init__(self) -> None: ...
    def report(self) -> str: ...

def hexagonalization(
    layout: cartesian_gate_layout, statistics: hexagonalization_stats | None = None
) -> hexagonal_gate_layout: ...

class orthogonal_params:
    def __init__(self) -> None: ...

class orthogonal_stats:
    time_total: float
    x_size: int
    y_size: int
    num_gates: int
    num_wires: int
    num_crossings: int

    def __init__(self) -> None: ...
    def report(self) -> None: ...

def orthogonal(
    network: technology_network, parameters: orthogonal_params | None = ..., statistics: orthogonal_stats | None = None
) -> cartesian_gate_layout: ...

class post_layout_optimization_params:
    def __init__(self) -> None: ...

    timeout: int
    max_gate_relocations: int
    optimize_pos_only: bool
    planar_optimization: bool

class post_layout_optimization_stats:
    time_total: float
    x_size_before: int
    y_size_before: int
    x_size_after: int
    y_size_after: int
    area_improvement: float
    num_wires_before: int
    num_wires_after: int
    num_crossings_before: int
    num_crossings_after: int

    def __init__(self) -> None: ...
    def report(self) -> str: ...

def post_layout_optimization(
    layout: cartesian_gate_layout,
    parameters: post_layout_optimization_params | None = ...,
    statistics: post_layout_optimization_stats | None = None,
) -> cartesian_gate_layout: ...

class wiring_reduction_params:
    def __init__(self) -> None: ...

    timeout: int

class wiring_reduction_stats:
    time_total: float
    x_size_before: int
    y_size_before: int
    x_size_after: int
    y_size_after: int
    num_wires_before: int
    num_wires_after: int
    area_improvement: float
    wiring_improvement: float

    def __init__(self) -> None: ...
    def report(self) -> str: ...

def wiring_reduction(
    layout: cartesian_gate_layout,
    parameters: wiring_reduction_params | None = ...,
    statistics: wiring_reduction_stats | None = None,
) -> cartesian_gate_layout: ...
def clear_routing(
    lyt: cartesian_obstruction_layout
    | cartesian_gate_layout
    | shifted_cartesian_layout
    | shifted_cartesian_gate_layout
    | hexagonal_obstruction_layout
    | hexagonal_gate_layout,
) -> None: ...
def critical_path_length_and_throughput(
    layout: cartesian_gate_layout | shifted_cartesian_gate_layout | hexagonal_gate_layout,
) -> tuple[int, int]: ...

# SidB Logic Design

class design_sidb_gates_stats:
    def __init__(self) -> None: ...

class design_sidb_gates_mode:
    __members__: ClassVar[dict[design_sidb_gates_mode, str]]  # readonly
    QUICKCELL: ClassVar[design_sidb_gates_mode]
    AUTOMATIC_EXHAUSTIVE_GATE_DESIGNER: ClassVar[design_sidb_gates_mode]
    RANDOM: ClassVar[design_sidb_gates_mode]

    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...

class design_sidb_gates_params:
    def __init__(self) -> None: ...

    operational_params: is_operational_params
    design_mode: design_sidb_gates_mode
    canvas: tuple[offset_coordinate, offset_coordinate]
    number_of_sidbs: int

def design_sidb_gates(
    skeleton: sidb_100_lattice | sidb_111_lattice,
    spec: list[dynamic_truth_table],
    params: design_sidb_gates_params = ...,
    stats: design_sidb_gates_stats | None = None,
) -> list[sidb_100_lattice | sidb_111_lattice]: ...

## simulation

### logic

@overload
def simulate(network: technology_network) -> dict[str, list[bool]]: ...
@overload
def simulate(
    layout: cartesian_gate_layout | shifted_cartesian_gate_layout | hexagonal_gate_layout,
) -> dict[str, list[bool]]: ...

## verification

class gate_level_drv_params:
    def __init__(self) -> None: ...

    unplaced_nodes: bool
    placed_dead_nodes: bool
    non_adjacent_connections: bool
    missing_connections: bool
    crossing_gates: bool
    clocked_data_flow: bool
    has_io: bool
    empty_io: bool
    io_pins: bool
    border_io: bool

def gate_level_drvs(
    layout: cartesian_gate_layout | shifted_cartesian_gate_layout | hexagonal_gate_layout,
    params: gate_level_drv_params | None = ...,
    print_report: bool | None = False,
) -> tuple[int, int]: ...

class eq_type:
    __members__: ClassVar[dict[eq_type, str]]  # readonly
    NO: ClassVar[eq_type]
    WEAK: ClassVar[eq_type]
    STRONG: ClassVar[eq_type]

    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...

class equivalence_checking_stats:
    def __init__(self) -> None: ...

    eq: eq_type
    tp_spec: int
    tp_impl: int
    tp_diff: int
    counter_example: list[bool]
    runtime: float

def equivalence_checking(
    specification: technology_network | cartesian_gate_layout | shifted_cartesian_gate_layout | hexagonal_gate_layout,
    implementation: technology_network | cartesian_gate_layout | shifted_cartesian_gate_layout | hexagonal_gate_layout,
    statistics: equivalence_checking_stats | None = None,
) -> eq_type: ...

# In/Out

class fgl_parsing_error(RuntimeError): ...

def read_cartesian_fgl_layout(filename: str, layout_name: str = "") -> cartesian_gate_layout: ...
def read_shifted_cartesian_fgl_layout(filename: str, layout_name: str = "") -> shifted_cartesian_gate_layout: ...
def read_hexagonal_fgl_layout(filename: str, layout_name: str = "") -> hexagonal_gate_layout: ...

class unsupported_character_exception(Exception): ...
class undefined_cell_label_exception(Exception): ...
class unrecognized_cell_definition_exception(Exception): ...

def read_fqca_layout(filename: str, layout_name: str = "") -> qca_layout: ...

class sqd_parsing_error(RuntimeError): ...

def read_sqd_layout_100(filename: str, layout_name: str = "") -> sidb_100_lattice: ...
def read_sqd_layout_111(filename: str, layout_name: str = "") -> sidb_111_lattice: ...
def write_dot_network(network: technology_network, filename: str) -> None: ...
def write_dot_layout(
    layout: cartesian_gate_layout | shifted_cartesian_gate_layout | hexagonal_gate_layout, filename: str
) -> None: ...
def write_fgl_layout(
    layout: cartesian_gate_layout | shifted_cartesian_gate_layout | hexagonal_gate_layout, filename: str
) -> None: ...

class out_of_cell_names_exception(IndexError): ...

class write_fqca_layout_params:
    def __init__(self) -> None: ...

    create_inter_layer_via_cells: bool

def write_fqca_layout(
    layout: cartesian_gate_layout | shifted_cartesian_gate_layout | hexagonal_gate_layout,
    filename: str,
    params: write_fqca_layout_params | None = ...,
) -> None: ...

class sample_writing_mode:
    __members__: ClassVar[dict[sample_writing_mode, str]]  # readonly
    ALL_SAMPLES: ClassVar[sample_writing_mode]
    OPERATIONAL_ONLY: ClassVar[sample_writing_mode]

    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...

class write_operational_domain_params:
    def __init__(self) -> None: ...
    operational_tag: str
    non_operational_tag: str
    writing_mode: sample_writing_mode

def write_operational_domain(
    opdom: operational_domain, filename: str, params: write_operational_domain_params | None = None
) -> None: ...

class color_mode:
    __members__: ClassVar[dict[color_mode, str]]  # readonly
    LIGHT: ClassVar[color_mode]
    DARK: ClassVar[color_mode]

    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...

class sidb_lattice_mode:
    __members__: ClassVar[dict[sidb_lattice_mode, str]]  # readonly
    SHOW_LATTICE: ClassVar[sidb_lattice_mode]
    HIDE_LATTICE: ClassVar[sidb_lattice_mode]

    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...

class write_sidb_layout_svg_params:
    def __init__(self) -> None: ...
    lattice_point_size: float
    sidb_size: float
    sidb_border_width: float
    color_background: str
    color_mode: color_mode
    lattice_mode: sidb_lattice_mode

class write_qca_layout_svg_params:
    def __init__(self) -> None: ...

def write_sidb_layout_svg(
    layout: sidb_100_lattice | sidb_111_lattice | sidb_layout, filename: str, params: write_sidb_layout_svg_params = ...
) -> None: ...
def write_sidb_layout_svg_to_string(
    layout: sidb_100_lattice | sidb_111_lattice | sidb_layout, params: write_sidb_layout_svg_params = ...
) -> str: ...
def write_qca_layout_svg(layout: sidb_layout, filename: str, params: write_sidb_layout_svg_params = ...) -> None: ...

class write_qca_layout_params:
    def __init__(self) -> None: ...

    create_inter_layer_via_cells: bool

def write_qca_layout(layout: qca_layout, filename: str, params: write_qca_layout_params = ...) -> None: ...
def write_qcc_layout(layout: inml_layout, filename: str) -> None: ...
def write_qll_layout(layout: qca_layout | inml_layout, filename: str) -> None: ...
def write_sqd_layout(
    layout: sidb_111_lattice | sidb_100_lattice | sidb_layout,
    filename: str,
) -> None: ...
def write_sqd_sim_result(layout: sidb_layout, filename: str) -> None: ...

# Technology

@overload
def area(layout: qca_layout, width: int = 18, height: int = 18, hspace: int = 2, vspace: int = 2) -> float: ...
@overload
def area(layout: inml_layout, width: int = 50, height: int = 100, hspace: int = 10, vspace: int = 25) -> float: ...
@overload
def area(
    layout: sidb_layout, width: float = 0.0, height: float = 0.0, hspace: float = 0.384, vspace: float = 0.384
) -> float: ...

# SiDB Technology
class input_bdl_configuration:
    __members__: ClassVar[dict[input_bdl_configuration, str]]  # readonly
    PERTURBER_ABSENCE_ENCODED: ClassVar[input_bdl_configuration]
    PERTURBER_DISTANCE_ENCODED: ClassVar[input_bdl_configuration]

    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...

# Class for BDL input iterator parameters
class bdl_input_iterator_params:
    def __init__(self) -> None: ...

    bdl_wire_params: detect_bdl_wires_params
    input_bdl_config: input_bdl_configuration

# Class for BDL input iterator
class bdl_input_iterator_100(Iterable):
    def __init__(self, lyt: sidb_100_lattice, params: bdl_input_iterator_params = ...) -> None: ...
    def __next__(self) -> object: ...
    def __eq__(self, m: object) -> bool: ...
    def __ne__(self, m: object) -> bool: ...
    def __lt__(self, m: int) -> bool: ...
    def __le__(self, m: int) -> bool: ...
    def __gt__(self, m: int) -> bool: ...
    def __ge__(self, m: int) -> bool: ...
    def __add__(self, m: int) -> bdl_input_iterator_100: ...
    def __iadd__(self, m: int) -> Self: ...
    def __sub__(self, m: int) -> bdl_input_iterator_100: ...
    def __isub__(self, m: int) -> Self: ...
    def __getitem__(self, m: int) -> bdl_input_iterator_100: ...
    def num_input_pairs(self) -> int: ...
    def get_layout(self) -> sidb_layout: ...

class bdl_input_iterator_111(Iterable):
    def __init__(self, lyt: sidb_111_lattice, params: bdl_input_iterator_params) -> None: ...
    def __next__(self) -> object: ...
    def __eq__(self, m: object) -> bool: ...
    def __ne__(self, m: object) -> bool: ...
    def __lt__(self, m: int) -> bool: ...
    def __le__(self, m: int) -> bool: ...
    def __gt__(self, m: int) -> bool: ...
    def __ge__(self, m: int) -> bool: ...
    def __add__(self, m: int) -> bdl_input_iterator_111: ...
    def __iadd__(self, m: int) -> Self: ...
    def __sub__(self, m: int) -> bdl_input_iterator_111: ...
    def __isub__(self, m: int) -> Self: ...
    def __getitem__(self, m: int) -> bdl_input_iterator_111: ...
    def num_input_pairs(self) -> int: ...
    def get_layout(self) -> sidb_layout: ...

class bdl_pair:
    def __init__(
        self,
        t: sidb_technology.cell_type,
        u: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        l: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> None: ...
    type: sidb_technology.cell_type
    upper: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    lower: offset_coordinate | tuple[int, int] | tuple[int, int, int]

class detect_bdl_pairs_params:
    def __init__(self) -> None: ...
    minimum_distance: float
    maximum_distance: float

def detect_bdl_pairs(
    lyt: sidb_100_lattice | sidb_111_lattice,
    cell_type: sidb_technology.cell_type | None = None,
    params: detect_bdl_pairs_params = ...,
) -> list[bdl_pair]: ...

class sidb_defect_type:
    __members__: ClassVar[dict[sidb_defect_type, str]]  # readonly
    NONE: ClassVar[sidb_defect_type]
    DB: ClassVar[sidb_defect_type]
    SI_VACANCY: ClassVar[sidb_defect_type]
    SINGLE_DIHYDRIDE: ClassVar[sidb_defect_type]
    DIHYDRIDE_PAIR: ClassVar[sidb_defect_type]
    ONE_BY_ONE: ClassVar[sidb_defect_type]
    THREE_BY_ONE: ClassVar[sidb_defect_type]
    SILOXANE: ClassVar[sidb_defect_type]
    RAISED_SI: ClassVar[sidb_defect_type]
    MISSING_DIMER: ClassVar[sidb_defect_type]
    ETCH_PIT: ClassVar[sidb_defect_type]
    STEP_EDGE: ClassVar[sidb_defect_type]
    GUNK: ClassVar[sidb_defect_type]
    UNKNOWN: ClassVar[sidb_defect_type]

    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...

class sidb_defect:
    def __init__(
        self,
        defect_type: sidb_defect_type = ...,
        electric_charge: int = 0,
        relative_permittivity: float = 0.0,
        screening_distance: float = 0.0,
    ) -> None: ...
    def __eq__(self, rhs: object) -> bool: ...
    def __ne__(self, rhs: object) -> bool: ...

    type: sidb_defect_type
    charge: int
    epsilon_r: float
    lambda_tf: float

def is_charged_defect_type(defect: sidb_defect_type) -> bool: ...
def is_neutral_defect_type(defect: sidb_defect_type) -> bool: ...
def is_positively_charged_defect(defect: sidb_defect_type) -> bool: ...
def is_negatively_charged_defect(defect: sidb_defect_type) -> bool: ...
def is_neutrally_charged_defect(defect: sidb_defect_type) -> bool: ...
def defect_extent(
    defect: sidb_defect_type,
    charged_defect_spacing_overwrite: float | None = None,
    neutral_defect_spacing_overwrite: float | None = None,
) -> float: ...

class sidb_charge_state:
    __members__: ClassVar[dict[sidb_charge_state, str]]  # readonly
    NEGATIVE: ClassVar[sidb_charge_state]
    NEUTRAL: ClassVar[sidb_charge_state]
    POSITIVE: ClassVar[sidb_charge_state]
    NONE: ClassVar[sidb_charge_state]

    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...

def charge_state_to_sign(cs: sidb_charge_state) -> int: ...
def sign_to_charge_state(sg: int) -> sidb_charge_state: ...
def charge_configuration_to_string(charge_distribution: list[sidb_charge_state]) -> str: ...

class dependent_cell_mode:
    __members__: ClassVar[dict[dependent_cell_mode, str]]  # readonly
    FIXED: ClassVar[dependent_cell_mode]
    VARIABLE: ClassVar[dependent_cell_mode]

    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...

class energy_calculation:
    __members__: ClassVar[dict[energy_calculation, str]]  # readonly
    KEEP_OLD_ENERGY_VALUE: ClassVar[energy_calculation]
    UPDATE_ENERGY: ClassVar[energy_calculation]

    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...

class charge_distribution_mode:
    __members__: ClassVar[dict[charge_distribution_mode, str]]  # readonly
    UPDATE_CHARGE_DISTRIBUTION: ClassVar[charge_distribution_mode]
    KEEP_CHARGE_DISTRIBUTION: ClassVar[charge_distribution_mode]

    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...

class charge_index_mode:
    __members__: ClassVar[dict[charge_index_mode, str]]  # readonly
    UPDATE_CHARGE_INDEX: ClassVar[charge_index_mode]
    KEEP_CHARGE_INDEX: ClassVar[charge_index_mode]

    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...

class charge_distribution_history:
    __members__: ClassVar[dict[charge_distribution_history, str]]  # readonly
    CONSIDER: ClassVar[charge_distribution_history]
    NEGLECT: ClassVar[charge_distribution_history]

    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...

class sidb_100_lattice_orientation(Enum):
    LAT_A: float
    LAT_B: float
    LAT_C: tuple[float, float]

class sidb_111_lattice_orientation(Enum):
    LAT_A: float
    LAT_B: float
    LAT_C: tuple[float, float]

class sidb_simulation_parameters:
    def __init__(
        self,
        base_number: int = 3,
        mu_minus: float = -0.32,
        relative_permittivity: float = 5.6,
        screening_distance: float = 5.0,
    ) -> None: ...
    def k(self) -> float: ...
    def mu_plus(self) -> float: ...

    epsilon_r: float
    lambda_tf: float
    mu_minus: float
    base: int

class charge_distribution_surface_100(sidb_100_lattice):
    @overload
    def __init__(self, params: sidb_simulation_parameters = ..., cs: sidb_charge_state = ...) -> None: ...
    @overload
    def __init__(
        self,
        lyt: charge_distribution_surface_100,
        params: sidb_simulation_parameters = ...,
        cs: sidb_charge_state = ...,
    ) -> None: ...
    def get_all_sidb_locations_in_nm(self) -> list[tuple[float, float, float]]: ...
    def assign_cell_type(
        self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int], ct: sidb_technology.cell_type
    ) -> None: ...
    def assign_physical_parameters(self, params: sidb_simulation_parameters) -> None: ...
    def get_phys_params(self) -> sidb_simulation_parameters: ...
    def charge_exists(self, cs: sidb_charge_state) -> bool: ...
    def cell_to_index(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> int: ...
    def assign_charge_state(
        self,
        c: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        cs: sidb_charge_state,
        index_mode: charge_index_mode = ...,
    ) -> None: ...
    def assign_charge_by_cell_index(self, i: int, cs: sidb_charge_state) -> None: ...
    def assign_all_charge_states(self, cs: sidb_charge_state) -> None: ...
    def assign_dependent_cell(
        self, dependent_cell: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> None: ...
    def assign_base_number(self, base: int) -> None: ...
    def add_sidb_defect_to_potential_landscape(self, c: sidb_charge_state, defect: sidb_defect) -> None: ...
    def erase_defect(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> None: ...
    def assign_charge_state_by_cell_index(
        self, index: int, cs: sidb_charge_state, index_mode: charge_index_mode = ...
    ) -> None: ...
    def get_charge_state(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> sidb_charge_state: ...
    def get_charge_state_by_index(self, index: int) -> sidb_charge_state: ...
    def get_all_sidb_charges(self) -> list[sidb_charge_state]: ...
    def negative_sidb_detection(self) -> list[int]: ...
    def get_nm_distance_between_sidbs(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> float: ...
    def get_nm_distance_by_indices(self, index1: int, index2: int) -> float: ...
    def calculate_chargeless_potential_between_sidbs_by_index(self, index1: int, index2: int) -> float: ...
    def calculate_chargeless_potential_between_sidbs(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> float: ...
    def get_chargeless_potential_between_sidbs(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> float: ...
    def get_chargeless_potential_by_indices(self, index1: int, index2: int) -> float: ...
    def get_potential_between_sidbs(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> float: ...
    def update_local_potential(self, consider_history: charge_distribution_history) -> None: ...
    def get_local_potential(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> float: ...
    def get_local_potential_by_index(self, index: int) -> float: ...
    def assign_system_energy_to_zero(self) -> None: ...
    def recompute_system_energy(self) -> None: ...
    def get_system_energy(self) -> float: ...
    def update_after_charge_change(
        self,
        dep_cell: dependent_cell_mode = ...,
        energy_calculation_mode: energy_calculation = ...,
        history_mode: charge_distribution_history = ...,
    ) -> None: ...
    def validity_check(self) -> bool: ...
    def is_physically_valid(self) -> bool: ...
    def charge_distribution_to_index_general(self) -> int: ...
    def charge_distribution_to_index(self) -> int: ...
    def get_charge_index_and_base(self) -> tuple[int, int]: ...
    def increase_charge_index_by_one(
        self,
        dependent_cell_fixed: dependent_cell_mode = ...,
        recompute_system_energy: energy_calculation = ...,
        consider_history: charge_distribution_history = ...,
        engine: exact_sidb_simulation_engine = ...,
    ) -> None: ...
    def get_max_charge_index(self) -> int: ...
    def assign_charge_index(
        self, charge_index: int, cdc: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> None: ...
    def adjacent_search(self, alpha: float, negative_indices: list[int]) -> None: ...
    def assign_global_external_potential(
        self, potential_value: float, dependent_cell: dependent_cell_mode = ...
    ) -> None: ...
    def is_three_state_simulation_required(self) -> bool: ...
    def get_positive_candidates(self) -> list[int]: ...
    def three_state_cell_to_index(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> int: ...
    def two_state_cell_to_index(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> int: ...
    def index_to_cell(self, index: int) -> offset_coordinate: ...
    def index_to_three_state_cell(self, index: int) -> offset_coordinate: ...
    def index_to_two_state_cell(self, index: int) -> offset_coordinate: ...
    def chargeless_potential_at_given_distance(self, distance: float) -> float: ...
    def chargeless_potential_generated_by_defect_at_given_distance(
        self, distance: float, defect: sidb_defect
    ) -> float: ...
    def assign_local_external_potential(self, external_potential: float) -> None: ...
    def get_local_external_potentials(self) -> list[float]: ...
    def get_local_defect_potentials(self) -> list[float]: ...
    def get_defects(self) -> list[sidb_defect]: ...
    def update_charge_state_of_dependent_cell(self) -> None: ...
    def get_charge_index_of_sub_layout(self) -> int: ...
    def charge_index_gray_code_to_charge_distribution(self, new_gray_code: int, old_gray_code: int) -> None: ...
    def increase_charge_index_of_sub_layout_by_one(
        self,
        dependent_cell_fixed: dependent_cell_mode = ...,
        recompute_system_energy: energy_calculation = ...,
        consider_history: charge_distribution_history = ...,
        engine: exact_sidb_simulation_engine = ...,
    ) -> None: ...
    def assign_charge_index_by_gray_code(
        self,
        current_gray_code: int,
        previous_gray_code: int,
        dependent_cell: dependent_cell_mode = ...,
        energy_calc_mode: energy_calculation = ...,
        history_mode: charge_distribution_history = ...,
    ) -> None: ...
    def reset_charge_index_sub_layout(self) -> None: ...
    def get_max_charge_index_sub_layout(self) -> int: ...
    def assign_charge_index_by_two_gray_codes(self, gray_code: int, gray_code_old: int) -> None: ...
    def get_sidb_order(self) -> list[int]: ...
    def add_sidb(self, cell: offset_coordinate | tuple[int, int] | tuple[int, int, int], charge: int) -> None: ...

class charge_distribution_surface_111(sidb_111_lattice):
    @overload
    def __init__(self, params: sidb_simulation_parameters = ..., cs: sidb_charge_state = ...) -> None: ...
    @overload
    def __init__(
        self,
        lyt: sidb_111_lattice,
        params: sidb_simulation_parameters = ...,
        cs: sidb_charge_state = ...,
    ) -> None: ...
    def get_all_sidb_locations_in_nm(self) -> list[tuple[float, float, float]]: ...
    def assign_cell_type(
        self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int], ct: sidb_technology.cell_type
    ) -> None: ...
    def assign_physical_parameters(self, params: sidb_simulation_parameters) -> None: ...
    def get_phys_params(self) -> sidb_simulation_parameters: ...
    def charge_exists(self, cs: sidb_charge_state) -> bool: ...
    def cell_to_index(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> int: ...
    def assign_charge_state(
        self,
        c: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        cs: sidb_charge_state,
        index_mode: charge_index_mode = ...,
    ) -> None: ...
    def assign_charge_by_cell_index(self, i: int, cs: sidb_charge_state) -> None: ...
    def assign_all_charge_states(self, cs: sidb_charge_state) -> None: ...
    def assign_dependent_cell(
        self, dependent_cell: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> None: ...
    def assign_base_number(self, base: int) -> None: ...
    def add_sidb_defect_to_potential_landscape(self, c: sidb_charge_state, defect: sidb_defect) -> None: ...
    def erase_defect(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> None: ...
    def assign_charge_state_by_cell_index(
        self, index: int, cs: sidb_charge_state, index_mode: charge_index_mode = ...
    ) -> None: ...
    def get_charge_state(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> sidb_charge_state: ...
    def get_charge_state_by_index(self, index: int) -> sidb_charge_state: ...
    def get_all_sidb_charges(self) -> list[sidb_charge_state]: ...
    def negative_sidb_detection(self) -> list[int]: ...
    def get_nm_distance_between_sidbs(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> float: ...
    def get_nm_distance_by_indices(self, index1: int, index2: int) -> float: ...
    def calculate_chargeless_potential_between_sidbs_by_index(self, index1: int, index2: int) -> float: ...
    def calculate_chargeless_potential_between_sidbs(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> float: ...
    def get_chargeless_potential_between_sidbs(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> float: ...
    def get_chargeless_potential_by_indices(self, index1: int, index2: int) -> float: ...
    def get_potential_between_sidbs(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> float: ...
    def update_local_potential(self, consider_history: charge_distribution_history) -> None: ...
    def get_local_potential(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> float: ...
    def get_local_potential_by_index(self, index: int) -> float: ...
    def assign_system_energy_to_zero(self) -> None: ...
    def recompute_system_energy(self) -> None: ...
    def get_system_energy(self) -> float: ...
    def update_after_charge_change(
        self,
        dep_cell: dependent_cell_mode = ...,
        energy_calculation_mode: energy_calculation = ...,
        history_mode: charge_distribution_history = ...,
    ) -> None: ...
    def validity_check(self) -> bool: ...
    def is_physically_valid(self) -> bool: ...
    def charge_distribution_to_index_general(self) -> int: ...
    def charge_distribution_to_index(self) -> int: ...
    def get_charge_index_and_base(self) -> tuple[int, int]: ...
    def increase_charge_index_by_one(
        self,
        dependent_cell_fixed: dependent_cell_mode = ...,
        recompute_system_energy: energy_calculation = ...,
        consider_history: charge_distribution_history = ...,
        engine: exact_sidb_simulation_engine = ...,
    ) -> None: ...
    def get_max_charge_index(self) -> int: ...
    def assign_charge_index(
        self, charge_index: int, cdc: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> None: ...
    def adjacent_search(self, alpha: float, negative_indices: list[int]) -> None: ...
    def assign_global_external_potential(
        self, potential_value: float, dependent_cell: dependent_cell_mode = ...
    ) -> None: ...
    def is_three_state_simulation_required(self) -> bool: ...
    def get_positive_candidates(self) -> list[int]: ...
    def three_state_cell_to_index(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> int: ...
    def two_state_cell_to_index(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> int: ...
    def index_to_cell(self, index: int) -> offset_coordinate: ...
    def index_to_three_state_cell(self, index: int) -> offset_coordinate: ...
    def index_to_two_state_cell(self, index: int) -> offset_coordinate: ...
    def chargeless_potential_at_given_distance(self, distance: float) -> float: ...
    def chargeless_potential_generated_by_defect_at_given_distance(
        self, distance: float, defect: sidb_defect
    ) -> float: ...
    def assign_local_external_potential(self, external_potential: float) -> None: ...
    def get_local_external_potentials(self) -> list[float]: ...
    def get_local_defect_potentials(self) -> list[float]: ...
    def get_defects(self) -> list[sidb_defect]: ...
    def update_charge_state_of_dependent_cell(self) -> None: ...
    def get_charge_index_of_sub_layout(self) -> int: ...
    def charge_index_gray_code_to_charge_distribution(self, new_gray_code: int, old_gray_code: int) -> None: ...
    def increase_charge_index_of_sub_layout_by_one(
        self,
        dependent_cell_fixed: dependent_cell_mode = ...,
        recompute_system_energy: energy_calculation = ...,
        consider_history: charge_distribution_history = ...,
        engine: exact_sidb_simulation_engine = ...,
    ) -> None: ...
    def assign_charge_index_by_gray_code(
        self,
        current_gray_code: int,
        previous_gray_code: int,
        dependent_cell: dependent_cell_mode = ...,
        energy_calc_mode: energy_calculation = ...,
        history_mode: charge_distribution_history = ...,
    ) -> None: ...
    def reset_charge_index_sub_layout(self) -> None: ...
    def get_max_charge_index_sub_layout(self) -> int: ...
    def assign_charge_index_by_two_gray_codes(self, gray_code: int, gray_code_old: int) -> None: ...
    def get_sidb_order(self) -> list[int]: ...
    def add_sidb(self, cell: offset_coordinate | tuple[int, int] | tuple[int, int, int], charge: int) -> None: ...

class charge_distribution_surface(sidb_layout):
    @overload
    def __init__(self, params: sidb_simulation_parameters = ..., cs: sidb_charge_state = ...) -> None: ...
    @overload
    def __init__(
        self,
        lyt: sidb_layout,
        params: sidb_simulation_parameters = ...,
        cs: sidb_charge_state = ...,
    ) -> None: ...
    @overload
    def __init__(self, lyt: charge_distribution_surface) -> None: ...
    def get_all_sidb_locations_in_nm(self) -> list[tuple[float, float, float]]: ...
    def assign_cell_type(
        self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int], ct: sidb_technology.cell_type
    ) -> None: ...
    def assign_physical_parameters(self, params: sidb_simulation_parameters) -> None: ...
    def get_phys_params(self) -> sidb_simulation_parameters: ...
    def charge_exists(self, cs: sidb_charge_state) -> bool: ...
    def cell_to_index(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> int: ...
    def assign_charge_state(
        self,
        c: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        cs: sidb_charge_state,
        index_mode: charge_index_mode = ...,
    ) -> None: ...
    def assign_charge_by_cell_index(self, i: int, cs: sidb_charge_state) -> None: ...
    def assign_all_charge_states(self, cs: sidb_charge_state) -> None: ...
    def assign_dependent_cell(
        self, dependent_cell: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> None: ...
    def assign_base_number(self, base: int) -> None: ...
    def add_sidb_defect_to_potential_landscape(self, c: sidb_charge_state, defect: sidb_defect) -> None: ...
    def erase_defect(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> None: ...
    def assign_charge_state_by_cell_index(
        self, index: int, cs: sidb_charge_state, index_mode: charge_index_mode = ...
    ) -> None: ...
    def get_charge_state(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> sidb_charge_state: ...
    def get_charge_state_by_index(self, index: int) -> sidb_charge_state: ...
    def get_all_sidb_charges(self) -> list[sidb_charge_state]: ...
    def negative_sidb_detection(self) -> list[int]: ...
    def get_nm_distance_between_sidbs(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> float: ...
    def get_nm_distance_by_indices(self, index1: int, index2: int) -> float: ...
    def calculate_chargeless_potential_between_sidbs_by_index(self, index1: int, index2: int) -> float: ...
    def calculate_chargeless_potential_between_sidbs(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> float: ...
    def get_chargeless_potential_between_sidbs(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> float: ...
    def get_chargeless_potential_by_indices(self, index1: int, index2: int) -> float: ...
    def get_potential_between_sidbs(
        self,
        c1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
        c2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    ) -> float: ...
    def update_local_potential(self, consider_history: charge_distribution_history) -> None: ...
    def get_local_potential(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> float: ...
    def get_local_potential_by_index(self, index: int) -> float: ...
    def assign_system_energy_to_zero(self) -> None: ...
    def recompute_system_energy(self) -> None: ...
    def get_system_energy(self) -> float: ...
    def update_after_charge_change(
        self,
        dep_cell: dependent_cell_mode = ...,
        energy_calculation_mode: energy_calculation = ...,
        history_mode: charge_distribution_history = ...,
    ) -> None: ...
    def validity_check(self) -> bool: ...
    def is_physically_valid(self) -> bool: ...
    def charge_distribution_to_index_general(self) -> int: ...
    def charge_distribution_to_index(self) -> int: ...
    def get_charge_index_and_base(self) -> tuple[int, int]: ...
    def increase_charge_index_by_one(
        self,
        dependent_cell_fixed: dependent_cell_mode = ...,
        recompute_system_energy: energy_calculation = ...,
        consider_history: charge_distribution_history = ...,
        engine: exact_sidb_simulation_engine = ...,
    ) -> None: ...
    def get_max_charge_index(self) -> int: ...
    def assign_charge_index(
        self, charge_index: int, cdc: offset_coordinate | tuple[int, int] | tuple[int, int, int]
    ) -> None: ...
    def adjacent_search(self, alpha: float, negative_indices: list[int]) -> None: ...
    def assign_global_external_potential(
        self, potential_value: float, dependent_cell: dependent_cell_mode = ...
    ) -> None: ...
    def is_three_state_simulation_required(self) -> bool: ...
    def get_positive_candidates(self) -> list[int]: ...
    def three_state_cell_to_index(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> int: ...
    def two_state_cell_to_index(self, c: offset_coordinate | tuple[int, int] | tuple[int, int, int]) -> int: ...
    def index_to_cell(self, index: int) -> offset_coordinate: ...
    def index_to_three_state_cell(self, index: int) -> offset_coordinate: ...
    def index_to_two_state_cell(self, index: int) -> offset_coordinate: ...
    def chargeless_potential_at_given_distance(self, distance: float) -> float: ...
    def chargeless_potential_generated_by_defect_at_given_distance(
        self, distance: float, defect: sidb_defect
    ) -> float: ...
    def assign_local_external_potential(self, external_potential: float) -> None: ...
    def get_local_external_potentials(self) -> list[float]: ...
    def get_local_defect_potentials(self) -> list[float]: ...
    def get_defects(self) -> list[sidb_defect]: ...
    def update_charge_state_of_dependent_cell(self) -> None: ...
    def get_charge_index_of_sub_layout(self) -> int: ...
    def charge_index_gray_code_to_charge_distribution(self, new_gray_code: int, old_gray_code: int) -> None: ...
    def increase_charge_index_of_sub_layout_by_one(
        self,
        dependent_cell_fixed: dependent_cell_mode = ...,
        recompute_system_energy: energy_calculation = ...,
        consider_history: charge_distribution_history = ...,
        engine: exact_sidb_simulation_engine = ...,
    ) -> None: ...
    def assign_charge_index_by_gray_code(
        self,
        current_gray_code: int,
        previous_gray_code: int,
        dependent_cell: dependent_cell_mode = ...,
        energy_calc_mode: energy_calculation = ...,
        history_mode: charge_distribution_history = ...,
    ) -> None: ...
    def reset_charge_index_sub_layout(self) -> None: ...
    def get_max_charge_index_sub_layout(self) -> int: ...
    def assign_charge_index_by_two_gray_codes(self, gray_code: int, gray_code_old: int) -> None: ...
    def get_sidb_order(self) -> list[int]: ...
    def add_sidb(self, cell: offset_coordinate | tuple[int, int] | tuple[int, int, int], charge: int) -> None: ...

@overload
def exhaustive_ground_state_simulation(
    lyt: sidb_100_lattice, params: sidb_simulation_parameters = ...
) -> sidb_simulation_result_100: ...
@overload
def exhaustive_ground_state_simulation(
    lyt: sidb_111_lattice, params: sidb_simulation_parameters = ...
) -> sidb_simulation_result_111: ...

class sidb_simulation_engine:
    __members__: ClassVar[dict[sidb_simulation_engine, str]]  # readonly
    EXGS: ClassVar[sidb_simulation_engine]
    QUICKSIM: ClassVar[sidb_simulation_engine]
    QUICKEXACT: ClassVar[sidb_simulation_engine]

    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...

class exact_sidb_simulation_engine:
    __members__: ClassVar[dict[exact_sidb_simulation_engine, str]]  # readonly
    EXGS: ClassVar[exact_sidb_simulation_engine]
    QUICKEXACT: ClassVar[exact_sidb_simulation_engine]

    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...

@overload
def sidb_nm_position(
    lyt: charge_distribution_surface | sidb_layout | sidb_100_lattice | sidb_111_lattice,
    c: offset_coordinate | tuple[int, int] | tuple[int, int, int],
) -> tuple[float, float]: ...
def sidb_nm_distance(
    lyt: sidb_100_lattice | sidb_111_lattice,
    source: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    target: offset_coordinate | tuple[int, int] | tuple[int, int, int],
) -> tuple[float, float]: ...

class transition_type:
    __members__: ClassVar[dict[transition_type, str]]  # readonly
    NEUTRAL_TO_NEGATIVE: ClassVar[transition_type]
    NEGATIVE_TO_NEUTRAL: ClassVar[transition_type]
    NEUTRAL_TO_POSITIVE: ClassVar[transition_type]
    POSITIVE_TO_NEUTRAL: ClassVar[transition_type]

    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...

class population_stability_information:
    def __init__(self) -> None: ...

    critical_cell: tuple[int, int]
    transition_from_to: transition_type
    minimum_potential_difference_to_transition: float
    distance_corresponding_to_potential: float
    system_energy: float

class assess_physical_population_stability_params:
    def __init__(self) -> None: ...

    simulation_parameters: sidb_simulation_parameters
    precision_for_distance_corresponding_to_potential: float

def assess_physical_population_stability_100(
    lyt: sidb_100_lattice, params: assess_physical_population_stability_params = ...
) -> list[population_stability_information]: ...
def assess_physical_population_stability_111(
    lyt: sidb_100_lattice, params: assess_physical_population_stability_params = ...
) -> list[population_stability_information]: ...
def energy_distribution(input_vec: list[charge_distribution_surface]) -> dict[float, int]: ...

class bdl_wire_selection:
    __members__: ClassVar[dict[bdl_wire_selection, str]]  # readonly
    ALL: ClassVar[bdl_wire_selection]
    INPUT: ClassVar[bdl_wire_selection]
    OUTPUT: ClassVar[bdl_wire_selection]

    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...

class bdl_wire_100:
    def __init__(self, p: list[bdl_pair]) -> None: ...

    pairs: list[bdl_pair]
    direction: int
    first_bdl_pair: bdl_pair
    last_bdl_pair: bdl_pair

class bdl_wire_111:
    def __init__(self, p: list[bdl_pair]) -> None: ...

    pairs: list[bdl_pair]
    direction: int
    first_bdl_pair: bdl_pair
    last_bdl_pair: bdl_pair

class detect_bdl_wires_params:
    def __init__(self) -> None: ...

    threshold_bdl_interdistance: float
    bdl_pairs_params: detect_bdl_wires_params

def detect_bdl_wires_100(
    lyt: sidb_100_lattice, params: detect_bdl_wires_params = ..., wire_selection: bdl_wire_selection = ...
) -> list[bdl_wire_100]: ...
def detect_bdl_wires_111(
    lyt: sidb_111_lattice, params: detect_bdl_wires_params = ..., wire_selection: bdl_wire_selection = ...
) -> list[bdl_wire_111]: ...

class operational_status:
    __members__: ClassVar[dict[operational_status, str]]  # readonly
    OPERATIONAL: ClassVar[operational_status]
    NON_OPERATIONAL: ClassVar[operational_status]

    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...

class operational_condition:
    __members__: ClassVar[dict[operational_condition, str]]  # readonly
    TOLERATE_KINKS: ClassVar[operational_condition]
    REJECT_KINKS: ClassVar[operational_condition]

    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...

# Class Definitions
class is_operational_params:
    def __init__(self) -> None: ...

    simulation_parameters: sidb_simulation_parameters
    sim_engine: sidb_simulation_engine
    input_bdl_iterator_params: bdl_input_iterator_params
    op_condition: operational_condition

# Functions

@overload
def is_operational(
    lyt: sidb_100_lattice,
    spec: list[dynamic_truth_table],
    params: is_operational_params = ...,
    input_bdl_wire: bdl_wire_100 | None = None,
    output_bdl_wire: bdl_wire_100 | None = None,
) -> operational_status: ...
@overload
def is_operational(
    lyt: sidb_100_lattice,
    spec: list[dynamic_truth_table],
    params: is_operational_params = ...,
    input_bdl_wire: bdl_wire_111 | None = None,
    output_bdl_wire: bdl_wire_111 | None = None,
) -> operational_status: ...
@overload
def operational_input_patterns(
    lyt: sidb_100_lattice,
    spec: list[dynamic_truth_table],
    params: is_operational_params = ...,
) -> list[int]: ...
@overload
def operational_input_patterns(
    lyt: sidb_111_lattice,
    spec: list[dynamic_truth_table],
    params: is_operational_params = ...,
) -> set[int]: ...
@overload
def is_kink_induced_non_operational(
    lyt: sidb_100_lattice,
    spec: list[dynamic_truth_table],
    params: is_operational_params = ...,
    input_bdl_wire: list[bdl_wire_100] | None = None,
    output_bdl_wire: list[bdl_wire_100] | None = None,
) -> operational_status: ...
@overload
def is_kink_induced_non_operational(
    lyt: sidb_111_lattice,
    spec: list[dynamic_truth_table],
    params: is_operational_params = ...,
    input_bdl_wire: list[bdl_wire_111] | None = None,
    output_bdl_wire: list[bdl_wire_111] | None = None,
) -> operational_status: ...
def kink_induced_non_operational_input_patterns(
    lyt: sidb_100_lattice | sidb_111_lattice,
    spec: list[dynamic_truth_table],
    params: is_operational_params = ...,
) -> set[int]: ...

# QuickExact
class quickexact_params:
    def __init__(self) -> None: ...
    simulation_parameters: sidb_simulation_parameters
    base_number_detection: automatic_base_number_detection
    local_external_potential: float
    global_potential: float

class automatic_base_number_detection:
    __members__: ClassVar[dict[automatic_base_number_detection, str]]  # readonly
    ON: ClassVar[automatic_base_number_detection]
    OFF: ClassVar[automatic_base_number_detection]

    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...

def quickexact(lyt: sidb_100_lattice | sidb_111_lattice, params: quickexact_params) -> None: ...

# QuickSim
class quicksim_params:
    def __init__(self) -> None: ...
    simulation_parameters: sidb_simulation_parameters
    iteration_steps: int
    alpha: float
    number_threads: int

def quicksim(lyt: sidb_100_lattice, params: quicksim_params) -> None: ...

class critical_temperature_stats:
    def __init__(self) -> None: ...
    def report(self) -> None: ...

    algorithm_name: str
    num_valid_lyt: int
    is_ground_state_transparent: float

class critical_temperature_params:
    def __init__(self) -> None: ...

    operational_params: dict
    confidence_level: float
    max_temperature: float

def critical_temperature_gate_based(
    lyt: sidb_100_lattice | sidb_111_lattice,
    spec: dict,
    params: critical_temperature_params | None = ...,
    stats: critical_temperature_stats | None = ...,
) -> float | None: ...
def critical_temperature_non_gate_based(
    lyt: sidb_100_lattice | sidb_111_lattice,
    params: critical_temperature_params | None = ...,
    stats: critical_temperature_stats | None = ...,
) -> float | None: ...

class parameter_point:
    def __init__(self, values: list[float] | None = None) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

    parameters: list[float]

class sweep_parameter:
    __members__: ClassVar[dict[sweep_parameter, str]]  # readonly
    EPSILON_R: ClassVar[sweep_parameter]
    LAMBDA_TF: ClassVar[sweep_parameter]
    MU_MINUS: ClassVar[sweep_parameter]

    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...

class operational_domain_value_range:
    def __init__(
        self,
        dimension: sweep_parameter,
        minimum: float | None = None,
        maximum: float | None = None,
        step: float | None = None,
    ) -> None: ...

    dimension: sweep_parameter
    min: float
    max: float
    step: float

class operational_domain_params:
    def __init__(self) -> None: ...

    operational_params: is_operational_params
    sweep_dimensions: list[operational_domain_value_range]

class operational_domain_stats:
    def __init__(self) -> None: ...

    time_total: float
    num_simulator_invocations: int
    num_evaluated_parameter_combinations: int
    num_operational_parameter_combinations: int
    num_non_operational_parameter_combinations: int
    num_total_parameter_points: int

class operational_domain:
    def __init__(self) -> None: ...
    dimensions: list[operational_domain_value_range]
    operational_values: dict[parameter_point, str]
    def get_value(self, point: parameter_point) -> str: ...

def operational_domain_grid_search(
    lyt: sidb_100_lattice | sidb_111_lattice,
    spec: dict,
    params: operational_domain_params | None = None,
    stats: operational_domain_stats | None = None,
) -> operational_domain | None: ...
def operational_domain_random_sampling(
    lyt: sidb_100_lattice | sidb_111_lattice,
    spec: dict,
    samples: int,
    params: operational_domain_params | None = None,
    stats: operational_domain_stats | None = None,
) -> operational_domain | None: ...
def operational_domain_flood_fill(
    lyt: sidb_100_lattice | sidb_111_lattice,
    spec: dict,
    samples: int,
    params: operational_domain_params | None = None,
    stats: operational_domain_stats | None = None,
) -> operational_domain | None: ...
def operational_domain_contour_tracing(
    lyt: sidb_100_lattice | sidb_111_lattice,
    spec: dict,
    samples: int,
    params: operational_domain_params | None = None,
    stats: operational_domain_stats | None = None,
) -> operational_domain | None: ...
@overload
def calculate_energy_and_state_type_with_kinks_accepted(
    energy_distribution: dict[float, int],
    valid_charge_distributions: list[sidb_100_lattice],
    output_bdl_pairs: list[bdl_wire_100],
    spec: list[dynamic_truth_table],
    input_index: int,
) -> None: ...
@overload
def calculate_energy_and_state_type_with_kinks_accepted(
    energy_distribution: dict[float, int],
    valid_charge_distributions: list[sidb_111_lattice],
    output_bdl_pairs: list[bdl_wire_111],
    spec: list[dynamic_truth_table],
    input_index: int,
) -> None: ...
@overload
def calculate_energy_and_state_type_with_kinks_rejected(
    energy_distribution: dict[float, int],
    valid_charge_distributions: list[sidb_100_lattice],
    spec: list[dynamic_truth_table],
    input_index: int,
    input_bdl_wires: list[bdl_wire_100],
    output_bdl_wires: list[bdl_wire_100],
) -> None: ...
@overload
def calculate_energy_and_state_type_with_kinks_rejected(
    energy_distribution: dict[float, int],
    valid_charge_distributions: list[sidb_111_lattice],
    spec: list[dynamic_truth_table],
    input_index: int,
    input_bdl_wires: list[bdl_wire_111],
    output_bdl_wires: list[bdl_wire_111],
) -> None: ...
def can_positive_charges_occur(
    lyt: sidb_100_lattice | sidb_111_lattice,
    sim_params: sidb_simulation_parameters,
) -> bool: ...
@overload
def check_simulation_results_for_equivalence(
    result1: sidb_simulation_result_100,
    result2: sidb_simulation_result_100,
) -> bool: ...
@overload
def check_simulation_results_for_equivalence(
    result1: sidb_simulation_result_111,
    result2: sidb_simulation_result_111,
) -> bool: ...

class sidb_simulation_result_100:
    def __init__(self) -> None: ...
    algorithm_name: str
    simulation_runtime: float
    charge_distributions: list[charge_distribution_surface_100]
    simulation_parameters: sidb_simulation_parameters
    additional_simulation_parameters: dict[str, Any]

class sidb_simulation_result_111:
    def __init__(self) -> None: ...
    algorithm_name: str
    simulation_runtime: float
    charge_distributions: list[charge_distribution_surface_111]
    simulation_parameters: sidb_simulation_parameters
    additional_simulation_parameters: dict[str, Any]

class time_to_solution_params:
    def __init__(self) -> None: ...
    engine: str
    repetitions: int
    confidence_level: float

class time_to_solution_stats:
    def __init__(self) -> None: ...
    time_to_solution: float
    acc: float
    mean_single_runtime: float
    single_runtime_exact: float
    algorithm: str

    def report(self, stream: str | None = None) -> None: ...

def time_to_solution(
    lyt: sidb_100_lattice | sidb_111_lattice,
    quickim_params: quicksim_params,
    tts_params: time_to_solution_params = ...,
    ps: time_to_solution_stats | None = None,
) -> None: ...
@overload
def time_to_solution_for_given_simulation_results(
    results_exact: sidb_simulation_result_100,
    results_heuristic: list[sidb_simulation_result_100],
    confidence_level: float = 0.997,
    ps: time_to_solution_stats | None = None,
) -> None: ...
@overload
def time_to_solution_for_given_simulation_results(
    results_exact: sidb_simulation_result_111,
    results_heuristic: list[sidb_simulation_result_111],
    confidence_level: float = 0.997,
    ps: time_to_solution_stats | None = None,
) -> None: ...
@overload
def is_ground_state(
    heuristic_results: sidb_simulation_result_100,
    exhaustive_results: sidb_simulation_result_100,
) -> bool: ...
@overload
def is_ground_state(
    heuristic_results: sidb_simulation_result_111,
    exhaustive_results: sidb_simulation_result_111,
) -> bool: ...

class displacement_analysis_mode:
    __members__: ClassVar[dict[displacement_analysis_mode, str]]  # readonly
    EXHAUSTIVE: ClassVar[displacement_analysis_mode]
    RANDOM: ClassVar[displacement_analysis_mode]

    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...

class dimer_displacement_policy:
    __members__: ClassVar[dict[dimer_displacement_policy, str]]  # readonly
    STAY_ON_ORIGINAL_DIMER: ClassVar[dimer_displacement_policy]
    ALLOW_OTHER_DIMER: ClassVar[dimer_displacement_policy]

    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...

class displacement_robustness_domain_params:
    def __init__(self) -> None: ...
    analysis_mode: displacement_analysis_mode
    percentage_of_analyzed_displaced_layouts: float
    displacement_variations: int
    operational_params: is_operational_params
    fixed_sidbs: list[siqad_coordinate | offset_coordinate]
    dimer_policy: dimer_displacement_policy

class displacement_robustness_domain_stats:
    def __init__(self) -> None: ...
    time_total: float
    num_operational_sidb_displacements: int
    num_non_operational_sidb_displacements: int

class displacement_robustness_domain_100:
    def __init__(self) -> None: ...

class displacement_robustness_domain_111:
    def __init__(self) -> None: ...

def determine_displacement_robustness_domain_100(
    layout: sidb_100_lattice,
    spec: list[dynamic_truth_table],
    params: displacement_robustness_domain_params,
    stats: displacement_robustness_domain_stats | None = None,
) -> None: ...
def determine_displacement_robustness_domain_111(
    layout: sidb_111_lattice,
    spec: list[dynamic_truth_table],
    params: displacement_robustness_domain_params,
    stats: displacement_robustness_domain_stats | None = None,
) -> None: ...
def occupation_probability_gate_based(energy_and_state_type: list[tuple[float, str]], temperature: float) -> float: ...
def occupation_probability_non_gate_based(energy_distribution: list[float], temperature: float) -> float: ...

class compute_operational_ratio_params:
    def __init__(self) -> None: ...
    op_domain_params: operational_domain_params

def compute_operational_ratio(
    lyt: sidb_100_lattice | sidb_111_lattice,
    spec: list[dynamic_truth_table],
    pp: parameter_point,
    params: compute_operational_ratio_params = ...,
) -> float: ...
@overload
def determine_groundstate_from_simulation_results(
    simulation_results: sidb_simulation_result_100,
) -> list[charge_distribution_surface_100]: ...
@overload
def determine_groundstate_from_simulation_results(
    simulation_results: sidb_simulation_result_111,
) -> list[charge_distribution_surface_111]: ...
@overload
def minimum_energy(layouts: list[charge_distribution_surface_100]) -> float: ...
@overload
def minimum_energy(layouts: list[charge_distribution_surface_111]) -> float: ...

class physically_valid_parameters_domain:
    def __init__(self) -> None: ...
    def get_excited_state_number_for_parameter(self, pp: parameter_point) -> int: ...

@overload
def determine_physically_valid_parameters(
    cds: charge_distribution_surface_100, params: operational_domain_params = ...
) -> physically_valid_parameters_domain: ...
@overload
def determine_physically_valid_parameters(
    cds: charge_distribution_surface_111, params: operational_domain_params = ...
) -> physically_valid_parameters_domain: ...

# Utils

__compiled_date__: str = ...
__compiled_time__: str = ...
__version__: str = ...
__repo__: str = ...

# Functions to create various types of truth tables
def create_id_tt() -> Callable[[int], int]: ...
def create_not_tt() -> Callable[[int], int]: ...
def create_and_tt() -> Callable[[int, int], int]: ...
def create_or_tt() -> Callable[[int, int], int]: ...
def create_nand_tt() -> Callable[[int, int], int]: ...
def create_nor_tt() -> Callable[[int, int], int]: ...
def create_xor_tt() -> Callable[[int, int], int]: ...
def create_xnor_tt() -> Callable[[int, int], int]: ...
def create_lt_tt() -> Callable[[int, int], int]: ...
def create_gt_tt() -> Callable[[int, int], int]: ...
def create_le_tt() -> Callable[[int, int], int]: ...
def create_ge_tt() -> Callable[[int, int], int]: ...
def create_and3_tt() -> Callable[[int, int, int], int]: ...
def create_xor_and_tt() -> Callable[[int, int, int], int]: ...
def create_or_and_tt() -> Callable[[int, int, int], int]: ...
def create_onehot_tt() -> Callable[[int], int]: ...
def create_maj_tt() -> Callable[[int, int, int], int]: ...
def create_gamble_tt() -> Callable[[int, int], int]: ...
def create_dot_tt() -> Callable[[int, int], int]: ...
def create_ite_tt() -> Callable[[int, int, int], int]: ...
def create_and_xor_tt() -> Callable[[int, int, int], int]: ...
def create_xor3_tt() -> Callable[[int, int, int], int]: ...
def create_double_wire_tt() -> Callable[[int, int], int]: ...
def create_crossing_wire_tt() -> Callable[[int, int], int]: ...
def create_fan_out_tt() -> Callable[[int], int]: ...
def create_half_adder_tt() -> Callable[[int, int], int]: ...
@overload
def random_coordinate(
    coordinate1: offset_coordinate | tuple[int, int] | tuple[int, int, int],
    coordinate2: offset_coordinate | tuple[int, int] | tuple[int, int, int],
) -> offset_coordinate: ...
@overload
def random_coordinate(
    coordinate1: cube_coordinate | tuple[int, int] | tuple[int, int, int],
    coordinate2: cube_coordinate | tuple[int, int] | tuple[int, int, int],
) -> cube_coordinate: ...
@overload
def random_coordinate(coordinate1: siqad_coordinate, coordinate2: siqad_coordinate) -> siqad_coordinate: ...
def normalize_layout_coordinates(
    lyt: sidb_100_lattice | sidb_111_lattice | sidb_layout | qca_layout | inml_layout,
) -> None: ...
def convert_potential_to_distance(
    potential: float, params: sidb_simulation_parameters = ..., precision: float = 2
) -> float: ...
