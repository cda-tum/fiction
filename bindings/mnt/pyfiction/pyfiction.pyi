from enum import Enum
from typing import Callable, overload

# Layouts

class offset_coordinate:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, int_repr: int) -> None: ...
    @overload
    def __init__(self, x: int, y: int, z: int) -> None: ...
    @overload
    def __init__(self, c: offset_coordinate) -> None: ...
    @overload
    def __init__(self, c: tuple[int, int, int]) -> None: ...

    x: int
    y: int
    z: int

    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: offset_coordinate) -> bool: ...
    def __gt__(self, other: offset_coordinate) -> bool: ...
    def __le__(self, other: offset_coordinate) -> bool: ...
    def __ge__(self, other: offset_coordinate) -> bool: ...
    def __hash__(self) -> int: ...

class cube_coordinate:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: int, y: int, z: int = 0) -> None: ...
    @overload
    def __init__(self, c: cube_coordinate) -> None: ...
    @overload
    def __init__(self, c: tuple[int, int, int]) -> None: ...

    x: int
    y: int
    z: int

    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: cube_coordinate) -> bool: ...
    def __gt__(self, other: cube_coordinate) -> bool: ...
    def __le__(self, other: cube_coordinate) -> bool: ...
    def __ge__(self, other: cube_coordinate) -> bool: ...
    def __hash__(self) -> int: ...

class siqad_coordinate:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: int, y: int, z: int = 0) -> None: ...
    @overload
    def __init__(self, c: siqad_coordinate) -> None: ...
    @overload
    def __init__(self, c: tuple[int, int, int]) -> None: ...

    x: int
    y: int
    z: int

    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: siqad_coordinate) -> bool: ...
    def __gt__(self, other: siqad_coordinate) -> bool: ...
    def __le__(self, other: siqad_coordinate) -> bool: ...
    def __ge__(self, other: siqad_coordinate) -> bool: ...
    def __hash__(self) -> int: ...

# For consistent behavior:
def area(coord: offset_coordinate | cube_coordinate | siqad_coordinate) -> float: ...
def volume(coord: offset_coordinate | cube_coordinate | siqad_coordinate) -> float: ...

# For conversions with potentially nuanced behavior:
@overload
def to_offset_coord(coord: siqad_coordinate) -> offset_coordinate: ...
@overload
def to_cube_coord(coord: siqad_coordinate) -> cube_coordinate: ...
@overload
def to_siqad_coord(coord: offset_coordinate) -> siqad_coordinate: ...
@overload
def to_siqad_coord(coord: cube_coordinate) -> siqad_coordinate: ...

class cartesian_layout:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate) -> None: ...
    def coord(self, x: int, y: int, z: int = 0) -> offset_coordinate: ...
    def x(self) -> int: ...
    def y(self) -> int: ...
    def z(self) -> int: ...
    def area(self) -> int: ...
    def resize(self, dimension: offset_coordinate) -> None: ...
    def north(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def north_east(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def east(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def south_east(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def south(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def south_west(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def west(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def north_west(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def above(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def below(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def is_north_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_east_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_south_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_west_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_adjacent_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_adjacent_elevation_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_above(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_below(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_northwards_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_eastwards_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_southwards_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_westwards_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_at_northern_border(self, c: offset_coordinate) -> bool: ...
    def is_at_eastern_border(self, c: offset_coordinate) -> bool: ...
    def is_at_southern_border(self, c: offset_coordinate) -> bool: ...
    def is_at_western_border(self, c: offset_coordinate) -> bool: ...
    def is_at_any_border(self, c: offset_coordinate) -> bool: ...
    def northern_border_of(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def eastern_border_of(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def southern_border_of(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def western_border_of(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def is_ground_layer(self, c: offset_coordinate) -> bool: ...
    def is_crossing_layer(self, c: offset_coordinate) -> bool: ...
    def is_within_bounds(self, c: offset_coordinate) -> bool: ...
    def offset_coordinates(self) -> list[offset_coordinate]: ...
    def ground_coordinates(self) -> list[offset_coordinate]: ...
    def adjacent_coordinates(self, c: offset_coordinate) -> list[offset_coordinate]: ...
    def adjacent_opposite_coordinates(self, c: offset_coordinate) -> list[offset_coordinate]: ...

class shifted_cartesian_layout:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate) -> None: ...
    def coord(self, x: int, y: int, z: int = 0) -> offset_coordinate: ...
    def x(self) -> int: ...
    def y(self) -> int: ...
    def z(self) -> int: ...
    def area(self) -> int: ...
    def resize(self, dimension: offset_coordinate) -> None: ...
    def north(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def north_east(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def east(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def south_east(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def south(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def south_west(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def west(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def north_west(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def above(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def below(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def is_north_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_east_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_south_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_west_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_adjacent_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_adjacent_elevation_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_above(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_below(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_northwards_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_eastwards_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_southwards_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_westwards_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_at_northern_border(self, c: offset_coordinate) -> bool: ...
    def is_at_eastern_border(self, c: offset_coordinate) -> bool: ...
    def is_at_southern_border(self, c: offset_coordinate) -> bool: ...
    def is_at_western_border(self, c: offset_coordinate) -> bool: ...
    def is_at_any_border(self, c: offset_coordinate) -> bool: ...
    def northern_border_of(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def eastern_border_of(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def southern_border_of(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def western_border_of(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def is_ground_layer(self, c: offset_coordinate) -> bool: ...
    def is_crossing_layer(self, c: offset_coordinate) -> bool: ...
    def is_within_bounds(self, c: offset_coordinate) -> bool: ...
    def offset_coordinates(self) -> list[offset_coordinate]: ...
    def ground_coordinates(self) -> list[offset_coordinate]: ...
    def adjacent_coordinates(self, c: offset_coordinate) -> list[offset_coordinate]: ...
    def adjacent_opposite_coordinates(self, c: offset_coordinate) -> list[offset_coordinate]: ...

class hexagonal_layout:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: cube_coordinate) -> None: ...
    def coord(self, x: int, y: int, z: int = 0) -> cube_coordinate: ...
    def x(self) -> int: ...
    def y(self) -> int: ...
    def z(self) -> int: ...
    def area(self) -> int: ...
    def resize(self, dimension: cube_coordinate) -> None: ...
    def north(self, c: cube_coordinate) -> cube_coordinate | None: ...
    def north_east(self, c: cube_coordinate) -> cube_coordinate | None: ...
    def east(self, c: cube_coordinate) -> cube_coordinate | None: ...
    def south_east(self, c: cube_coordinate) -> cube_coordinate | None: ...
    def south(self, c: cube_coordinate) -> cube_coordinate | None: ...
    def south_west(self, c: cube_coordinate) -> cube_coordinate | None: ...
    def west(self, c: cube_coordinate) -> cube_coordinate | None: ...
    def north_west(self, c: cube_coordinate) -> cube_coordinate | None: ...
    def above(self, c: cube_coordinate) -> cube_coordinate | None: ...
    def below(self, c: cube_coordinate) -> cube_coordinate | None: ...
    def is_north_of(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...
    def is_east_of(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...
    def is_south_of(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...
    def is_west_of(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...
    def is_adjacent_of(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...
    def is_adjacent_elevation_of(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...
    def is_above(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...
    def is_below(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...
    def is_northwards_of(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...
    def is_eastwards_of(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...
    def is_southwards_of(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...
    def is_westwards_of(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...
    def is_at_northern_border(self, c: cube_coordinate) -> bool: ...
    def is_at_eastern_border(self, c: cube_coordinate) -> bool: ...
    def is_at_southern_border(self, c: cube_coordinate) -> bool: ...
    def is_at_western_border(self, c: cube_coordinate) -> bool: ...
    def is_at_any_border(self, c: cube_coordinate) -> bool: ...
    def northern_border_of(self, c: cube_coordinate) -> cube_coordinate | None: ...
    def eastern_border_of(self, c: cube_coordinate) -> cube_coordinate | None: ...
    def southern_border_of(self, c: cube_coordinate) -> cube_coordinate | None: ...
    def western_border_of(self, c: cube_coordinate) -> cube_coordinate | None: ...
    def is_ground_layer(self, c: cube_coordinate) -> bool: ...
    def is_crossing_layer(self, c: cube_coordinate) -> bool: ...
    def is_within_bounds(self, c: cube_coordinate) -> bool: ...
    def coordinates(self) -> list[cube_coordinate]: ...
    def ground_coordinates(self) -> list[cube_coordinate]: ...
    def adjacent_coordinates(self, c: cube_coordinate) -> list[cube_coordinate]: ...
    def adjacent_opposite_coordinates(self, c: cube_coordinate) -> list[cube_coordinate]: ...

class clocked_cartesian_layout(cartesian_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate, clocking_scheme: str = "2DDWave") -> None: ...
    def assign_clock_number(self, cz: offset_coordinate, cn: int) -> None: ...
    def get_clock_number(self, cz: offset_coordinate) -> int: ...
    def num_clocks(self) -> int: ...
    def is_regularly_clocked(self) -> bool: ...
    def is_clocking_scheme(self, name: str) -> bool: ...
    def is_incoming_clocked(self, cz1: offset_coordinate, cz2: offset_coordinate) -> bool: ...
    def is_outgoing_clocked(self, cz1: offset_coordinate, cz2: offset_coordinate) -> bool: ...
    def incoming_clocked_zones(self, cz: offset_coordinate) -> list[offset_coordinate]: ...
    def outgoing_clocked_zones(self, cz: offset_coordinate) -> list[offset_coordinate]: ...
    def in_degree(self, cz: offset_coordinate) -> int: ...
    def out_degree(self, cz: offset_coordinate) -> int: ...
    def degree(self, cz: offset_coordinate) -> int: ...

class clocked_shifted_cartesian_layout(shifted_cartesian_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate, clocking_scheme: str = "2DDWave") -> None: ...
    def assign_clock_number(self, cz: offset_coordinate, cn: int) -> None: ...
    def get_clock_number(self, cz: offset_coordinate) -> int: ...
    def num_clocks(self) -> int: ...
    def is_regularly_clocked(self) -> bool: ...
    def is_clocking_scheme(self, name: str) -> bool: ...
    def is_incoming_clocked(self, cz1: offset_coordinate, cz2: offset_coordinate) -> bool: ...
    def is_outgoing_clocked(self, cz1: offset_coordinate, cz2: offset_coordinate) -> bool: ...
    def incoming_clocked_zones(self, cz: offset_coordinate) -> list[offset_coordinate]: ...
    def outgoing_clocked_zones(self, cz: offset_coordinate) -> list[offset_coordinate]: ...
    def in_degree(self, cz: offset_coordinate) -> int: ...
    def out_degree(self, cz: offset_coordinate) -> int: ...
    def degree(self, cz: offset_coordinate) -> int: ...

class clocked_hexagonal_layout(hexagonal_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: cube_coordinate) -> None: ...
    @overload
    def __init__(self, dimension: cube_coordinate, clocking_scheme: str = "2DDWave") -> None: ...
    def assign_clock_number(self, cz: cube_coordinate, cn: int) -> None: ...
    def get_clock_number(self, cz: cube_coordinate) -> int: ...
    def num_clocks(self) -> int: ...
    def is_regularly_clocked(self) -> bool: ...
    def is_clocking_scheme(self, name: str) -> bool: ...
    def is_incoming_clocked(self, cz1: cube_coordinate, cz2: cube_coordinate) -> bool: ...
    def is_outgoing_clocked(self, cz1: cube_coordinate, cz2: cube_coordinate) -> bool: ...
    def incoming_clocked_zones(self, cz: cube_coordinate) -> list[cube_coordinate]: ...
    def outgoing_clocked_zones(self, cz: cube_coordinate) -> list[cube_coordinate]: ...
    def in_degree(self, cz: cube_coordinate) -> int: ...
    def out_degree(self, cz: cube_coordinate) -> int: ...
    def degree(self, cz: cube_coordinate) -> int: ...

class cartesian_gate_layout(clocked_cartesian_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate) -> None: ...
    @overload
    def __init__(
        self, dimension: offset_coordinate, clocking_scheme: str = "2DDWave", layout_name: str = ""
    ) -> None: ...
    def create_pi(self, name: str = "", t: offset_coordinate | None = None) -> None: ...
    def create_po(self, s: int, name: str = "", t: offset_coordinate | None = None) -> None: ...
    def is_pi(self, n: int) -> bool: ...
    def is_po(self, n: int) -> bool: ...
    def is_pi_coordinate(self, t: offset_coordinate) -> bool: ...
    def is_po_coordinate(self, t: offset_coordinate) -> bool: ...
    def is_inv(self) -> bool: ...
    def is_and(self) -> bool: ...
    def is_nand(self) -> bool: ...
    def is_or(self) -> bool: ...
    def is_nor(self) -> bool: ...
    def is_xor(self) -> bool: ...
    def is_xnor(self) -> bool: ...
    def is_maj(self) -> bool: ...
    def is_fanout(self) -> bool: ...
    def is_wire(self) -> bool: ...
    def set_layout_name(self, name: str) -> None: ...
    def get_layout_name(self) -> str: ...
    def set_input_name(self, index: int, name: str) -> None: ...
    def get_input_name(self, index: int) -> str: ...
    def set_output_name(self, index: int, name: str) -> None: ...
    def get_output_name(self, index: int) -> str: ...
    def get_name(self, s: int) -> str: ...
    def create_buf(self, a: int, t: offset_coordinate | None = None) -> None: ...
    def create_not(self, a: int, t: offset_coordinate | None = None) -> None: ...
    def create_and(self, a: int, b: int, t: offset_coordinate | None = None) -> None: ...
    def create_nand(self, a: int, b: int, t: offset_coordinate | None = None) -> None: ...
    def create_or(self, a: int, b: int, t: offset_coordinate | None = None) -> None: ...
    def create_nor(self, a: int, b: int, t: offset_coordinate | None = None) -> None: ...
    def create_xor(self, a: int, b: int, t: offset_coordinate | None = None) -> None: ...
    def create_xnor(self, a: int, b: int, t: offset_coordinate | None = None) -> None: ...
    def create_maj(self, a: int, b: int, c: int, t: offset_coordinate | None = None) -> None: ...
    def num_pis(self) -> int: ...
    def num_pos(self) -> int: ...
    def num_gates(self) -> int: ...
    def num_wires(self) -> int: ...
    def num_crossings(self) -> int: ...
    def is_empty(self) -> bool: ...
    def fanin_size(self, n: int) -> int: ...
    def fanout_size(self, n: int) -> int: ...
    def get_int(self, t: offset_coordinate) -> int: ...
    def get_coordinate(self, n: int) -> offset_coordinate: ...
    def make_int(self, n: int) -> int: ...
    def move_int(self, n: int, t: offset_coordinate, new_children: list[offset_coordinate] = []) -> None: ...
    def clear_coordinate(self, t: offset_coordinate) -> None: ...
    def is_gate_coordinate(self, t: offset_coordinate) -> bool: ...
    def is_wire_coordinate(self, t: offset_coordinate) -> bool: ...
    def is_empty_coordinate(self, t: offset_coordinate) -> bool: ...
    def pis(self) -> list[offset_coordinate]: ...
    def pos(self) -> list[offset_coordinate]: ...
    def gates(self) -> list[offset_coordinate]: ...
    def wires(self) -> list[offset_coordinate]: ...
    def fanins(self, t: offset_coordinate) -> list[int]: ...
    def fanouts(self, t: offset_coordinate) -> list[int]: ...
    def is_incoming_int(self, t: offset_coordinate, s: int) -> bool: ...
    def has_no_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_northern_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_north_eastern_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_eastern_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_south_eastern_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_southern_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_south_western_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_western_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_north_western_incoming_int(self, t: offset_coordinate) -> bool: ...
    def is_outgoing_int(self, t: offset_coordinate, s: int) -> bool: ...
    def has_no_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_northern_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_north_eastern_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_eastern_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_south_eastern_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_southern_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_south_western_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_western_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_north_western_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def bounding_box_2d(self) -> tuple[offset_coordinate, offset_coordinate]: ...
    def is_dead(self, n: int) -> bool: ...

class shifted_cartesian_gate_layout(clocked_shifted_cartesian_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate) -> None: ...
    @overload
    def __init__(
        self, dimension: offset_coordinate, clocking_scheme: str = "2DDWave", layout_name: str = ""
    ) -> None: ...
    def create_pi(self, name: str = "", t: offset_coordinate | None = None) -> None: ...
    def create_po(self, s: int, name: str = "", t: offset_coordinate | None = None) -> None: ...
    def is_pi(self, n: int) -> bool: ...
    def is_po(self, n: int) -> bool: ...
    def is_pi_coordinate(self, t: offset_coordinate) -> bool: ...
    def is_po_coordinate(self, t: offset_coordinate) -> bool: ...
    def is_inv(self) -> bool: ...
    def is_and(self) -> bool: ...
    def is_nand(self) -> bool: ...
    def is_or(self) -> bool: ...
    def is_nor(self) -> bool: ...
    def is_xor(self) -> bool: ...
    def is_xnor(self) -> bool: ...
    def is_maj(self) -> bool: ...
    def is_fanout(self) -> bool: ...
    def is_wire(self) -> bool: ...
    def set_layout_name(self, name: str) -> None: ...
    def get_layout_name(self) -> str: ...
    def set_input_name(self, index: int, name: str) -> None: ...
    def get_input_name(self, index: int) -> str: ...
    def set_output_name(self, index: int, name: str) -> None: ...
    def get_output_name(self, index: int) -> str: ...
    def get_name(self, s: int) -> str: ...
    def create_buf(self, a: int, t: offset_coordinate | None = None) -> None: ...
    def create_not(self, a: int, t: offset_coordinate | None = None) -> None: ...
    def create_and(self, a: int, b: int, t: offset_coordinate | None = None) -> None: ...
    def create_nand(self, a: int, b: int, t: offset_coordinate | None = None) -> None: ...
    def create_or(self, a: int, b: int, t: offset_coordinate | None = None) -> None: ...
    def create_nor(self, a: int, b: int, t: offset_coordinate | None = None) -> None: ...
    def create_xor(self, a: int, b: int, t: offset_coordinate | None = None) -> None: ...
    def create_xnor(self, a: int, b: int, t: offset_coordinate | None = None) -> None: ...
    def create_maj(self, a: int, b: int, c: int, t: offset_coordinate | None = None) -> None: ...
    def num_pis(self) -> int: ...
    def num_pos(self) -> int: ...
    def num_gates(self) -> int: ...
    def num_wires(self) -> int: ...
    def num_crossings(self) -> int: ...
    def is_empty(self) -> bool: ...
    def fanin_size(self, n: int) -> int: ...
    def fanout_size(self, n: int) -> int: ...
    def get_int(self, t: offset_coordinate) -> int: ...
    def get_coordinate(self, n: int) -> offset_coordinate: ...
    def make_int(self, n: int) -> int: ...
    def move_int(self, n: int, t: offset_coordinate, new_children: list[offset_coordinate] = []) -> None: ...
    def clear_coordinate(self, t: offset_coordinate) -> None: ...
    def is_gate_coordinate(self, t: offset_coordinate) -> bool: ...
    def is_wire_coordinate(self, t: offset_coordinate) -> bool: ...
    def is_empty_coordinate(self, t: offset_coordinate) -> bool: ...
    def pis(self) -> list[offset_coordinate]: ...
    def pos(self) -> list[offset_coordinate]: ...
    def gates(self) -> list[offset_coordinate]: ...
    def wires(self) -> list[offset_coordinate]: ...
    def fanins(self, t: offset_coordinate) -> list[int]: ...
    def fanouts(self, t: offset_coordinate) -> list[int]: ...
    def is_incoming_int(self, t: offset_coordinate, s: int) -> bool: ...
    def has_no_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_northern_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_north_eastern_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_eastern_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_south_eastern_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_southern_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_south_western_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_western_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_north_western_incoming_int(self, t: offset_coordinate) -> bool: ...
    def is_outgoing_int(self, t: offset_coordinate, s: int) -> bool: ...
    def has_no_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_northern_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_north_eastern_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_eastern_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_south_eastern_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_southern_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_south_western_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_western_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_north_western_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def bounding_box_2d(self) -> tuple[offset_coordinate, offset_coordinate]: ...
    def is_dead(self, n: int) -> bool: ...

class hexagonal_gate_layout(clocked_hexagonal_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: cube_coordinate) -> None: ...
    @overload
    def __init__(self, dimension: cube_coordinate, clocking_scheme: str = "2DDWave", layout_name: str = "") -> None: ...
    def create_pi(self, name: str = "", t: cube_coordinate | None = None) -> None: ...
    def create_po(self, s: int, name: str = "", t: cube_coordinate | None = None) -> None: ...
    def is_pi(self, n: int) -> bool: ...
    def is_po(self, n: int) -> bool: ...
    def is_pi_coordinate(self, t: cube_coordinate) -> bool: ...
    def is_po_coordinate(self, t: cube_coordinate) -> bool: ...
    def is_inv(self) -> bool: ...
    def is_and(self) -> bool: ...
    def is_nand(self) -> bool: ...
    def is_or(self) -> bool: ...
    def is_nor(self) -> bool: ...
    def is_xor(self) -> bool: ...
    def is_xnor(self) -> bool: ...
    def is_maj(self) -> bool: ...
    def is_fanout(self) -> bool: ...
    def is_wire(self) -> bool: ...
    def set_layout_name(self, name: str) -> None: ...
    def get_layout_name(self) -> str: ...
    def set_input_name(self, index: int, name: str) -> None: ...
    def get_input_name(self, index: int) -> str: ...
    def set_output_name(self, index: int, name: str) -> None: ...
    def get_output_name(self, index: int) -> str: ...
    def get_name(self, s: int) -> str: ...
    def create_buf(self, a: int, t: cube_coordinate | None = None) -> None: ...
    def create_not(self, a: int, t: cube_coordinate | None = None) -> None: ...
    def create_and(self, a: int, b: int, t: cube_coordinate | None = None) -> None: ...
    def create_nand(self, a: int, b: int, t: cube_coordinate | None = None) -> None: ...
    def create_or(self, a: int, b: int, t: cube_coordinate | None = None) -> None: ...
    def create_nor(self, a: int, b: int, t: cube_coordinate | None = None) -> None: ...
    def create_xor(self, a: int, b: int, t: cube_coordinate | None = None) -> None: ...
    def create_xnor(self, a: int, b: int, t: cube_coordinate | None = None) -> None: ...
    def create_maj(self, a: int, b: int, c: int, t: cube_coordinate | None = None) -> None: ...
    def num_pis(self) -> int: ...
    def num_pos(self) -> int: ...
    def num_gates(self) -> int: ...
    def num_wires(self) -> int: ...
    def num_crossings(self) -> int: ...
    def is_empty(self) -> bool: ...
    def fanin_size(self, n: int) -> int: ...
    def fanout_size(self, n: int) -> int: ...
    def get_int(self, t: cube_coordinate) -> int: ...
    def get_coordinate(self, n: int) -> cube_coordinate: ...
    def make_int(self, n: int) -> int: ...
    def move_int(self, n: int, t: cube_coordinate, new_children: list[cube_coordinate] = []) -> None: ...
    def clear_coordinate(self, t: cube_coordinate) -> None: ...
    def is_gate_coordinate(self, t: cube_coordinate) -> bool: ...
    def is_wire_coordinate(self, t: cube_coordinate) -> bool: ...
    def is_empty_coordinate(self, t: cube_coordinate) -> bool: ...
    def pis(self) -> list[cube_coordinate]: ...
    def pos(self) -> list[cube_coordinate]: ...
    def gates(self) -> list[cube_coordinate]: ...
    def wires(self) -> list[cube_coordinate]: ...
    def fanins(self, t: cube_coordinate) -> list[int]: ...
    def fanouts(self, t: cube_coordinate) -> list[int]: ...
    def is_incoming_int(self, t: cube_coordinate, s: int) -> bool: ...
    def has_no_incoming_int(self, t: cube_coordinate) -> bool: ...
    def has_northern_incoming_int(self, t: cube_coordinate) -> bool: ...
    def has_north_eastern_incoming_int(self, t: cube_coordinate) -> bool: ...
    def has_eastern_incoming_int(self, t: cube_coordinate) -> bool: ...
    def has_south_eastern_incoming_int(self, t: cube_coordinate) -> bool: ...
    def has_southern_incoming_int(self, t: cube_coordinate) -> bool: ...
    def has_south_western_incoming_int(self, t: cube_coordinate) -> bool: ...
    def has_western_incoming_int(self, t: cube_coordinate) -> bool: ...
    def has_north_western_incoming_int(self, t: cube_coordinate) -> bool: ...
    def is_outgoing_int(self, t: cube_coordinate, s: int) -> bool: ...
    def has_no_outgoing_int(self, t: cube_coordinate) -> bool: ...
    def has_northern_outgoing_int(self, t: cube_coordinate) -> bool: ...
    def has_north_eastern_outgoing_int(self, t: cube_coordinate) -> bool: ...
    def has_eastern_outgoing_int(self, t: cube_coordinate) -> bool: ...
    def has_south_eastern_outgoing_int(self, t: cube_coordinate) -> bool: ...
    def has_southern_outgoing_int(self, t: cube_coordinate) -> bool: ...
    def has_south_western_outgoing_int(self, t: cube_coordinate) -> bool: ...
    def has_western_outgoing_int(self, t: cube_coordinate) -> bool: ...
    def has_north_western_outgoing_int(self, t: cube_coordinate) -> bool: ...
    def bounding_box_2d(self) -> tuple[cube_coordinate, cube_coordinate]: ...
    def is_dead(self, n: int) -> bool: ...

class cartesian_obstruction_layout(cartesian_gate_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, layout: cartesian_gate_layout) -> None: ...
    def obstruct_coordinate(self, c: offset_coordinate) -> None: ...
    def obstruct_connection(self, src: offset_coordinate, tgt: offset_coordinate) -> None: ...
    def is_obstructed_coordinate(self, c: offset_coordinate) -> bool: ...
    def is_obstructed_connection(self, src: offset_coordinate, tgt: offset_coordinate) -> bool: ...
    def clear_obstructed_coordinate(self, c: offset_coordinate) -> None: ...
    def clear_obstructed_connection(self, src: offset_coordinate, tgt: offset_coordinate) -> None: ...
    def clear_obstructed_coordinates(self) -> None: ...
    def clear_obstructed_connections(self) -> None: ...

class shifted_cartesian_obstruction_layout(shifted_cartesian_gate_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, layout: shifted_cartesian_gate_layout) -> None: ...
    def obstruct_coordinate(self, c: offset_coordinate) -> None: ...
    def obstruct_connection(self, src: offset_coordinate, tgt: offset_coordinate) -> None: ...
    def is_obstructed_coordinate(self, c: offset_coordinate) -> bool: ...
    def is_obstructed_connection(self, src: offset_coordinate, tgt: offset_coordinate) -> bool: ...
    def clear_obstructed_coordinate(self, c: offset_coordinate) -> None: ...
    def clear_obstructed_connection(self, src: offset_coordinate, tgt: offset_coordinate) -> None: ...
    def clear_obstructed_coordinates(self) -> None: ...
    def clear_obstructed_connections(self) -> None: ...

class hexagonal_obstruction_layout(hexagonal_gate_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, layout: hexagonal_gate_layout) -> None: ...
    def obstruct_coordinate(self, c: cube_coordinate) -> None: ...
    def obstruct_connection(self, src: cube_coordinate, tgt: cube_coordinate) -> None: ...
    def is_obstructed_coordinate(self, c: cube_coordinate) -> bool: ...
    def is_obstructed_connection(self, src: cube_coordinate, tgt: cube_coordinate) -> bool: ...
    def clear_obstructed_coordinate(self, c: cube_coordinate) -> None: ...
    def clear_obstructed_connection(self, src: cube_coordinate, tgt: cube_coordinate) -> None: ...
    def clear_obstructed_coordinates(self) -> None: ...
    def clear_obstructed_connections(self) -> None: ...

class qca_technology:
    class cell_type(Enum):
        EMPTY = ...
        NORMAL = ...
        INPUT = ...
        OUTPUT = ...
        CONST_0 = ...
        CONST_1 = ...

class inml_technology:
    class cell_type(Enum):
        EMPTY = ...
        NORMAL = ...
        INPUT = ...
        OUTPUT = ...
        SLANTED_EDGE_UP_MAGNET = ...
        SLANTED_EDGE_DOWN_MAGNET = ...
        INVERTER_MAGNET = ...
        CROSSWIRE_MAGNET = ...
        FANOUT_COUPLER_MAGNET = ...

class sidb_technology:
    class cell_type(Enum):
        EMPTY = ...
        NORMAL = ...
        INPUT = ...
        OUTPUT = ...
        LOGIC = ...

class qca_layout(clocked_cartesian_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate) -> None: ...
    @overload
    def __init__(
        self, dimension: offset_coordinate, clocking_scheme: str = "2DDWave", layout_name: str = ""
    ) -> None: ...
    def assign_cell_type(self, c: offset_coordinate, ct: qca_technology.cell_type) -> None: ...
    def get_cell_type(self, c: offset_coordinate) -> qca_technology.cell_type: ...
    def is_empty_cell(self, c: offset_coordinate) -> bool: ...
    def assign_cell_name(self, c: offset_coordinate, n: str) -> None: ...
    def get_cell_name(self, c: offset_coordinate) -> str | None: ...
    def set_layout_name(self, name: str) -> None: ...
    def get_layout_name(self) -> str: ...
    def num_cells(self) -> int: ...
    def is_empty(self) -> bool: ...
    def num_pis(self) -> int: ...
    def num_pos(self) -> int: ...
    def is_pi(self, c: offset_coordinate) -> bool: ...
    def is_po(self, c: offset_coordinate) -> bool: ...
    def cells(self) -> list[offset_coordinate]: ...
    def pis(self) -> list[offset_coordinate]: ...
    def pos(self) -> list[offset_coordinate]: ...
    def bounding_box_2d(self) -> tuple[offset_coordinate, offset_coordinate]: ...

class inml_layout(clocked_cartesian_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate) -> None: ...
    @overload
    def __init__(
        self, dimension: offset_coordinate, clocking_scheme: str = "2DDWave", layout_name: str = ""
    ) -> None: ...
    def assign_cell_type(self, c: offset_coordinate, ct: inml_technology.cell_type) -> None: ...
    def get_cell_type(self, c: offset_coordinate) -> inml_technology.cell_type: ...
    def is_empty_cell(self, c: offset_coordinate) -> bool: ...
    def assign_cell_name(self, c: offset_coordinate, n: str) -> None: ...
    def get_cell_name(self, c: offset_coordinate) -> str | None: ...
    def set_layout_name(self, name: str) -> None: ...
    def get_layout_name(self) -> str: ...
    def num_cells(self) -> int: ...
    def is_empty(self) -> bool: ...
    def num_pis(self) -> int: ...
    def num_pos(self) -> int: ...
    def is_pi(self, c: offset_coordinate) -> bool: ...
    def is_po(self, c: offset_coordinate) -> bool: ...
    def cells(self) -> list[offset_coordinate]: ...
    def pis(self) -> list[offset_coordinate]: ...
    def pos(self) -> list[offset_coordinate]: ...
    def bounding_box_2d(self) -> tuple[offset_coordinate, offset_coordinate]: ...

class sidb_layout(clocked_cartesian_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate) -> None: ...
    @overload
    def __init__(
        self, dimension: offset_coordinate, clocking_scheme: str = "2DDWave", layout_name: str = ""
    ) -> None: ...
    def assign_cell_type(self, c: offset_coordinate, ct: sidb_technology.cell_type) -> None: ...
    def get_cell_type(self, c: offset_coordinate) -> sidb_technology.cell_type: ...
    def is_empty_cell(self, c: offset_coordinate) -> bool: ...
    def assign_cell_name(self, c: offset_coordinate, n: str) -> None: ...
    def get_cell_name(self, c: offset_coordinate) -> str | None: ...
    def set_layout_name(self, name: str) -> None: ...
    def get_layout_name(self) -> str: ...
    def num_cells(self) -> int: ...
    def is_empty(self) -> bool: ...
    def num_pis(self) -> int: ...
    def num_pos(self) -> int: ...
    def is_pi(self, c: offset_coordinate) -> bool: ...
    def is_po(self, c: offset_coordinate) -> bool: ...
    def cells(self) -> list[offset_coordinate]: ...
    def pis(self) -> list[offset_coordinate]: ...
    def pos(self) -> list[offset_coordinate]: ...
    def bounding_box_2d(self) -> tuple[offset_coordinate, offset_coordinate]: ...

class sidb_100_lattice:
    def __init__(self, dimension: offset_coordinate, name: str = "") -> None: ...

class sidb_111_lattice:
    def __init__(self, dimension: offset_coordinate, name: str = "") -> None: ...

# Networks

class technology_network_node:
    def __hash__(self) -> int: ...

class technology_network:
    def __init__(self) -> None: ...
    def size(self) -> int: ...
    def num_gates(self) -> int: ...
    def num_pis(self) -> int: ...
    def num_pos(self) -> int: ...
    def nodes(self) -> list[technology_network_node]: ...
    def gates(self) -> list[technology_network_node]: ...
    def pis(self) -> list[technology_network_node]: ...
    def pos(self) -> list[technology_network_node]: ...
    def fanins(self, n: technology_network_node) -> list[technology_network_node]: ...
    def is_constant(self, n: technology_network_node) -> bool: ...
    def is_pi(self, n: technology_network_node) -> bool: ...
    def is_po(self, n: technology_network_node) -> bool: ...
    def is_buf(self, n: technology_network_node) -> bool: ...
    def is_fanout(self, n: technology_network_node) -> bool: ...
    def is_inv(self, n: technology_network_node) -> bool: ...
    def is_and(self, n: technology_network_node) -> bool: ...
    def is_or(self, n: technology_network_node) -> bool: ...
    def is_xor(self, n: technology_network_node) -> bool: ...
    def is_maj(self, n: technology_network_node) -> bool: ...
    def is_nand(self, n: technology_network_node) -> bool: ...
    def is_nor(self, n: technology_network_node) -> bool: ...
    def is_xnor(self, n: technology_network_node) -> bool: ...
    def has_name(self, n: technology_network_node) -> bool: ...
    def get_name(self, n: technology_network_node) -> str | None: ...
    def has_output_name(self, index: int) -> bool: ...
    def get_output_name(self, index: int) -> str | None: ...
    def po_index(self, n: technology_network_node) -> int: ...
    def po_at(self, index: int) -> technology_network_node: ...

def read_technology_network(filename: str) -> technology_network: ...

class dynamic_truth_table:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, num_vars: int) -> None: ...
    def num_vars(self) -> int: ...
    def num_blocks(self) -> int: ...
    def num_bits(self) -> int: ...

# Algorithms

## network transformation

class substitution_strategy:
    BREADTH: int
    DEPTH: int

class fanout_substitution_params:
    def __init__(self) -> None: ...

    strategy: substitution_strategy
    degree: int | None
    threshold: int | None

def fanout_substitution(
    network: technology_network, params: fanout_substitution_params | None = ...
) -> technology_network: ...
def is_fanout_substituted(network: technology_network, params: fanout_substitution_params | None = ...) -> bool: ...

class network_balancing_params:
    def __init__(self) -> None: ...

    unify_outputs: bool

def network_balancing(
    network: technology_network, params: network_balancing_params | None = ...
) -> technology_network: ...
def is_balanced(network: technology_network, params: network_balancing_params | None = ...) -> bool: ...

class technology_mapping_params:
    def __init__(self) -> None: ...

    decay: float | None
    inv: bool | None
    and2: bool | None
    nand2: bool | None
    or2: bool | None
    nor2: bool | None
    xor2: bool | None
    xnor2: bool | None
    and3: bool | None
    xor_and: bool | None
    or_and: bool | None
    onehot: bool | None
    maj3: bool | None
    gamble: bool | None
    dot: bool | None
    mux: bool | None
    and_xor: bool | None

class technology_mapping_stats:
    def __init__(self) -> None: ...
    def report(self) -> None: ...

def and_or_not() -> technology_mapping_params: ...
def and_or_not_maj() -> technology_mapping_params: ...
def all_standard_2_input_functions() -> technology_mapping_params: ...
def all_standard_3_input_functions() -> technology_mapping_params: ...
def all_supported_standard_functions() -> technology_mapping_params: ...
def technology_mapping(
    network: technology_network,
    params: technology_mapping_params | None = ...,
    stats: technology_mapping_stats | None = None,
) -> technology_network: ...

## path finding

@overload
def manhattan_distance(
    layout: cartesian_layout | shifted_cartesian_layout, source: offset_coordinate, target: offset_coordinate
) -> int: ...
@overload
def manhattan_distance(layout: hexagonal_layout, source: cube_coordinate, target: cube_coordinate) -> int: ...
@overload
def euclidean_distance(
    layout: cartesian_layout | shifted_cartesian_layout, source: offset_coordinate, target: offset_coordinate
) -> float: ...
@overload
def euclidean_distance(layout: hexagonal_layout, source: cube_coordinate, target: cube_coordinate) -> float: ...
@overload
def squared_euclidean_distance(
    layout: cartesian_layout | shifted_cartesian_layout, source: offset_coordinate, target: offset_coordinate
) -> float: ...
@overload
def squared_euclidean_distance(layout: hexagonal_layout, source: cube_coordinate, target: cube_coordinate) -> float: ...
@overload
def twoddwave_distance(
    layout: cartesian_layout | shifted_cartesian_layout, source: offset_coordinate, target: offset_coordinate
) -> int: ...
@overload
def twoddwave_distance(layout: hexagonal_layout, source: cube_coordinate, target: cube_coordinate) -> int: ...
@overload
def chebyshev_distance(
    layout: cartesian_layout | shifted_cartesian_layout, source: offset_coordinate, target: offset_coordinate
) -> int: ...
@overload
def chebyshev_distance(layout: hexagonal_layout, source: cube_coordinate, target: cube_coordinate) -> int: ...

class a_star_params:
    def __init__(self) -> None: ...

    crossings: bool

@overload
def a_star(
    layout: cartesian_obstruction_layout
    | cartesian_gate_layout
    | cartesian_layout
    | shifted_cartesian_obstruction_layout
    | shifted_cartesian_gate_layout
    | shifted_cartesian_layout,
    source: offset_coordinate,
    target: offset_coordinate,
    params: a_star_params | None = ...,
) -> list[offset_coordinate]: ...
@overload
def a_star(
    layout: hexagonal_obstruction_layout | hexagonal_gate_layout | hexagonal_layout,
    source: cube_coordinate,
    target: cube_coordinate,
    params: a_star_params | None = ...,
) -> list[cube_coordinate]: ...

class enumerate_all_paths_params:
    def __init__(self) -> None: ...

    crossings: bool

@overload
def enumerate_all_paths(
    layout: cartesian_obstruction_layout
    | cartesian_gate_layout
    | cartesian_layout
    | shifted_cartesian_obstruction_layout
    | shifted_cartesian_gate_layout
    | shifted_cartesian_layout,
    source: offset_coordinate,
    target: offset_coordinate,
    params: enumerate_all_paths_params | None = ...,
) -> list[list[offset_coordinate]]: ...
@overload
def enumerate_all_paths(
    layout: hexagonal_obstruction_layout | hexagonal_gate_layout | hexagonal_layout,
    source: cube_coordinate,
    target: cube_coordinate,
    params: enumerate_all_paths_params | None = ...,
) -> list[list[cube_coordinate]]: ...

class yen_k_shortest_paths_params:
    def __init__(self) -> None: ...

    astar_params: a_star_params

@overload
def yen_k_shortest_paths(
    layout: cartesian_obstruction_layout
    | cartesian_gate_layout
    | cartesian_layout
    | shifted_cartesian_obstruction_layout
    | shifted_cartesian_gate_layout
    | shifted_cartesian_layout,
    source: offset_coordinate,
    target: offset_coordinate,
    k: int,
    params: yen_k_shortest_paths_params | None = ...,
) -> list[list[offset_coordinate]]: ...
@overload
def yen_k_shortest_paths(
    layout: hexagonal_obstruction_layout | hexagonal_gate_layout | hexagonal_layout,
    source: cube_coordinate,
    target: cube_coordinate,
    k: int,
    params: yen_k_shortest_paths_params | None = ...,
) -> list[list[cube_coordinate]]: ...

# physical design

def apply_qca_one_library(layout: cartesian_gate_layout) -> qca_layout: ...
def apply_topolinano_library(layout: shifted_cartesian_gate_layout) -> inml_layout: ...
def apply_bestagon_library(layout: hexagonal_gate_layout) -> sidb_layout: ...

class graph_coloring_engine(Enum):
    MCS = ...
    DSATUR = ...
    LMXRLF = ...
    TABUCOL = ...
    SAT = ...

class color_routing_params:
    def __init__(self) -> None: ...

    conduct_partial_routing: bool
    crossings: bool
    path_limit: int | None
    engine: graph_coloring_engine
    partial_sat: bool

@overload
def color_routing(
    layout: cartesian_obstruction_layout
    | cartesian_gate_layout
    | shifted_cartesian_obstruction_layout
    | shifted_cartesian_gate_layout,
    objectives: list[tuple[offset_coordinate, offset_coordinate]],
    params: color_routing_params | None = ...,
) -> bool: ...
@overload
def color_routing(
    layout: hexagonal_obstruction_layout | hexagonal_gate_layout,
    objectives: list[tuple[cube_coordinate, cube_coordinate]],
    params: color_routing_params | None = ...,
) -> bool: ...

class technology_constraints(Enum):
    NONE: ...
    TOPOLINANO: ...

class exact_params:
    def __init__(self) -> None: ...

    scheme: str
    upper_bound_area: int
    upper_bound_x: int
    upper_bound_y: int
    fixed_size: bool
    num_threads: int
    crossings: bool
    border_io: bool
    straight_inverters: bool
    desynchronize: bool
    minimize_wires: bool
    minimize_crossings: bool
    timeout: int
    technology_specifics: technology_constraints

class exact_stats:
    time_total: float
    x_size: int
    y_size: int
    num_gates: int
    num_wires: int
    num_crossings: int
    num_aspect_ratios: int

    def __init__(self) -> None: ...
    def report(self) -> str: ...

def exact_cartesian(
    network: technology_network, parameters: exact_params | None = None, statistics: exact_stats | None = None
) -> cartesian_gate_layout: ...
def exact_shifted_cartesian(
    network: technology_network, parameters: exact_params | None = None, statistics: exact_stats | None = None
) -> shifted_cartesian_gate_layout: ...
def exact_hexagonal(
    network: technology_network, parameters: exact_params | None = None, statistics: exact_stats | None = None
) -> hexagonal_gate_layout: ...

class gold_effort_mode(Enum):
    HIGH_EFFICIENCY = ...
    HIGH_EFFORT = ...
    HIGHEST_EFFORT = ...

class gold_cost_objective(Enum):
    AREA = ...
    WIRES = ...
    CROSSINGS = ...
    ACP = ...
    CUSTOM = ...

class graph_oriented_layout_design_params:
    def __init__(self) -> None: ...

    timeout: int
    num_vertex_expansions: int
    verbose: bool
    mode: gold_effort_mode
    cost: gold_cost_objective
    return_first: bool
    planar: bool
    enable_multithreading: bool

class graph_oriented_layout_design_stats:
    time_total: float
    x_size: int
    y_size: int
    num_gates: int
    num_wires: int
    num_crossings: int

    def __init__(self) -> None: ...
    def report(self) -> str: ...

def graph_oriented_layout_design(
    network: technology_network,
    parameters: graph_oriented_layout_design_params | None = ...,
    statistics: graph_oriented_layout_design_stats | None = None,
) -> cartesian_gate_layout: ...

class hexagonalization_stats:
    time_total: float

    def __init__(self) -> None: ...
    def report(self) -> str: ...

def hexagonalization(
    layout: cartesian_gate_layout, statistics: hexagonalization_stats | None = None
) -> hexagonal_gate_layout: ...

class orthogonal_params:
    def __init__(self) -> None: ...

class orthogonal_stats:
    time_total: float
    x_size: int
    y_size: int
    num_gates: int
    num_wires: int
    num_crossings: int

    def __init__(self) -> None: ...
    def report(self) -> None: ...

def orthogonal(
    network: technology_network, parameters: orthogonal_params | None = ..., statistics: orthogonal_stats | None = None
) -> cartesian_gate_layout: ...

class post_layout_optimization_params:
    def __init__(self) -> None: ...

    timeout: int
    max_gate_relocations: int
    optimize_pos_only: bool
    planar_optimization: bool

class post_layout_optimization_stats:
    time_total: float
    x_size_before: int
    y_size_before: int
    x_size_after: int
    y_size_after: int
    area_improvement: float
    num_wires_before: int
    num_wires_after: int
    num_crossings_before: int
    num_crossings_after: int

    def __init__(self) -> None: ...
    def report(self) -> str: ...

def post_layout_optimization(
    layout: cartesian_gate_layout,
    parameters: post_layout_optimization_params | None = ...,
    statistics: post_layout_optimization_stats | None = None,
) -> cartesian_gate_layout: ...

class wiring_reduction_params:
    def __init__(self) -> None: ...

    timeout: int

class wiring_reduction_stats:
    time_total: float
    x_size_before: int
    y_size_before: int
    x_size_after: int
    y_size_after: int
    num_wires_before: int
    num_wires_after: int
    area_improvement: float
    wiring_improvement: float

    def __init__(self) -> None: ...
    def report(self) -> str: ...

def wiring_reduction(
    layout: cartesian_gate_layout,
    parameters: wiring_reduction_params | None = ...,
    statistics: wiring_reduction_stats | None = None,
) -> cartesian_gate_layout: ...

# properties

def critical_path_length_and_throughput(
    layout: cartesian_gate_layout | shifted_cartesian_gate_layout | hexagonal_gate_layout,
) -> tuple[int, int]: ...

# TODO design_sidb_gates

class design_sidb_gates_stats:
    def __init__(self) -> None: ...

class design_sidb_gates_mode(Enum):
    QUICKCELL: ...
    AUTOMATIC_EXHAUSTIVE_GATE_DESIGNER: ...
    RANDOM: ...

class design_sidb_gates_params:
    def __init__(self) -> None: ...

    operational_params: operational_domain_params
    design_mode: design_sidb_gates_mode
    canvas: [offset_coordinate, offset_coordinate]
    number_of_sidbs: int

def design_sidb_gates(
    skeleton: sidb_100_lattice | sidb_111_lattice,
    spec: [[int, int], int],
    params: design_sidb_gates_params = ...,
    stats: design_sidb_gates_stats | None = None,
) -> list[sidb_100_lattice | sidb_111_lattice]: ...

## simulation

### logic

@overload
def simulate(network: technology_network) -> dict[str, list[bool]]: ...
@overload
def simulate(
    layout: cartesian_gate_layout | shifted_cartesian_gate_layout | hexagonal_gate_layout,
) -> dict[str, list[bool]]: ...

### sidb

# TODO all SiDB simulation

## verification

class gate_level_drv_params:
    def __init__(self) -> None: ...

    unplaced_nodes: bool
    placed_dead_nodes: bool
    non_adjacent_connections: bool
    missing_connections: bool
    crossing_gates: bool
    clocked_data_flow: bool
    has_io: bool
    empty_io: bool
    io_pins: bool
    border_io: bool

def gate_level_drvs(
    layout: cartesian_gate_layout | shifted_cartesian_gate_layout | hexagonal_gate_layout,
    params: gate_level_drv_params | None = ...,
    print_report: bool | None = False,
) -> tuple[int, int]: ...

class eq_type(Enum):
    NO = ...
    WEAK = ...
    STRONG = ...

class equivalence_checking_stats:
    def __init__(self) -> None: ...

    eq: eq_type
    tp_spec: int
    tp_impl: int
    tp_diff: int
    counter_example: list[bool]
    runtime: float

def equivalence_checking(
    specification: technology_network | cartesian_gate_layout | shifted_cartesian_gate_layout | hexagonal_gate_layout,
    implementation: technology_network | cartesian_gate_layout | shifted_cartesian_gate_layout | hexagonal_gate_layout,
    statistics: equivalence_checking_stats | None = None,
) -> eq_type: ...

# In/Out

class fgl_parsing_error(RuntimeError): ...

def read_cartesian_fgl_layout(filename: str, layout_name: str = "") -> cartesian_gate_layout: ...
def read_shifted_cartesian_fgl_layout(filename: str, layout_name: str = "") -> shifted_cartesian_gate_layout: ...
def read_hexagonal_fgl_layout(filename: str, layout_name: str = "") -> hexagonal_gate_layout: ...

class unsupported_character_exception(Exception): ...
class undefined_cell_label_exception(Exception): ...
class unrecognized_cell_definition_exception(Exception): ...

def read_fqca_layout(filename: str, layout_name: str = "") -> qca_layout: ...

# TODO read_sqd_layout

def write_dot_network(network: technology_network, filename: str) -> None: ...
def write_dot_layout(
    layout: cartesian_gate_layout | shifted_cartesian_gate_layout | hexagonal_gate_layout, filename: str
) -> None: ...
def write_fgl_layout(
    layout: cartesian_gate_layout | shifted_cartesian_gate_layout | hexagonal_gate_layout, filename: str
) -> None: ...

class out_of_cell_names_exception(IndexError): ...

class write_fqca_layout_params:
    def __init__(self) -> None: ...

    create_inter_layer_via_cells: bool

def write_fqca_layout(
    layout: cartesian_gate_layout | shifted_cartesian_gate_layout | hexagonal_gate_layout,
    filename: str,
    params: write_fqca_layout_params | None = ...,
) -> None: ...

# TODO write_operational_domain

class write_qca_layout_params:
    def __init__(self) -> None: ...

    create_inter_layer_via_cells: bool

def write_qca_layout(layout: qca_layout, filename: str, params: write_qca_layout_params | None = ...) -> None: ...
def write_qcc_layout(layout: inml_layout, filename: str) -> None: ...
def write_qll_layout(layout: qca_layout | inml_layout, filename: str) -> None: ...
def write_sqd_layout(
    layout: sidb_111_lattice | sidb_100_lattice | sidb_layout,
    filename: str,
) -> None: ...
def write_sqd_sim_result(layout: sidb_layout, filename: str) -> None: ...

# Technology

@overload
def area(layout: qca_layout, width: int = 18, height: int = 18, hspace: int = 2, vspace: int = 2) -> float: ...
@overload
def area(layout: inml_layout, width: int = 50, height: int = 100, hspace: int = 10, vspace: int = 25) -> float: ...
@overload
def area(
    layout: sidb_layout, width: float = 0.0, height: float = 0.0, hspace: float = 0.384, vspace: float = 0.384
) -> float: ...

# TODO all SiDB technology

class input_bdl_configuration(Enum):
    PERTURBER_ABSENCE_ENCODED: ...
    PERTURBER_DISTANCE_ENCODED: ...

# Class for BDL input iterator parameters
class bdl_input_iterator_params:
    def __init__(self) -> None: ...

    bdl_wire_params: detect_bdl_wires_params
    input_bdl_config: input_bdl_configuration

# Class for BDL input iterator
class bdl_input_iterator:
    def __init__(self, lyt: object, params: bdl_input_iterator_params) -> None: ...
    def __next__(self) -> object: ...
    def __eq__(self, n: int) -> bool: ...
    def __ne__(self, n: int) -> bool: ...
    def __lt__(self, n: int) -> bool: ...
    def __le__(self, n: int) -> bool: ...
    def __gt__(self, n: int) -> bool: ...
    def __ge__(self, n: int) -> bool: ...
    def __add__(self, n: int) -> bdl_input_iterator: ...
    def __iadd__(self, n: int) -> bdl_input_iterator: ...
    def __sub__(self, n: int) -> bdl_input_iterator: ...
    def __isub__(self, n: int) -> bdl_input_iterator: ...
    def __getitem__(self, n: int) -> bdl_input_iterator: ...
    def num_input_pairs(self) -> int: ...
    def get_layout(self) -> object: ...

# Function to register BDL input iterator for different lattice types
def bdl_input_iterator_100(lyt: object, params: bdl_input_iterator_params) -> bdl_input_iterator: ...
def bdl_input_iterator_111(lyt: object, params: bdl_input_iterator_params) -> bdl_input_iterator: ...

class bdl_pair:
    def __init__(self, t: sidb_technology.cell_type, u: offset_coordinate, l: offset_coordinate) -> None:
        self.type: sidb_technology.cell_type
        self.upper: offset_coordinate
        self.lower: offset_coordinate

class detect_bdl_pairs_params:
    def __init__(self) -> None:
        self.minimum_distance: float
        self.maximum_distance: float

def detect_bdl_pairs(
    lyt: sidb_100_lattice | sidb_111_lattice,
    type: sidb_technology.cell_type | None = None,
    params: detect_bdl_pairs_params = ...,
) -> list[bdl_pair]: ...

class sidb_defect_type(Enum):
    NONE: ...
    DB: ...
    SI_VACANCY: ...
    SINGLE_DIHYDRIDE: ...
    DIHYDRIDE_PAIR: ...
    ONE_BY_ONE: ...
    THREE_BY_ONE: ...
    SILOXANE: ...
    RAISED_SI: ...
    MISSING_DIMER: ...
    ETCH_PIT: ...
    STEP_EDGE: ...
    GUNK: ...
    UNKNOWN: ...

class sidb_defect:
    def __init__(
        self,
        defect_type: sidb_defect_type = ...,
        electric_charge: int = 0,
        relative_permittivity: float = 0.0,
        screening_distance: float = 0.0,
    ) -> None:
        def __eq__(self, rhs: sidb_defect) -> bool: ...
        def __ne__(self, rhs: sidb_defect) -> bool: ...

    type: sidb_defect_type
    charge: int
    epsilon_r: float
    lambda_tf: float

def is_charged_defect_type(defect: sidb_defect_type) -> bool: ...
def is_neutral_defect_type(defect: sidb_defect_type) -> bool: ...
def is_positively_charged_defect(defect: sidb_defect_type) -> bool: ...
def is_negatively_charged_defect(defect: sidb_defect_type) -> bool: ...
def is_neutrally_charged_defect(defect: sidb_defect_type) -> bool: ...
def defect_extent(
    defect: sidb_defect_type,
    charged_defect_spacing_overwrite: float | None = None,
    neutral_defect_spacing_overwrite: float | None = None,
) -> float: ...

class sidb_charge_state(Enum):
    NEGATIVE: int = -1
    NEUTRAL: int = 0
    POSITIVE: int = 1
    NONE: int = 127

def charge_state_to_sign(cs: sidb_charge_state) -> int: ...
def sign_to_charge_state(sg: int) -> sidb_charge_state: ...
def charge_configuration_to_string(charge_distribution: list[sidb_charge_state]) -> str: ...

class dependent_cell_mode(Enum):
    FIXED: ...
    VARIABLE: ...

class energy_calculation(Enum):
    KEEP_OLD_ENERGY_VALUE: ...
    UPDATE_ENERGY: ...

class charge_distribution_mode(Enum):
    UPDATE_CHARGE_DISTRIBUTION: ...
    KEEP_CHARGE_DISTRIBUTION: ...

class charge_index_mode(Enum):
    UPDATE_CHARGE_INDEX: ...
    KEEP_CHARGE_INDEX: ...

class charge_distribution_history(Enum):
    CONSIDER: ...
    NEGLECT: ...

class sidb_100_lattice_orientation(Enum):
    LAT_A: float
    LAT_B: float
    LAT_C: tuple[float, float]

class sidb_111_lattice_orientation(Enum):
    LAT_A: float
    LAT_B: float
    LAT_C: tuple[float, float]

class charge_distribution_surface_100(sidb_100_lattice):
    def __init__(self, params: sidb_simulation_parameters = ..., cs: sidb_charge_state = ...) -> None: ...
    @overload
    def __init__(
        self,
        lyt: charge_distribution_surface_100,
        params: sidb_simulation_parameters = ...,
        cs: sidb_charge_state = ...,
    ) -> None: ...
    @overload
    def __init__(self, lyt: charge_distribution_surface_100) -> None: ...
    def get_all_sidb_locations_in_nm(self) -> list[tuple[float, float, float]]: ...
    def assign_cell_type(self, c: sidb_technology.cell_type, ct: int) -> None: ...
    def assign_physical_parameters(self, params: sidb_simulation_parameters) -> None: ...
    def get_phys_params(self) -> sidb_simulation_parameters: ...
    def charge_exists(self, cs: sidb_charge_state) -> bool: ...
    def cell_to_index(self, c: offset_coordinate) -> int: ...
    def assign_charge_state(
        self, c: offset_coordinate, cs: sidb_charge_state, index_mode: charge_index_mode = ...
    ) -> None: ...
    def assign_charge_by_cell_index(self, i: int, cs: sidb_charge_state) -> None: ...
    def assign_all_charge_states(self, cs: sidb_charge_state) -> None: ...
    def assign_dependent_cell(self, dependent_cell: offset_coordinate) -> None: ...
    def assign_base_number(self, base: int) -> None: ...
    def add_sidb_defect_to_potential_landscape(self, c: sidb_charge_state, defect: sidb_defect) -> None: ...
    def erase_defect(self, c: offset_coordinate) -> None: ...
    def assign_charge_state_by_cell_index(
        self, index: int, cs: sidb_charge_state, index_mode: charge_index_mode = ...
    ) -> None: ...
    def get_charge_state(self, c: offset_coordinate) -> sidb_charge_state: ...
    def get_charge_state_by_index(self, index: int) -> sidb_charge_state: ...
    def get_all_sidb_charges(self) -> list[sidb_charge_state]: ...
    def negative_sidb_detection(self) -> list[int]: ...
    def get_nm_distance_between_sidbs(self, c1: offset_coordinate, c2: offset_coordinate) -> float: ...
    def get_nm_distance_by_indices(self, index1: int, index2: int) -> float: ...
    def calculate_chargeless_potential_between_sidbs_by_index(self, index1: int, index2: int) -> float: ...
    def calculate_chargeless_potential_between_sidbs(self, c1: offset_coordinate, c2: offset_coordinate) -> float: ...
    def get_chargeless_potential_between_sidbs(self, c1: offset_coordinate, c2: offset_coordinate) -> float: ...
    def get_chargeless_potential_by_indices(self, index1: int, index2: int) -> float: ...
    def get_potential_between_sidbs(self, c1: offset_coordinate, c2: offset_coordinate) -> float: ...
    def update_local_potential(self, consider_history: charge_distribution_history) -> None: ...
    def get_local_potential(self, c: offset_coordinate) -> float: ...
    def get_local_potential_by_index(self, index: int) -> float: ...
    def assign_system_energy_to_zero(self) -> None: ...
    def recompute_system_energy(self) -> None: ...
    def get_system_energy(self) -> float: ...
    def update_after_charge_change(
        self,
        dep_cell: dependent_cell_mode = ...,
        energy_calculation_mode: energy_calculation = ...,
        history_mode: charge_distribution_history = ...,
    ) -> None: ...
    def validity_check(self) -> bool: ...
    def is_physically_valid(self) -> bool: ...
    def charge_distribution_to_index_general(self) -> int: ...
    def charge_distribution_to_index(self) -> int: ...
    def get_charge_index_and_base(self) -> tuple[int, int]: ...
    def increase_charge_index_by_one(
        self,
        dependent_cell_fixed: dependent_cell_mode = ...,
        recompute_system_energy: energy_calculation = ...,
        consider_history: charge_distribution_history = ...,
        engine: exact_sidb_simulation_engine = ...,
    ) -> None: ...
    def get_max_charge_index(self) -> int: ...
    def assign_charge_index(self, charge_index: int, cdc: offset_coordinate) -> None: ...
    def adjacent_search(self, alpha: float, negative_indices: list[int]) -> None: ...
    def assign_global_external_potential(
        self, potential_value: float, dependent_cell: dependent_cell_mode = ...
    ) -> None: ...
    def is_three_state_simulation_required(self) -> bool: ...
    def get_positive_candidates(self) -> list[int]: ...
    def three_state_cell_to_index(self, c: offset_coordinate) -> int: ...
    def two_state_cell_to_index(self, c: offset_coordinate) -> int: ...
    def index_to_cell(self, index: int) -> offset_coordinate: ...
    def index_to_three_state_cell(self, index: int) -> offset_coordinate: ...
    def index_to_two_state_cell(self, index: int) -> offset_coordinate: ...
    def chargeless_potential_at_given_distance(self, distance: float) -> float: ...
    def chargeless_potential_generated_by_defect_at_given_distance(
        self, distance: float, defect: sidb_defect
    ) -> float: ...
    def assign_local_external_potential(self, external_potential: float) -> None: ...
    def get_local_external_potentials(self) -> list[float]: ...
    def get_local_defect_potentials(self) -> list[float]: ...
    def get_defects(self) -> list[sidb_defect]: ...
    def update_charge_state_of_dependent_cell(self) -> None: ...
    def get_charge_index_of_sub_layout(self) -> int: ...
    def charge_index_gray_code_to_charge_distribution(self, new_gray_code: int, old_gray_code: int) -> None: ...
    def increase_charge_index_of_sub_layout_by_one(
        self,
        dependent_cell_fixed: dependent_cell_mode = ...,
        recompute_system_energy: energy_calculation = ...,
        consider_history: charge_distribution_history = ...,
        engine: exact_sidb_simulation_engine = ...,
    ) -> None: ...
    def assign_charge_index_by_gray_code(
        self,
        current_gray_code: int,
        previous_gray_code: int,
        dependent_cell: dependent_cell_mode = ...,
        energy_calc_mode: energy_calculation = ...,
        history_mode: charge_distribution_history = ...,
    ) -> None: ...
    def reset_charge_index_sub_layout(self) -> None: ...
    def get_max_charge_index_sub_layout(self) -> int: ...
    def assign_charge_index_by_two_gray_codes(self, gray_code: int, gray_code_old: int) -> None: ...
    def get_sidb_order(self) -> list[int]: ...
    def add_sidb(self, cell: offset_coordinate, charge: int) -> None: ...
    def cells(self) -> list[tuple[int, int, int]]: ...
    def pis(self) -> list[tuple[int, int, int]]: ...
    def pos(self) -> list[tuple[int, int, int]]: ...
    def is_within_bounds(self, c: tuple[int, int, int]) -> bool: ...
    def bounding_box_2d(self) -> tuple[tuple[int, int], tuple[int, int]]: ...

class charge_distribution_surface_111(sidb_111_lattice):
    def __init__(self, params: sidb_simulation_parameters = ..., cs: sidb_charge_state = ...) -> None: ...
    @overload
    def __init__(
        self,
        lyt: charge_distribution_surface_100,
        params: sidb_simulation_parameters = ...,
        cs: sidb_charge_state = ...,
    ) -> None: ...
    @overload
    def __init__(self, lyt: charge_distribution_surface_100) -> None: ...
    def get_all_sidb_locations_in_nm(self) -> list[tuple[float, float, float]]: ...
    def assign_cell_type(self, c: sidb_technology.cell_type, ct: int) -> None: ...
    def assign_physical_parameters(self, params: sidb_simulation_parameters) -> None: ...
    def get_phys_params(self) -> sidb_simulation_parameters: ...
    def charge_exists(self, cs: sidb_charge_state) -> bool: ...
    def cell_to_index(self, c: offset_coordinate) -> int: ...
    def assign_charge_state(
        self, c: offset_coordinate, cs: sidb_charge_state, index_mode: charge_index_mode = ...
    ) -> None: ...
    def assign_charge_by_cell_index(self, i: int, cs: sidb_charge_state) -> None: ...
    def assign_all_charge_states(self, cs: sidb_charge_state) -> None: ...
    def assign_dependent_cell(self, dependent_cell: offset_coordinate) -> None: ...
    def assign_base_number(self, base: int) -> None: ...
    def add_sidb_defect_to_potential_landscape(self, c: sidb_charge_state, defect: sidb_defect) -> None: ...
    def erase_defect(self, c: offset_coordinate) -> None: ...
    def assign_charge_state_by_cell_index(
        self, index: int, cs: sidb_charge_state, index_mode: charge_index_mode = ...
    ) -> None: ...
    def get_charge_state(self, c: offset_coordinate) -> sidb_charge_state: ...
    def get_charge_state_by_index(self, index: int) -> sidb_charge_state: ...
    def get_all_sidb_charges(self) -> list[sidb_charge_state]: ...
    def negative_sidb_detection(self) -> list[int]: ...
    def get_nm_distance_between_sidbs(self, c1: offset_coordinate, c2: offset_coordinate) -> float: ...
    def get_nm_distance_by_indices(self, index1: int, index2: int) -> float: ...
    def calculate_chargeless_potential_between_sidbs_by_index(self, index1: int, index2: int) -> float: ...
    def calculate_chargeless_potential_between_sidbs(self, c1: offset_coordinate, c2: offset_coordinate) -> float: ...
    def get_chargeless_potential_between_sidbs(self, c1: offset_coordinate, c2: offset_coordinate) -> float: ...
    def get_chargeless_potential_by_indices(self, index1: int, index2: int) -> float: ...
    def get_potential_between_sidbs(self, c1: offset_coordinate, c2: offset_coordinate) -> float: ...
    def update_local_potential(self, consider_history: charge_distribution_history) -> None: ...
    def get_local_potential(self, c: offset_coordinate) -> float: ...
    def get_local_potential_by_index(self, index: int) -> float: ...
    def assign_system_energy_to_zero(self) -> None: ...
    def recompute_system_energy(self) -> None: ...
    def get_system_energy(self) -> float: ...
    def update_after_charge_change(
        self,
        dep_cell: dependent_cell_mode = ...,
        energy_calculation_mode: energy_calculation = ...,
        history_mode: charge_distribution_history = ...,
    ) -> None: ...
    def validity_check(self) -> bool: ...
    def is_physically_valid(self) -> bool: ...
    def charge_distribution_to_index_general(self) -> int: ...
    def charge_distribution_to_index(self) -> int: ...
    def get_charge_index_and_base(self) -> tuple[int, int]: ...
    def increase_charge_index_by_one(
        self,
        dependent_cell_fixed: dependent_cell_mode = ...,
        recompute_system_energy: energy_calculation = ...,
        consider_history: charge_distribution_history = ...,
        engine: exact_sidb_simulation_engine = ...,
    ) -> None: ...
    def get_max_charge_index(self) -> int: ...
    def assign_charge_index(self, charge_index: int, cdc: offset_coordinate) -> None: ...
    def adjacent_search(self, alpha: float, negative_indices: list[int]) -> None: ...
    def assign_global_external_potential(
        self, potential_value: float, dependent_cell: dependent_cell_mode = ...
    ) -> None: ...
    def is_three_state_simulation_required(self) -> bool: ...
    def get_positive_candidates(self) -> list[int]: ...
    def three_state_cell_to_index(self, c: offset_coordinate) -> int: ...
    def two_state_cell_to_index(self, c: offset_coordinate) -> int: ...
    def index_to_cell(self, index: int) -> offset_coordinate: ...
    def index_to_three_state_cell(self, index: int) -> offset_coordinate: ...
    def index_to_two_state_cell(self, index: int) -> offset_coordinate: ...
    def chargeless_potential_at_given_distance(self, distance: float) -> float: ...
    def chargeless_potential_generated_by_defect_at_given_distance(
        self, distance: float, defect: sidb_defect
    ) -> float: ...
    def assign_local_external_potential(self, external_potential: float) -> None: ...
    def get_local_external_potentials(self) -> list[float]: ...
    def get_local_defect_potentials(self) -> list[float]: ...
    def get_defects(self) -> list[sidb_defect]: ...
    def update_charge_state_of_dependent_cell(self) -> None: ...
    def get_charge_index_of_sub_layout(self) -> int: ...
    def charge_index_gray_code_to_charge_distribution(self, new_gray_code: int, old_gray_code: int) -> None: ...
    def increase_charge_index_of_sub_layout_by_one(
        self,
        dependent_cell_fixed: dependent_cell_mode = ...,
        recompute_system_energy: energy_calculation = ...,
        consider_history: charge_distribution_history = ...,
        engine: exact_sidb_simulation_engine = ...,
    ) -> None: ...
    def assign_charge_index_by_gray_code(
        self,
        current_gray_code: int,
        previous_gray_code: int,
        dependent_cell: dependent_cell_mode = ...,
        energy_calc_mode: energy_calculation = ...,
        history_mode: charge_distribution_history = ...,
    ) -> None: ...
    def reset_charge_index_sub_layout(self) -> None: ...
    def get_max_charge_index_sub_layout(self) -> int: ...
    def assign_charge_index_by_two_gray_codes(self, gray_code: int, gray_code_old: int) -> None: ...
    def get_sidb_order(self) -> list[int]: ...
    def add_sidb(self, cell: offset_coordinate, charge: int) -> None: ...
    def cells(self) -> list[tuple[int, int, int]]: ...
    def pis(self) -> list[tuple[int, int, int]]: ...
    def pos(self) -> list[tuple[int, int, int]]: ...
    def is_within_bounds(self, c: tuple[int, int, int]) -> bool: ...
    def bounding_box_2d(self) -> tuple[tuple[int, int], tuple[int, int]]: ...

class charge_distribution_surface(sidb_layout):
    def __init__(self, params: sidb_simulation_parameters = ..., cs: sidb_charge_state = ...) -> None: ...
    @overload
    def __init__(
        self,
        lyt: charge_distribution_surface_100,
        params: sidb_simulation_parameters = ...,
        cs: sidb_charge_state = ...,
    ) -> None: ...
    @overload
    def __init__(self, lyt: charge_distribution_surface_100) -> None: ...
    def get_all_sidb_locations_in_nm(self) -> list[tuple[float, float, float]]: ...
    def assign_cell_type(self, c: sidb_technology.cell_type, ct: int) -> None: ...
    def assign_physical_parameters(self, params: sidb_simulation_parameters) -> None: ...
    def get_phys_params(self) -> sidb_simulation_parameters: ...
    def charge_exists(self, cs: sidb_charge_state) -> bool: ...
    def cell_to_index(self, c: offset_coordinate) -> int: ...
    def assign_charge_state(
        self, c: offset_coordinate, cs: sidb_charge_state, index_mode: charge_index_mode = ...
    ) -> None: ...
    def assign_charge_by_cell_index(self, i: int, cs: sidb_charge_state) -> None: ...
    def assign_all_charge_states(self, cs: sidb_charge_state) -> None: ...
    def assign_dependent_cell(self, dependent_cell: offset_coordinate) -> None: ...
    def assign_base_number(self, base: int) -> None: ...
    def add_sidb_defect_to_potential_landscape(self, c: sidb_charge_state, defect: sidb_defect) -> None: ...
    def erase_defect(self, c: offset_coordinate) -> None: ...
    def assign_charge_state_by_cell_index(
        self, index: int, cs: sidb_charge_state, index_mode: charge_index_mode = ...
    ) -> None: ...
    def get_charge_state(self, c: offset_coordinate) -> sidb_charge_state: ...
    def get_charge_state_by_index(self, index: int) -> sidb_charge_state: ...
    def get_all_sidb_charges(self) -> list[sidb_charge_state]: ...
    def negative_sidb_detection(self) -> list[int]: ...
    def get_nm_distance_between_sidbs(self, c1: offset_coordinate, c2: offset_coordinate) -> float: ...
    def get_nm_distance_by_indices(self, index1: int, index2: int) -> float: ...
    def calculate_chargeless_potential_between_sidbs_by_index(self, index1: int, index2: int) -> float: ...
    def calculate_chargeless_potential_between_sidbs(self, c1: offset_coordinate, c2: offset_coordinate) -> float: ...
    def get_chargeless_potential_between_sidbs(self, c1: offset_coordinate, c2: offset_coordinate) -> float: ...
    def get_chargeless_potential_by_indices(self, index1: int, index2: int) -> float: ...
    def get_potential_between_sidbs(self, c1: offset_coordinate, c2: offset_coordinate) -> float: ...
    def update_local_potential(self, consider_history: charge_distribution_history) -> None: ...
    def get_local_potential(self, c: offset_coordinate) -> float: ...
    def get_local_potential_by_index(self, index: int) -> float: ...
    def assign_system_energy_to_zero(self) -> None: ...
    def recompute_system_energy(self) -> None: ...
    def get_system_energy(self) -> float: ...
    def update_after_charge_change(
        self,
        dep_cell: dependent_cell_mode = ...,
        energy_calculation_mode: energy_calculation = ...,
        history_mode: charge_distribution_history = ...,
    ) -> None: ...
    def validity_check(self) -> bool: ...
    def is_physically_valid(self) -> bool: ...
    def charge_distribution_to_index_general(self) -> int: ...
    def charge_distribution_to_index(self) -> int: ...
    def get_charge_index_and_base(self) -> tuple[int, int]: ...
    def increase_charge_index_by_one(
        self,
        dependent_cell_fixed: dependent_cell_mode = ...,
        recompute_system_energy: energy_calculation = ...,
        consider_history: charge_distribution_history = ...,
        engine: exact_sidb_simulation_engine = ...,
    ) -> None: ...
    def get_max_charge_index(self) -> int: ...
    def assign_charge_index(self, charge_index: int, cdc: offset_coordinate) -> None: ...
    def adjacent_search(self, alpha: float, negative_indices: list[int]) -> None: ...
    def assign_global_external_potential(
        self, potential_value: float, dependent_cell: dependent_cell_mode = ...
    ) -> None: ...
    def is_three_state_simulation_required(self) -> bool: ...
    def get_positive_candidates(self) -> list[int]: ...
    def three_state_cell_to_index(self, c: offset_coordinate) -> int: ...
    def two_state_cell_to_index(self, c: offset_coordinate) -> int: ...
    def index_to_cell(self, index: int) -> offset_coordinate: ...
    def index_to_three_state_cell(self, index: int) -> offset_coordinate: ...
    def index_to_two_state_cell(self, index: int) -> offset_coordinate: ...
    def chargeless_potential_at_given_distance(self, distance: float) -> float: ...
    def chargeless_potential_generated_by_defect_at_given_distance(
        self, distance: float, defect: sidb_defect
    ) -> float: ...
    def assign_local_external_potential(self, external_potential: float) -> None: ...
    def get_local_external_potentials(self) -> list[float]: ...
    def get_local_defect_potentials(self) -> list[float]: ...
    def get_defects(self) -> list[sidb_defect]: ...
    def update_charge_state_of_dependent_cell(self) -> None: ...
    def get_charge_index_of_sub_layout(self) -> int: ...
    def charge_index_gray_code_to_charge_distribution(self, new_gray_code: int, old_gray_code: int) -> None: ...
    def increase_charge_index_of_sub_layout_by_one(
        self,
        dependent_cell_fixed: dependent_cell_mode = ...,
        recompute_system_energy: energy_calculation = ...,
        consider_history: charge_distribution_history = ...,
        engine: exact_sidb_simulation_engine = ...,
    ) -> None: ...
    def assign_charge_index_by_gray_code(
        self,
        current_gray_code: int,
        previous_gray_code: int,
        dependent_cell: dependent_cell_mode = ...,
        energy_calc_mode: energy_calculation = ...,
        history_mode: charge_distribution_history = ...,
    ) -> None: ...
    def reset_charge_index_sub_layout(self) -> None: ...
    def get_max_charge_index_sub_layout(self) -> int: ...
    def assign_charge_index_by_two_gray_codes(self, gray_code: int, gray_code_old: int) -> None: ...
    def get_sidb_order(self) -> list[int]: ...
    def add_sidb(self, cell: offset_coordinate, charge: int) -> None: ...
    def cells(self) -> list[tuple[int, int, int]]: ...
    def pis(self) -> list[tuple[int, int, int]]: ...
    def pos(self) -> list[tuple[int, int, int]]: ...
    def is_within_bounds(self, c: tuple[int, int, int]) -> bool: ...
    def bounding_box_2d(self) -> tuple[tuple[int, int], tuple[int, int]]: ...

class sidb_simulation_engine(Enum):
    EXGS: ...
    QUICKSIM: ...
    QUICKEXACT: ...

class exact_sidb_simulation_engine(Enum):
    EXGS: ...
    QUICKEXACT: ...

@overload
def sidb_nm_position(
    lyt: charge_distribution_surface | sidb_layout | sidb_100_lattice | sidb_111_lattice, c: sidb_technology.cell_type
) -> None: ...
@overload
def sidb_nm_distance_111(lyt: sidb_111_lattice, c: sidb_technology.cell_type) -> None: ...

class sidb_simulation_parameters:
    def __init__(
        self,
        base_number: int = 3,
        mu_minus: float = -0.32,
        relative_permittivity: float = 5.6,
        screening_distance: float = 5.0,
    ) -> None: ...
    def k(self) -> float: ...
    def mu_plus(self) -> float: ...

    epsilon_r: float
    lambda_tf: float
    mu_minus: float
    base: int

class transition_type(Enum):
    NEUTRAL_TO_NEGATIVE: ...
    NEGATIVE_TO_NEUTRAL: ...
    NEUTRAL_TO_POSITIVE: ...
    POSITIVE_TO_NEUTRAL: ...

class population_stability_information:
    def __init__(self) -> None: ...

    critical_cell: tuple[int, int]
    transition_from_to: transition_type
    minimum_potential_difference_to_transition: float
    distance_corresponding_to_potential: float
    system_energy: float

class assess_physical_population_stability_params:
    def __init__(self) -> None: ...

    simulation_parameters: sidb_simulation_parameters
    precision_for_distance_corresponding_to_potential: float

def assess_physical_population_stability_100(
    lyt: sidb_100_lattice, params: assess_physical_population_stability_params = ...
) -> list[population_stability_information]: ...
def assess_physical_population_stability_111(
    lyt: sidb_100_lattice, params: assess_physical_population_stability_params = ...
) -> list[population_stability_information]: ...
def energy_distribution(input_vec: list[charge_distribution_surface]) -> dict[float, int]: ...

class bdl_wire_selection(Enum):
    ALL: ...
    INPUT: ...
    OUTPUT: ...

class bdl_wire_100(sidb_100_lattice):
    def __init__(self, p: list[bdl_pair]) -> None: ...

    pairs: list[bdl_pair]
    direction: int
    first_bdl_pair: bdl_pair
    last_bdl_pair: bdl_pair

class bdl_wire_111(sidb_111_lattice):
    def __init__(self, p: list[bdl_pair]) -> None: ...

    pairs: list[bdl_pair]
    direction: int
    first_bdl_pair: bdl_pair
    last_bdl_pair: bdl_pair

class detect_bdl_wires_params:
    def __init__(self) -> None: ...

    threshold_bdl_interdistance: float
    bdl_pairs_params: object

def detect_bdl_wires_100(
    lyt: sidb_100_lattice, params: detect_bdl_wires_params = ..., wire_selection: bdl_wire_selection = ...
) -> list[bdl_wire_100]: ...
def detect_bdl_wires_111(
    lyt: sidb_111_lattice, params: detect_bdl_wires_params = ..., wire_selection: bdl_wire_selection = ...
) -> list[bdl_wire_111]: ...

# Enums
class operational_status:
    OPERATIONAL: ...
    NON_OPERATIONAL: ...

class operational_condition:
    TOLERATE_KINKS: ...
    REJECT_KINKS: ...

# Class Definitions
class is_operational_params:
    def __init__(self) -> None: ...

    simulation_parameters: sidb_simulation_parameters
    sim_engine: sidb_simulation_engine
    input_bdl_iterator_params: bdl_input_iterator_params
    op_condition: operational_condition

# Functions

@overload
def is_operational(
    lyt: sidb_100_lattice,
    spec: object,
    params: is_operational_params = ...,
    input_bdl_wire: bdl_wire_100 | None = None,
    output_bdl_wire: bdl_wire_100 | None = None,
) -> operational_status: ...
@overload
def is_operational(
    lyt: sidb_100_lattice,
    spec: object,
    params: is_operational_params = ...,
    input_bdl_wire: bdl_wire_111 | None = None,
    output_bdl_wire: bdl_wire_111 | None = None,
) -> operational_status: ...
@overload
def operational_input_patterns(
    lyt: sidb_100_lattice,
    spec: object,  # Type depends on the specification
    params: is_operational_params = ...,
) -> list[int]: ...
@overload
def operational_input_patterns(
    lyt: sidb_111_lattice,
    spec: object,  # Type depends on the specification
    params: is_operational_params = ...,
) -> list[int]: ...
def is_kink_induced_non_operational(
    lyt: sidb_100_lattice | sidb_111_lattice,
    spec: object,
    params: is_operational_params = ...,
    input_bdl_wire: object | None = None,
    output_bdl_wire: object | None = None,
) -> operational_status: ...
def kink_induced_non_operational_input_patterns(
    lyt: sidb_100_lattice | sidb_111_lattice,
    spec: object,
    params: is_operational_params = ...,
) -> object: ...

# QuickExact
class quickexact_params:
    def __init__(self) -> None:
        self.simulation_parameters: sidb_simulation_parameters
        self.base_number_detection: automatic_base_number_detection
        self.local_external_potential: float
        self.global_potential: float

class automatic_base_number_detection(Enum):
    ON = ...
    OFF = ...

def quickexact(lyt: sidb_100_lattice | sidb_111_lattice, params: quickexact_params) -> None: ...

# QuickSim
class quicksim_params:
    def __init__(self) -> None:
        self.simulation_parameters: sidb_simulation_parameters
        self.iteration_steps: int
        self.alpha: float
        self.number_threads: int

def quicksim(lyt: sidb_100_lattice, params: quicksim_params) -> None: ...

class critical_temperature_stats:
    def __init__(self) -> None: ...
    def report(self) -> None: ...

    algorithm_name: str
    num_valid_lyt: int
    is_ground_state_transparent: float

class critical_temperature_params:
    def __init__(self) -> None: ...

    operational_params: dict
    confidence_level: float
    max_temperature: float

def critical_temperature_gate_based(
    lyt: sidb_100_lattice | sidb_111_lattice,
    spec: dict,
    params: critical_temperature_params | None = ...,
    stats: critical_temperature_stats | None = ...,
) -> float | None: ...
def critical_temperature_non_gate_based(
    lyt: sidb_100_lattice | sidb_111_lattice,
    params: critical_temperature_params | None = ...,
    stats: critical_temperature_stats | None = ...,
) -> float | None: ...

class parameter_point:
    def __init__(self, values: list[float] | None = None) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: parameter_point) -> bool: ...
    def __ne__(self, other: parameter_point) -> bool: ...

    parameters: list[float]

class sweep_parameter(Enum):
    EPSILON_R: ...
    LAMBDA_TF: ...
    MU_MINUS: ...

class operational_domain_value_range:
    def __init__(
        self, dimension: sweep_parameter, min: float | None = None, max: float | None = None, step: float | None = None
    ) -> None: ...

    dimension: sweep_parameter
    min: float
    max: float
    step: float

class operational_domain_params:
    def __init__(self) -> None: ...

    operational_params: dict[str, float]
    sweep_dimensions: list[operational_domain_value_range]

class operational_domain_stats:
    def __init__(self) -> None: ...

    time_total: float
    num_simulator_invocations: int
    num_evaluated_parameter_combinations: int
    num_operational_parameter_combinations: int
    num_non_operational_parameter_combinations: int
    num_total_parameter_points: int

class operational_domain:
    def __init__(self) -> None: ...

    dimensions: list[operational_domain_value_range]
    operational_values: dict[parameter_point, str]

def get_value(self, point: parameter_point) -> str: ...
def operational_domain_grid_search(
    lyt: sidb_100_lattice | sidb_111_lattice,
    spec: dict,
    params: operational_domain_params | None = None,
    stats: operational_domain_stats | None = None,
) -> operational_domain | None: ...
def operational_domain_random_sampling(
    lyt: sidb_100_lattice | sidb_111_lattice,
    spec: dict,
    samples: int,
    params: operational_domain_params | None = None,
    stats: operational_domain_stats | None = None,
) -> operational_domain | None: ...
def operational_domain_flood_fill(
    lyt: sidb_100_lattice | sidb_111_lattice,
    spec: dict,
    samples: int,
    params: operational_domain_params | None = None,
    stats: operational_domain_stats | None = None,
) -> operational_domain | None: ...
def operational_domain_contour_tracing(
    lyt: sidb_100_lattice | sidb_111_lattice,
    spec: dict,
    samples: int,
    params: operational_domain_params | None = None,
    stats: operational_domain_stats | None = None,
) -> operational_domain | None: ...

# Utils

# Functions to create various types of truth tables
def create_id_tt() -> Callable[[int], int]: ...
def create_not_tt() -> Callable[[int], int]: ...
def create_and_tt() -> Callable[[int, int], int]: ...
def create_or_tt() -> Callable[[int, int], int]: ...
def create_nand_tt() -> Callable[[int, int], int]: ...
def create_nor_tt() -> Callable[[int, int], int]: ...
def create_xor_tt() -> Callable[[int, int], int]: ...
def create_xnor_tt() -> Callable[[int, int], int]: ...
def create_lt_tt() -> Callable[[int, int], int]: ...
def create_gt_tt() -> Callable[[int, int], int]: ...
def create_le_tt() -> Callable[[int, int], int]: ...
def create_ge_tt() -> Callable[[int, int], int]: ...
def create_and3_tt() -> Callable[[int, int, int], int]: ...
def create_xor_and_tt() -> Callable[[int, int, int], int]: ...
def create_or_and_tt() -> Callable[[int, int, int], int]: ...
def create_onehot_tt() -> Callable[[int], int]: ...
def create_maj_tt() -> Callable[[int, int, int], int]: ...
def create_gamble_tt() -> Callable[[int, int], int]: ...
def create_dot_tt() -> Callable[[int, int], int]: ...
def create_ite_tt() -> Callable[[int, int, int], int]: ...
def create_and_xor_tt() -> Callable[[int, int, int], int]: ...
def create_xor3_tt() -> Callable[[int, int, int], int]: ...
def create_double_wire_tt() -> Callable[[int, int], int]: ...
def create_crossing_wire_tt() -> Callable[[int, int], int]: ...
def create_fan_out_tt() -> Callable[[int], int]: ...
def create_half_adder_tt() -> Callable[[int, int], int]: ...

# TODO all utils
