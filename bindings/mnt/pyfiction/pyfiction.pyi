from enum import Enum
from typing import overload

# Layouts

class offset_coordinate:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, int_repr: int) -> None: ...
    @overload
    def __init__(self, x: int, y: int, z: int) -> None: ...
    @overload
    def __init__(self, c: offset_coordinate) -> None: ...
    @overload
    def __init__(self, c: tuple[int, int, int]) -> None: ...

    x: int
    y: int
    z: int

    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: offset_coordinate) -> bool: ...
    def __gt__(self, other: offset_coordinate) -> bool: ...
    def __le__(self, other: offset_coordinate) -> bool: ...
    def __ge__(self, other: offset_coordinate) -> bool: ...
    def __hash__(self) -> int: ...

class cube_coordinate:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: int, y: int, z: int = 0) -> None: ...
    @overload
    def __init__(self, c: cube_coordinate) -> None: ...
    @overload
    def __init__(self, c: tuple[int, int, int]) -> None: ...

    x: int
    y: int
    z: int

    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: cube_coordinate) -> bool: ...
    def __gt__(self, other: cube_coordinate) -> bool: ...
    def __le__(self, other: cube_coordinate) -> bool: ...
    def __ge__(self, other: cube_coordinate) -> bool: ...
    def __hash__(self) -> int: ...

class siqad_coordinate:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: int, y: int, z: int = 0) -> None: ...
    @overload
    def __init__(self, c: siqad_coordinate) -> None: ...
    @overload
    def __init__(self, c: tuple[int, int, int]) -> None: ...

    x: int
    y: int
    z: int

    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: siqad_coordinate) -> bool: ...
    def __gt__(self, other: siqad_coordinate) -> bool: ...
    def __le__(self, other: siqad_coordinate) -> bool: ...
    def __ge__(self, other: siqad_coordinate) -> bool: ...
    def __hash__(self) -> int: ...

# For consistent behavior:
def area(coord: offset_coordinate | cube_coordinate | siqad_coordinate) -> float: ...
def volume(coord: offset_coordinate | cube_coordinate | siqad_coordinate) -> float: ...

# For conversions with potentially nuanced behavior:
@overload
def to_offset_coord(coord: siqad_coordinate) -> offset_coordinate: ...
@overload
def to_cube_coord(coord: siqad_coordinate) -> cube_coordinate: ...
@overload
def to_siqad_coord(coord: offset_coordinate) -> siqad_coordinate: ...
@overload
def to_siqad_coord(coord: cube_coordinate) -> siqad_coordinate: ...

class cartesian_layout:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate) -> None: ...
    def coord(self, x: int, y: int, z: int = 0) -> offset_coordinate: ...
    def x(self) -> int: ...
    def y(self) -> int: ...
    def z(self) -> int: ...
    def area(self) -> int: ...
    def resize(self, dimension: offset_coordinate) -> None: ...
    def north(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def north_east(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def east(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def south_east(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def south(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def south_west(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def west(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def north_west(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def above(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def below(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def is_north_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_east_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_south_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_west_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_adjacent_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_adjacent_elevation_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_above(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_below(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_northwards_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_eastwards_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_southwards_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_westwards_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_at_northern_border(self, c: offset_coordinate) -> bool: ...
    def is_at_eastern_border(self, c: offset_coordinate) -> bool: ...
    def is_at_southern_border(self, c: offset_coordinate) -> bool: ...
    def is_at_western_border(self, c: offset_coordinate) -> bool: ...
    def is_at_any_border(self, c: offset_coordinate) -> bool: ...
    def northern_border_of(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def eastern_border_of(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def southern_border_of(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def western_border_of(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def is_ground_layer(self, c: offset_coordinate) -> bool: ...
    def is_crossing_layer(self, c: offset_coordinate) -> bool: ...
    def is_within_bounds(self, c: offset_coordinate) -> bool: ...
    def offset_coordinates(self) -> list[offset_coordinate]: ...
    def ground_coordinates(self) -> list[offset_coordinate]: ...
    def adjacent_coordinates(self, c: offset_coordinate) -> list[offset_coordinate]: ...
    def adjacent_opposite_coordinates(self, c: offset_coordinate) -> list[offset_coordinate]: ...

class shifted_cartesian_layout:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate) -> None: ...
    def coord(self, x: int, y: int, z: int = 0) -> offset_coordinate: ...
    def x(self) -> int: ...
    def y(self) -> int: ...
    def z(self) -> int: ...
    def area(self) -> int: ...
    def resize(self, dimension: offset_coordinate) -> None: ...
    def north(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def north_east(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def east(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def south_east(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def south(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def south_west(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def west(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def north_west(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def above(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def below(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def is_north_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_east_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_south_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_west_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_adjacent_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_adjacent_elevation_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_above(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_below(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_northwards_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_eastwards_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_southwards_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_westwards_of(self, c1: offset_coordinate, c2: offset_coordinate) -> bool: ...
    def is_at_northern_border(self, c: offset_coordinate) -> bool: ...
    def is_at_eastern_border(self, c: offset_coordinate) -> bool: ...
    def is_at_southern_border(self, c: offset_coordinate) -> bool: ...
    def is_at_western_border(self, c: offset_coordinate) -> bool: ...
    def is_at_any_border(self, c: offset_coordinate) -> bool: ...
    def northern_border_of(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def eastern_border_of(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def southern_border_of(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def western_border_of(self, c: offset_coordinate) -> offset_coordinate | None: ...
    def is_ground_layer(self, c: offset_coordinate) -> bool: ...
    def is_crossing_layer(self, c: offset_coordinate) -> bool: ...
    def is_within_bounds(self, c: offset_coordinate) -> bool: ...
    def offset_coordinates(self) -> list[offset_coordinate]: ...
    def ground_coordinates(self) -> list[offset_coordinate]: ...
    def adjacent_coordinates(self, c: offset_coordinate) -> list[offset_coordinate]: ...
    def adjacent_opposite_coordinates(self, c: offset_coordinate) -> list[offset_coordinate]: ...

class hexagonal_layout:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: cube_coordinate) -> None: ...
    def coord(self, x: int, y: int, z: int = 0) -> cube_coordinate: ...
    def x(self) -> int: ...
    def y(self) -> int: ...
    def z(self) -> int: ...
    def area(self) -> int: ...
    def resize(self, dimension: cube_coordinate) -> None: ...
    def north(self, c: cube_coordinate) -> cube_coordinate | None: ...
    def north_east(self, c: cube_coordinate) -> cube_coordinate | None: ...
    def east(self, c: cube_coordinate) -> cube_coordinate | None: ...
    def south_east(self, c: cube_coordinate) -> cube_coordinate | None: ...
    def south(self, c: cube_coordinate) -> cube_coordinate | None: ...
    def south_west(self, c: cube_coordinate) -> cube_coordinate | None: ...
    def west(self, c: cube_coordinate) -> cube_coordinate | None: ...
    def north_west(self, c: cube_coordinate) -> cube_coordinate | None: ...
    def above(self, c: cube_coordinate) -> cube_coordinate | None: ...
    def below(self, c: cube_coordinate) -> cube_coordinate | None: ...
    def is_north_of(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...
    def is_east_of(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...
    def is_south_of(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...
    def is_west_of(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...
    def is_adjacent_of(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...
    def is_adjacent_elevation_of(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...
    def is_above(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...
    def is_below(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...
    def is_northwards_of(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...
    def is_eastwards_of(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...
    def is_southwards_of(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...
    def is_westwards_of(self, c1: cube_coordinate, c2: cube_coordinate) -> bool: ...
    def is_at_northern_border(self, c: cube_coordinate) -> bool: ...
    def is_at_eastern_border(self, c: cube_coordinate) -> bool: ...
    def is_at_southern_border(self, c: cube_coordinate) -> bool: ...
    def is_at_western_border(self, c: cube_coordinate) -> bool: ...
    def is_at_any_border(self, c: cube_coordinate) -> bool: ...
    def northern_border_of(self, c: cube_coordinate) -> cube_coordinate | None: ...
    def eastern_border_of(self, c: cube_coordinate) -> cube_coordinate | None: ...
    def southern_border_of(self, c: cube_coordinate) -> cube_coordinate | None: ...
    def western_border_of(self, c: cube_coordinate) -> cube_coordinate | None: ...
    def is_ground_layer(self, c: cube_coordinate) -> bool: ...
    def is_crossing_layer(self, c: cube_coordinate) -> bool: ...
    def is_within_bounds(self, c: cube_coordinate) -> bool: ...
    def coordinates(self) -> list[cube_coordinate]: ...
    def ground_coordinates(self) -> list[cube_coordinate]: ...
    def adjacent_coordinates(self, c: cube_coordinate) -> list[cube_coordinate]: ...
    def adjacent_opposite_coordinates(self, c: cube_coordinate) -> list[cube_coordinate]: ...

class clocked_cartesian_layout(cartesian_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate, clocking_scheme: str = "2DDWave") -> None: ...
    def assign_clock_number(self, cz: offset_coordinate, cn: int) -> None: ...
    def get_clock_number(self, cz: offset_coordinate) -> int: ...
    def num_clocks(self) -> int: ...
    def is_regularly_clocked(self) -> bool: ...
    def is_clocking_scheme(self, name: str) -> bool: ...
    def is_incoming_clocked(self, cz1: offset_coordinate, cz2: offset_coordinate) -> bool: ...
    def is_outgoing_clocked(self, cz1: offset_coordinate, cz2: offset_coordinate) -> bool: ...
    def incoming_clocked_zones(self, cz: offset_coordinate) -> list[offset_coordinate]: ...
    def outgoing_clocked_zones(self, cz: offset_coordinate) -> list[offset_coordinate]: ...
    def in_degree(self, cz: offset_coordinate) -> int: ...
    def out_degree(self, cz: offset_coordinate) -> int: ...
    def degree(self, cz: offset_coordinate) -> int: ...

class clocked_shifted_cartesian_layout(shifted_cartesian_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate, clocking_scheme: str = "2DDWave") -> None: ...
    def assign_clock_number(self, cz: offset_coordinate, cn: int) -> None: ...
    def get_clock_number(self, cz: offset_coordinate) -> int: ...
    def num_clocks(self) -> int: ...
    def is_regularly_clocked(self) -> bool: ...
    def is_clocking_scheme(self, name: str) -> bool: ...
    def is_incoming_clocked(self, cz1: offset_coordinate, cz2: offset_coordinate) -> bool: ...
    def is_outgoing_clocked(self, cz1: offset_coordinate, cz2: offset_coordinate) -> bool: ...
    def incoming_clocked_zones(self, cz: offset_coordinate) -> list[offset_coordinate]: ...
    def outgoing_clocked_zones(self, cz: offset_coordinate) -> list[offset_coordinate]: ...
    def in_degree(self, cz: offset_coordinate) -> int: ...
    def out_degree(self, cz: offset_coordinate) -> int: ...
    def degree(self, cz: offset_coordinate) -> int: ...

class clocked_hexagonal_layout(hexagonal_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: cube_coordinate) -> None: ...
    @overload
    def __init__(self, dimension: cube_coordinate, clocking_scheme: str = "2DDWave") -> None: ...
    def assign_clock_number(self, cz: cube_coordinate, cn: int) -> None: ...
    def get_clock_number(self, cz: cube_coordinate) -> int: ...
    def num_clocks(self) -> int: ...
    def is_regularly_clocked(self) -> bool: ...
    def is_clocking_scheme(self, name: str) -> bool: ...
    def is_incoming_clocked(self, cz1: cube_coordinate, cz2: cube_coordinate) -> bool: ...
    def is_outgoing_clocked(self, cz1: cube_coordinate, cz2: cube_coordinate) -> bool: ...
    def incoming_clocked_zones(self, cz: cube_coordinate) -> list[cube_coordinate]: ...
    def outgoing_clocked_zones(self, cz: cube_coordinate) -> list[cube_coordinate]: ...
    def in_degree(self, cz: cube_coordinate) -> int: ...
    def out_degree(self, cz: cube_coordinate) -> int: ...
    def degree(self, cz: cube_coordinate) -> int: ...

class cartesian_gate_layout(clocked_cartesian_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate) -> None: ...
    @overload
    def __init__(
        self, dimension: offset_coordinate, clocking_scheme: str = "2DDWave", layout_name: str = ""
    ) -> None: ...
    def create_pi(self, name: str = "", t: offset_coordinate | None = None) -> None: ...
    def create_po(self, s: int, name: str = "", t: offset_coordinate | None = None) -> None: ...
    def is_pi(self, n: int) -> bool: ...
    def is_po(self, n: int) -> bool: ...
    def is_pi_coordinate(self, t: offset_coordinate) -> bool: ...
    def is_po_coordinate(self, t: offset_coordinate) -> bool: ...
    def is_inv(self) -> bool: ...
    def is_and(self) -> bool: ...
    def is_nand(self) -> bool: ...
    def is_or(self) -> bool: ...
    def is_nor(self) -> bool: ...
    def is_xor(self) -> bool: ...
    def is_xnor(self) -> bool: ...
    def is_maj(self) -> bool: ...
    def is_fanout(self) -> bool: ...
    def is_wire(self) -> bool: ...
    def set_layout_name(self, name: str) -> None: ...
    def get_layout_name(self) -> str: ...
    def set_input_name(self, index: int, name: str) -> None: ...
    def get_input_name(self, index: int) -> str: ...
    def set_output_name(self, index: int, name: str) -> None: ...
    def get_output_name(self, index: int) -> str: ...
    def get_name(self, s: int) -> str: ...
    def create_buf(self, a: int, t: offset_coordinate | None = None) -> None: ...
    def create_not(self, a: int, t: offset_coordinate | None = None) -> None: ...
    def create_and(self, a: int, b: int, t: offset_coordinate | None = None) -> None: ...
    def create_nand(self, a: int, b: int, t: offset_coordinate | None = None) -> None: ...
    def create_or(self, a: int, b: int, t: offset_coordinate | None = None) -> None: ...
    def create_nor(self, a: int, b: int, t: offset_coordinate | None = None) -> None: ...
    def create_xor(self, a: int, b: int, t: offset_coordinate | None = None) -> None: ...
    def create_xnor(self, a: int, b: int, t: offset_coordinate | None = None) -> None: ...
    def create_maj(self, a: int, b: int, c: int, t: offset_coordinate | None = None) -> None: ...
    def num_pis(self) -> int: ...
    def num_pos(self) -> int: ...
    def num_gates(self) -> int: ...
    def num_wires(self) -> int: ...
    def num_crossings(self) -> int: ...
    def is_empty(self) -> bool: ...
    def fanin_size(self, n: int) -> int: ...
    def fanout_size(self, n: int) -> int: ...
    def get_int(self, t: offset_coordinate) -> int: ...
    def get_coordinate(self, n: int) -> offset_coordinate: ...
    def make_int(self, n: int) -> int: ...
    def move_int(self, n: int, t: offset_coordinate, new_children: list[offset_coordinate] = []) -> None: ...
    def clear_coordinate(self, t: offset_coordinate) -> None: ...
    def is_gate_coordinate(self, t: offset_coordinate) -> bool: ...
    def is_wire_coordinate(self, t: offset_coordinate) -> bool: ...
    def is_empty_coordinate(self, t: offset_coordinate) -> bool: ...
    def pis(self) -> list[offset_coordinate]: ...
    def pos(self) -> list[offset_coordinate]: ...
    def gates(self) -> list[offset_coordinate]: ...
    def wires(self) -> list[offset_coordinate]: ...
    def fanins(self, t: offset_coordinate) -> list[int]: ...
    def fanouts(self, t: offset_coordinate) -> list[int]: ...
    def is_incoming_int(self, t: offset_coordinate, s: int) -> bool: ...
    def has_no_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_northern_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_north_eastern_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_eastern_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_south_eastern_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_southern_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_south_western_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_western_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_north_western_incoming_int(self, t: offset_coordinate) -> bool: ...
    def is_outgoing_int(self, t: offset_coordinate, s: int) -> bool: ...
    def has_no_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_northern_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_north_eastern_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_eastern_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_south_eastern_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_southern_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_south_western_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_western_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_north_western_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def bounding_box_2d(self) -> tuple[offset_coordinate, offset_coordinate]: ...
    def is_dead(self, n: int) -> bool: ...

class shifted_cartesian_gate_layout(clocked_shifted_cartesian_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate) -> None: ...
    @overload
    def __init__(
        self, dimension: offset_coordinate, clocking_scheme: str = "2DDWave", layout_name: str = ""
    ) -> None: ...
    def create_pi(self, name: str = "", t: offset_coordinate | None = None) -> None: ...
    def create_po(self, s: int, name: str = "", t: offset_coordinate | None = None) -> None: ...
    def is_pi(self, n: int) -> bool: ...
    def is_po(self, n: int) -> bool: ...
    def is_pi_coordinate(self, t: offset_coordinate) -> bool: ...
    def is_po_coordinate(self, t: offset_coordinate) -> bool: ...
    def is_inv(self) -> bool: ...
    def is_and(self) -> bool: ...
    def is_nand(self) -> bool: ...
    def is_or(self) -> bool: ...
    def is_nor(self) -> bool: ...
    def is_xor(self) -> bool: ...
    def is_xnor(self) -> bool: ...
    def is_maj(self) -> bool: ...
    def is_fanout(self) -> bool: ...
    def is_wire(self) -> bool: ...
    def set_layout_name(self, name: str) -> None: ...
    def get_layout_name(self) -> str: ...
    def set_input_name(self, index: int, name: str) -> None: ...
    def get_input_name(self, index: int) -> str: ...
    def set_output_name(self, index: int, name: str) -> None: ...
    def get_output_name(self, index: int) -> str: ...
    def get_name(self, s: int) -> str: ...
    def create_buf(self, a: int, t: offset_coordinate | None = None) -> None: ...
    def create_not(self, a: int, t: offset_coordinate | None = None) -> None: ...
    def create_and(self, a: int, b: int, t: offset_coordinate | None = None) -> None: ...
    def create_nand(self, a: int, b: int, t: offset_coordinate | None = None) -> None: ...
    def create_or(self, a: int, b: int, t: offset_coordinate | None = None) -> None: ...
    def create_nor(self, a: int, b: int, t: offset_coordinate | None = None) -> None: ...
    def create_xor(self, a: int, b: int, t: offset_coordinate | None = None) -> None: ...
    def create_xnor(self, a: int, b: int, t: offset_coordinate | None = None) -> None: ...
    def create_maj(self, a: int, b: int, c: int, t: offset_coordinate | None = None) -> None: ...
    def num_pis(self) -> int: ...
    def num_pos(self) -> int: ...
    def num_gates(self) -> int: ...
    def num_wires(self) -> int: ...
    def num_crossings(self) -> int: ...
    def is_empty(self) -> bool: ...
    def fanin_size(self, n: int) -> int: ...
    def fanout_size(self, n: int) -> int: ...
    def get_int(self, t: offset_coordinate) -> int: ...
    def get_coordinate(self, n: int) -> offset_coordinate: ...
    def make_int(self, n: int) -> int: ...
    def move_int(self, n: int, t: offset_coordinate, new_children: list[offset_coordinate] = []) -> None: ...
    def clear_coordinate(self, t: offset_coordinate) -> None: ...
    def is_gate_coordinate(self, t: offset_coordinate) -> bool: ...
    def is_wire_coordinate(self, t: offset_coordinate) -> bool: ...
    def is_empty_coordinate(self, t: offset_coordinate) -> bool: ...
    def pis(self) -> list[offset_coordinate]: ...
    def pos(self) -> list[offset_coordinate]: ...
    def gates(self) -> list[offset_coordinate]: ...
    def wires(self) -> list[offset_coordinate]: ...
    def fanins(self, t: offset_coordinate) -> list[int]: ...
    def fanouts(self, t: offset_coordinate) -> list[int]: ...
    def is_incoming_int(self, t: offset_coordinate, s: int) -> bool: ...
    def has_no_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_northern_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_north_eastern_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_eastern_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_south_eastern_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_southern_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_south_western_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_western_incoming_int(self, t: offset_coordinate) -> bool: ...
    def has_north_western_incoming_int(self, t: offset_coordinate) -> bool: ...
    def is_outgoing_int(self, t: offset_coordinate, s: int) -> bool: ...
    def has_no_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_northern_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_north_eastern_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_eastern_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_south_eastern_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_southern_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_south_western_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_western_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def has_north_western_outgoing_int(self, t: offset_coordinate) -> bool: ...
    def bounding_box_2d(self) -> tuple[offset_coordinate, offset_coordinate]: ...
    def is_dead(self, n: int) -> bool: ...

class hexagonal_gate_layout(clocked_hexagonal_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: cube_coordinate) -> None: ...
    @overload
    def __init__(self, dimension: cube_coordinate, clocking_scheme: str = "2DDWave", layout_name: str = "") -> None: ...
    def create_pi(self, name: str = "", t: cube_coordinate | None = None) -> None: ...
    def create_po(self, s: int, name: str = "", t: cube_coordinate | None = None) -> None: ...
    def is_pi(self, n: int) -> bool: ...
    def is_po(self, n: int) -> bool: ...
    def is_pi_coordinate(self, t: cube_coordinate) -> bool: ...
    def is_po_coordinate(self, t: cube_coordinate) -> bool: ...
    def is_inv(self) -> bool: ...
    def is_and(self) -> bool: ...
    def is_nand(self) -> bool: ...
    def is_or(self) -> bool: ...
    def is_nor(self) -> bool: ...
    def is_xor(self) -> bool: ...
    def is_xnor(self) -> bool: ...
    def is_maj(self) -> bool: ...
    def is_fanout(self) -> bool: ...
    def is_wire(self) -> bool: ...
    def set_layout_name(self, name: str) -> None: ...
    def get_layout_name(self) -> str: ...
    def set_input_name(self, index: int, name: str) -> None: ...
    def get_input_name(self, index: int) -> str: ...
    def set_output_name(self, index: int, name: str) -> None: ...
    def get_output_name(self, index: int) -> str: ...
    def get_name(self, s: int) -> str: ...
    def create_buf(self, a: int, t: cube_coordinate | None = None) -> None: ...
    def create_not(self, a: int, t: cube_coordinate | None = None) -> None: ...
    def create_and(self, a: int, b: int, t: cube_coordinate | None = None) -> None: ...
    def create_nand(self, a: int, b: int, t: cube_coordinate | None = None) -> None: ...
    def create_or(self, a: int, b: int, t: cube_coordinate | None = None) -> None: ...
    def create_nor(self, a: int, b: int, t: cube_coordinate | None = None) -> None: ...
    def create_xor(self, a: int, b: int, t: cube_coordinate | None = None) -> None: ...
    def create_xnor(self, a: int, b: int, t: cube_coordinate | None = None) -> None: ...
    def create_maj(self, a: int, b: int, c: int, t: cube_coordinate | None = None) -> None: ...
    def num_pis(self) -> int: ...
    def num_pos(self) -> int: ...
    def num_gates(self) -> int: ...
    def num_wires(self) -> int: ...
    def num_crossings(self) -> int: ...
    def is_empty(self) -> bool: ...
    def fanin_size(self, n: int) -> int: ...
    def fanout_size(self, n: int) -> int: ...
    def get_int(self, t: cube_coordinate) -> int: ...
    def get_coordinate(self, n: int) -> cube_coordinate: ...
    def make_int(self, n: int) -> int: ...
    def move_int(self, n: int, t: cube_coordinate, new_children: list[cube_coordinate] = []) -> None: ...
    def clear_coordinate(self, t: cube_coordinate) -> None: ...
    def is_gate_coordinate(self, t: cube_coordinate) -> bool: ...
    def is_wire_coordinate(self, t: cube_coordinate) -> bool: ...
    def is_empty_coordinate(self, t: cube_coordinate) -> bool: ...
    def pis(self) -> list[cube_coordinate]: ...
    def pos(self) -> list[cube_coordinate]: ...
    def gates(self) -> list[cube_coordinate]: ...
    def wires(self) -> list[cube_coordinate]: ...
    def fanins(self, t: cube_coordinate) -> list[int]: ...
    def fanouts(self, t: cube_coordinate) -> list[int]: ...
    def is_incoming_int(self, t: cube_coordinate, s: int) -> bool: ...
    def has_no_incoming_int(self, t: cube_coordinate) -> bool: ...
    def has_northern_incoming_int(self, t: cube_coordinate) -> bool: ...
    def has_north_eastern_incoming_int(self, t: cube_coordinate) -> bool: ...
    def has_eastern_incoming_int(self, t: cube_coordinate) -> bool: ...
    def has_south_eastern_incoming_int(self, t: cube_coordinate) -> bool: ...
    def has_southern_incoming_int(self, t: cube_coordinate) -> bool: ...
    def has_south_western_incoming_int(self, t: cube_coordinate) -> bool: ...
    def has_western_incoming_int(self, t: cube_coordinate) -> bool: ...
    def has_north_western_incoming_int(self, t: cube_coordinate) -> bool: ...
    def is_outgoing_int(self, t: cube_coordinate, s: int) -> bool: ...
    def has_no_outgoing_int(self, t: cube_coordinate) -> bool: ...
    def has_northern_outgoing_int(self, t: cube_coordinate) -> bool: ...
    def has_north_eastern_outgoing_int(self, t: cube_coordinate) -> bool: ...
    def has_eastern_outgoing_int(self, t: cube_coordinate) -> bool: ...
    def has_south_eastern_outgoing_int(self, t: cube_coordinate) -> bool: ...
    def has_southern_outgoing_int(self, t: cube_coordinate) -> bool: ...
    def has_south_western_outgoing_int(self, t: cube_coordinate) -> bool: ...
    def has_western_outgoing_int(self, t: cube_coordinate) -> bool: ...
    def has_north_western_outgoing_int(self, t: cube_coordinate) -> bool: ...
    def bounding_box_2d(self) -> tuple[cube_coordinate, cube_coordinate]: ...
    def is_dead(self, n: int) -> bool: ...

class cartesian_obstruction_layout(cartesian_gate_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, layout: cartesian_gate_layout) -> None: ...
    def obstruct_coordinate(self, c: offset_coordinate) -> None: ...
    def obstruct_connection(self, src: offset_coordinate, tgt: offset_coordinate) -> None: ...
    def is_obstructed_coordinate(self, c: offset_coordinate) -> bool: ...
    def is_obstructed_connection(self, src: offset_coordinate, tgt: offset_coordinate) -> bool: ...
    def clear_obstructed_coordinate(self, c: offset_coordinate) -> None: ...
    def clear_obstructed_connection(self, src: offset_coordinate, tgt: offset_coordinate) -> None: ...
    def clear_obstructed_coordinates(self) -> None: ...
    def clear_obstructed_connections(self) -> None: ...

class shifted_cartesian_obstruction_layout(shifted_cartesian_gate_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, layout: shifted_cartesian_gate_layout) -> None: ...
    def obstruct_coordinate(self, c: offset_coordinate) -> None: ...
    def obstruct_connection(self, src: offset_coordinate, tgt: offset_coordinate) -> None: ...
    def is_obstructed_coordinate(self, c: offset_coordinate) -> bool: ...
    def is_obstructed_connection(self, src: offset_coordinate, tgt: offset_coordinate) -> bool: ...
    def clear_obstructed_coordinate(self, c: offset_coordinate) -> None: ...
    def clear_obstructed_connection(self, src: offset_coordinate, tgt: offset_coordinate) -> None: ...
    def clear_obstructed_coordinates(self) -> None: ...
    def clear_obstructed_connections(self) -> None: ...

class hexagonal_obstruction_layout(hexagonal_gate_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, layout: hexagonal_gate_layout) -> None: ...
    def obstruct_coordinate(self, c: cube_coordinate) -> None: ...
    def obstruct_connection(self, src: cube_coordinate, tgt: cube_coordinate) -> None: ...
    def is_obstructed_coordinate(self, c: cube_coordinate) -> bool: ...
    def is_obstructed_connection(self, src: cube_coordinate, tgt: cube_coordinate) -> bool: ...
    def clear_obstructed_coordinate(self, c: cube_coordinate) -> None: ...
    def clear_obstructed_connection(self, src: cube_coordinate, tgt: cube_coordinate) -> None: ...
    def clear_obstructed_coordinates(self) -> None: ...
    def clear_obstructed_connections(self) -> None: ...

class qca_technology:
    class cell_type(Enum):
        EMPTY = ...
        NORMAL = ...
        INPUT = ...
        OUTPUT = ...
        CONST_0 = ...
        CONST_1 = ...

class inml_technology:
    class cell_type(Enum):
        EMPTY = ...
        NORMAL = ...
        INPUT = ...
        OUTPUT = ...
        SLANTED_EDGE_UP_MAGNET = ...
        SLANTED_EDGE_DOWN_MAGNET = ...
        INVERTER_MAGNET = ...
        CROSSWIRE_MAGNET = ...
        FANOUT_COUPLER_MAGNET = ...

class sidb_technology:
    class cell_type(Enum):
        EMPTY = ...
        NORMAL = ...
        INPUT = ...
        OUTPUT = ...
        LOGIC = ...

class qca_layout(clocked_cartesian_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate) -> None: ...
    @overload
    def __init__(
        self, dimension: offset_coordinate, clocking_scheme: str = "2DDWave", layout_name: str = ""
    ) -> None: ...
    def assign_cell_type(self, c: offset_coordinate, ct: qca_technology.cell_type) -> None: ...
    def get_cell_type(self, c: offset_coordinate) -> qca_technology.cell_type: ...
    def is_empty_cell(self, c: offset_coordinate) -> bool: ...
    def assign_cell_name(self, c: offset_coordinate, n: str) -> None: ...
    def get_cell_name(self, c: offset_coordinate) -> str | None: ...
    def set_layout_name(self, name: str) -> None: ...
    def get_layout_name(self) -> str: ...
    def num_cells(self) -> int: ...
    def is_empty(self) -> bool: ...
    def num_pis(self) -> int: ...
    def num_pos(self) -> int: ...
    def is_pi(self, c: offset_coordinate) -> bool: ...
    def is_po(self, c: offset_coordinate) -> bool: ...
    def cells(self) -> list[offset_coordinate]: ...
    def pis(self) -> list[offset_coordinate]: ...
    def pos(self) -> list[offset_coordinate]: ...
    def bounding_box_2d(self) -> tuple[offset_coordinate, offset_coordinate]: ...

class inml_layout(clocked_cartesian_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate) -> None: ...
    @overload
    def __init__(
        self, dimension: offset_coordinate, clocking_scheme: str = "2DDWave", layout_name: str = ""
    ) -> None: ...
    def assign_cell_type(self, c: offset_coordinate, ct: inml_technology.cell_type) -> None: ...
    def get_cell_type(self, c: offset_coordinate) -> inml_technology.cell_type: ...
    def is_empty_cell(self, c: offset_coordinate) -> bool: ...
    def assign_cell_name(self, c: offset_coordinate, n: str) -> None: ...
    def get_cell_name(self, c: offset_coordinate) -> str | None: ...
    def set_layout_name(self, name: str) -> None: ...
    def get_layout_name(self) -> str: ...
    def num_cells(self) -> int: ...
    def is_empty(self) -> bool: ...
    def num_pis(self) -> int: ...
    def num_pos(self) -> int: ...
    def is_pi(self, c: offset_coordinate) -> bool: ...
    def is_po(self, c: offset_coordinate) -> bool: ...
    def cells(self) -> list[offset_coordinate]: ...
    def pis(self) -> list[offset_coordinate]: ...
    def pos(self) -> list[offset_coordinate]: ...
    def bounding_box_2d(self) -> tuple[offset_coordinate, offset_coordinate]: ...

class sidb_layout(clocked_cartesian_layout):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dimension: offset_coordinate) -> None: ...
    @overload
    def __init__(
        self, dimension: offset_coordinate, clocking_scheme: str = "2DDWave", layout_name: str = ""
    ) -> None: ...
    def assign_cell_type(self, c: offset_coordinate, ct: sidb_technology.cell_type) -> None: ...
    def get_cell_type(self, c: offset_coordinate) -> sidb_technology.cell_type: ...
    def is_empty_cell(self, c: offset_coordinate) -> bool: ...
    def assign_cell_name(self, c: offset_coordinate, n: str) -> None: ...
    def get_cell_name(self, c: offset_coordinate) -> str | None: ...
    def set_layout_name(self, name: str) -> None: ...
    def get_layout_name(self) -> str: ...
    def num_cells(self) -> int: ...
    def is_empty(self) -> bool: ...
    def num_pis(self) -> int: ...
    def num_pos(self) -> int: ...
    def is_pi(self, c: offset_coordinate) -> bool: ...
    def is_po(self, c: offset_coordinate) -> bool: ...
    def cells(self) -> list[offset_coordinate]: ...
    def pis(self) -> list[offset_coordinate]: ...
    def pos(self) -> list[offset_coordinate]: ...
    def bounding_box_2d(self) -> tuple[offset_coordinate, offset_coordinate]: ...

# Networks

class technology_network_node:
    def __hash__(self) -> int: ...

class technology_network:
    def __init__(self) -> None: ...
    def size(self) -> int: ...
    def num_gates(self) -> int: ...
    def num_pis(self) -> int: ...
    def num_pos(self) -> int: ...
    def nodes(self) -> list[technology_network_node]: ...
    def gates(self) -> list[technology_network_node]: ...
    def pis(self) -> list[technology_network_node]: ...
    def pos(self) -> list[technology_network_node]: ...
    def fanins(self, n: technology_network_node) -> list[technology_network_node]: ...
    def is_constant(self, n: technology_network_node) -> bool: ...
    def is_pi(self, n: technology_network_node) -> bool: ...
    def is_po(self, n: technology_network_node) -> bool: ...
    def is_buf(self, n: technology_network_node) -> bool: ...
    def is_fanout(self, n: technology_network_node) -> bool: ...
    def is_inv(self, n: technology_network_node) -> bool: ...
    def is_and(self, n: technology_network_node) -> bool: ...
    def is_or(self, n: technology_network_node) -> bool: ...
    def is_xor(self, n: technology_network_node) -> bool: ...
    def is_maj(self, n: technology_network_node) -> bool: ...
    def is_nand(self, n: technology_network_node) -> bool: ...
    def is_nor(self, n: technology_network_node) -> bool: ...
    def is_xnor(self, n: technology_network_node) -> bool: ...
    def has_name(self, n: technology_network_node) -> bool: ...
    def get_name(self, n: technology_network_node) -> str | None: ...
    def has_output_name(self, index: int) -> bool: ...
    def get_output_name(self, index: int) -> str | None: ...
    def po_index(self, n: technology_network_node) -> int: ...
    def po_at(self, index: int) -> technology_network_node: ...

def read_technology_network(filename: str) -> technology_network: ...

class dynamic_truth_table:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, num_vars: int) -> None: ...
    def num_vars(self) -> int: ...
    def num_blocks(self) -> int: ...
    def num_bits(self) -> int: ...

# Algorithms

## network transformation

class substitution_strategy:
    BREADTH: int
    DEPTH: int

class fanout_substitution_params:
    def __init__(self) -> None: ...

    strategy: substitution_strategy
    degree: int | None
    threshold: int | None

def fanout_substitution(
    network: technology_network, params: fanout_substitution_params | None = ...
) -> technology_network: ...
def is_fanout_substituted(network: technology_network, params: fanout_substitution_params | None = ...) -> bool: ...

class network_balancing_params:
    def __init__(self) -> None: ...

    unify_outputs: bool

def network_balancing(
    network: technology_network, params: network_balancing_params | None = ...
) -> technology_network: ...
def is_balanced(network: technology_network, params: network_balancing_params | None = ...) -> bool: ...

class technology_mapping_params:
    def __init__(self) -> None: ...

    decay: float | None
    inv: bool | None
    and2: bool | None
    nand2: bool | None
    or2: bool | None
    nor2: bool | None
    xor2: bool | None
    xnor2: bool | None
    and3: bool | None
    xor_and: bool | None
    or_and: bool | None
    onehot: bool | None
    maj3: bool | None
    gamble: bool | None
    dot: bool | None
    mux: bool | None
    and_xor: bool | None

class technology_mapping_stats:
    def __init__(self) -> None: ...
    def report(self) -> None: ...

def and_or_not() -> technology_mapping_params: ...
def and_or_not_maj() -> technology_mapping_params: ...
def all_standard_2_input_functions() -> technology_mapping_params: ...
def all_standard_3_input_functions() -> technology_mapping_params: ...
def all_supported_standard_functions() -> technology_mapping_params: ...
def technology_mapping(
    network: technology_network,
    params: technology_mapping_params | None = ...,
    stats: technology_mapping_stats | None = None,
) -> technology_network: ...

## path finding

@overload
def manhattan_distance(
    layout: cartesian_layout | shifted_cartesian_layout, source: offset_coordinate, target: offset_coordinate
) -> int: ...
@overload
def manhattan_distance(layout: hexagonal_layout, source: cube_coordinate, target: cube_coordinate) -> int: ...
@overload
def euclidean_distance(
    layout: cartesian_layout | shifted_cartesian_layout, source: offset_coordinate, target: offset_coordinate
) -> float: ...
@overload
def euclidean_distance(layout: hexagonal_layout, source: cube_coordinate, target: cube_coordinate) -> float: ...
@overload
def squared_euclidean_distance(
    layout: cartesian_layout | shifted_cartesian_layout, source: offset_coordinate, target: offset_coordinate
) -> float: ...
@overload
def squared_euclidean_distance(layout: hexagonal_layout, source: cube_coordinate, target: cube_coordinate) -> float: ...
@overload
def twoddwave_distance(
    layout: cartesian_layout | shifted_cartesian_layout, source: offset_coordinate, target: offset_coordinate
) -> int: ...
@overload
def twoddwave_distance(layout: hexagonal_layout, source: cube_coordinate, target: cube_coordinate) -> int: ...
@overload
def chebyshev_distance(
    layout: cartesian_layout | shifted_cartesian_layout, source: offset_coordinate, target: offset_coordinate
) -> int: ...
@overload
def chebyshev_distance(layout: hexagonal_layout, source: cube_coordinate, target: cube_coordinate) -> int: ...

class a_star_params:
    def __init__(self) -> None: ...

    crossings: bool

@overload
def a_star(
    layout: cartesian_obstruction_layout
    | cartesian_gate_layout
    | cartesian_layout
    | shifted_cartesian_obstruction_layout
    | shifted_cartesian_gate_layout
    | shifted_cartesian_layout,
    source: offset_coordinate,
    target: offset_coordinate,
    params: a_star_params | None = ...,
) -> list[offset_coordinate]: ...
@overload
def a_star(
    layout: hexagonal_obstruction_layout | hexagonal_gate_layout | hexagonal_layout,
    source: cube_coordinate,
    target: cube_coordinate,
    params: a_star_params | None = ...,
) -> list[cube_coordinate]: ...

class enumerate_all_paths_params:
    def __init__(self) -> None: ...

    crossings: bool

@overload
def enumerate_all_paths(
    layout: cartesian_obstruction_layout
    | cartesian_gate_layout
    | cartesian_layout
    | shifted_cartesian_obstruction_layout
    | shifted_cartesian_gate_layout
    | shifted_cartesian_layout,
    source: offset_coordinate,
    target: offset_coordinate,
    params: enumerate_all_paths_params | None = ...,
) -> list[list[offset_coordinate]]: ...
@overload
def enumerate_all_paths(
    layout: hexagonal_obstruction_layout | hexagonal_gate_layout | hexagonal_layout,
    source: cube_coordinate,
    target: cube_coordinate,
    params: enumerate_all_paths_params | None = ...,
) -> list[list[cube_coordinate]]: ...

class yen_k_shortest_paths_params:
    def __init__(self) -> None: ...

    astar_params: a_star_params

@overload
def yen_k_shortest_paths(
    layout: cartesian_obstruction_layout
    | cartesian_gate_layout
    | cartesian_layout
    | shifted_cartesian_obstruction_layout
    | shifted_cartesian_gate_layout
    | shifted_cartesian_layout,
    source: offset_coordinate,
    target: offset_coordinate,
    k: int,
    params: yen_k_shortest_paths_params | None = ...,
) -> list[list[offset_coordinate]]: ...
@overload
def yen_k_shortest_paths(
    layout: hexagonal_obstruction_layout | hexagonal_gate_layout | hexagonal_layout,
    source: cube_coordinate,
    target: cube_coordinate,
    k: int,
    params: yen_k_shortest_paths_params | None = ...,
) -> list[list[cube_coordinate]]: ...

# physical design

def apply_qca_one_library(layout: cartesian_gate_layout) -> qca_layout: ...
def apply_topolinano_library(layout: shifted_cartesian_gate_layout) -> inml_layout: ...
def apply_bestagon_library(layout: hexagonal_gate_layout) -> sidb_layout: ...

class graph_coloring_engine(Enum):
    MCS = ...
    DSATUR = ...
    LMXRLF = ...
    TABUCOL = ...
    SAT = ...

class color_routing_params:
    def __init__(self) -> None: ...

    conduct_partial_routing: bool
    crossings: bool
    path_limit: int | None
    engine: graph_coloring_engine
    partial_sat: bool

@overload
def color_routing(
    layout: cartesian_obstruction_layout
    | cartesian_gate_layout
    | shifted_cartesian_obstruction_layout
    | shifted_cartesian_gate_layout,
    objectives: list[tuple[offset_coordinate, offset_coordinate]],
    params: color_routing_params | None = ...,
) -> bool: ...
@overload
def color_routing(
    layout: hexagonal_obstruction_layout | hexagonal_gate_layout,
    objectives: list[tuple[cube_coordinate, cube_coordinate]],
    params: color_routing_params | None = ...,
) -> bool: ...

class technology_constraints(Enum):
    NONE: ...
    TOPOLINANO: ...

class exact_params:
    def __init__(self) -> None: ...

    scheme: str
    upper_bound_area: int
    upper_bound_x: int
    upper_bound_y: int
    fixed_size: bool
    num_threads: int
    crossings: bool
    border_io: bool
    straight_inverters: bool
    desynchronize: bool
    minimize_wires: bool
    minimize_crossings: bool
    timeout: int
    technology_specifics: technology_constraints

class exact_stats:
    time_total: float
    x_size: int
    y_size: int
    num_gates: int
    num_wires: int
    num_crossings: int
    num_aspect_ratios: int

    def __init__(self) -> None: ...
    def report(self) -> str: ...

def exact_cartesian(
    network: technology_network, parameters: exact_params | None = None, statistics: exact_stats | None = None
) -> cartesian_gate_layout: ...
def exact_shifted_cartesian(
    network: technology_network, parameters: exact_params | None = None, statistics: exact_stats | None = None
) -> shifted_cartesian_gate_layout: ...
def exact_hexagonal(
    network: technology_network, parameters: exact_params | None = None, statistics: exact_stats | None = None
) -> hexagonal_gate_layout: ...

class orthogonal_params:
    def __init__(self) -> None: ...

class orthogonal_stats:
    time_total: float
    x_size: int
    y_size: int
    num_gates: int
    num_wires: int
    num_crossings: int

    def __init__(self) -> None: ...
    def report(self) -> None: ...

def orthogonal(
    network: technology_network, parameters: orthogonal_params | None = ..., statistics: orthogonal_stats | None = None
) -> cartesian_gate_layout: ...

# properties

def critical_path_length_and_throughput(
    layout: cartesian_gate_layout | shifted_cartesian_gate_layout | hexagonal_gate_layout,
) -> tuple[int, int]: ...

# TODO design_sidb_gates, gold, hexagonalization, PLO, wiring reduction

## simulation

### logic

@overload
def simulate(network: technology_network) -> dict[str, list[bool]]: ...
@overload
def simulate(
    layout: cartesian_gate_layout | shifted_cartesian_gate_layout | hexagonal_gate_layout,
) -> dict[str, list[bool]]: ...

### sidb

# TODO all SiDB simulation

## verification

class gate_level_drv_params:
    def __init__(self) -> None: ...

    unplaced_nodes: bool
    placed_dead_nodes: bool
    non_adjacent_connections: bool
    missing_connections: bool
    crossing_gates: bool
    clocked_data_flow: bool
    has_io: bool
    empty_io: bool
    io_pins: bool
    border_io: bool

def gate_level_drvs(
    layout: cartesian_gate_layout | shifted_cartesian_gate_layout | hexagonal_gate_layout,
    params: gate_level_drv_params | None = ...,
    print_report: bool | None = False,
) -> tuple[int, int]: ...

class eq_type(Enum):
    NO = ...
    WEAK = ...
    STRONG = ...

class equivalence_checking_stats:
    def __init__(self) -> None: ...

    eq: eq_type
    tp_spec: int
    tp_impl: int
    tp_diff: int
    counter_example: list[bool]
    runtime: float

def equivalence_checking(
    specification: technology_network | cartesian_gate_layout | shifted_cartesian_gate_layout | hexagonal_gate_layout,
    implementation: technology_network | cartesian_gate_layout | shifted_cartesian_gate_layout | hexagonal_gate_layout,
    statistics: equivalence_checking_stats | None = None,
) -> eq_type: ...

# In/Out

class fgl_parsing_error(RuntimeError): ...

def read_cartesian_fgl_layout(filename: str, layout_name: str = "") -> cartesian_gate_layout: ...
def read_shifted_cartesian_fgl_layout(filename: str, layout_name: str = "") -> shifted_cartesian_gate_layout: ...
def read_hexagonal_fgl_layout(filename: str, layout_name: str = "") -> hexagonal_gate_layout: ...

class unsupported_character_exception(Exception): ...
class undefined_cell_label_exception(Exception): ...
class unrecognized_cell_definition_exception(Exception): ...

def read_fqca_layout(filename: str, layout_name: str = "") -> qca_layout: ...

# TODO read_sqd_layout

def write_dot_network(network: technology_network, filename: str) -> None: ...
def write_dot_layout(
    layout: cartesian_gate_layout | shifted_cartesian_gate_layout | hexagonal_gate_layout, filename: str
) -> None: ...
def write_fgl_layout(
    layout: cartesian_gate_layout | shifted_cartesian_gate_layout | hexagonal_gate_layout, filename: str
) -> None: ...

class out_of_cell_names_exception(IndexError): ...

class write_fqca_layout_params:
    def __init__(self) -> None: ...

    create_inter_layer_via_cells: bool

def write_fqca_layout(
    layout: cartesian_gate_layout | shifted_cartesian_gate_layout | hexagonal_gate_layout,
    filename: str,
    params: write_fqca_layout_params | None = ...,
) -> None: ...

# TODO write_operational_domain

class write_qca_layout_params:
    def __init__(self) -> None: ...

    create_inter_layer_via_cells: bool

def write_qca_layout(layout: qca_layout, filename: str, params: write_qca_layout_params | None = ...) -> None: ...
def write_qcc_layout(layout: inml_layout, filename: str) -> None: ...
def write_qll_layout(layout: qca_layout | inml_layout, filename: str) -> None: ...
def write_sqd_layout(
    # layout: Union[sidb_111_lattice, sidb_100_lattice, sidb_layout], # TODO move to this layout spec as soon as lattices are added
    layout: sidb_layout,
    filename: str,
) -> None: ...
def write_sqd_sim_result(layout: sidb_layout, filename: str) -> None: ...

# Technology

@overload
def area(layout: qca_layout, width: int = 18, height: int = 18, hspace: int = 2, vspace: int = 2) -> float: ...
@overload
def area(layout: inml_layout, width: int = 50, height: int = 100, hspace: int = 10, vspace: int = 25) -> float: ...
@overload
def area(
    layout: sidb_layout, width: float = 0.0, height: float = 0.0, hspace: float = 0.384, vspace: float = 0.384
) -> float: ...

# TODO all SiDB technology

class sidb_simulation_parameters:
    epsilon_r: float
    lambda_tf: float
    mu_minus: float
    base: int

    def __init__(
        self,
        base_number: int = 3,
        mu_minus: float = -0.32,
        relative_permittivity: float = 5.6,
        screening_distance: float = 5.0,
    ) -> None: ...
    def k(self) -> float: ...
    def mu_plus(self) -> float: ...

# Utils

# TODO all utils
